<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Habbo Clone</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #222;
}

canvas {
  display: block;
  cursor: pointer;
  image-rendering: pixelated; /* Zorgt voor scherpe weergave op alle schermen */
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Algemene knoppen */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
button {
  font-family: Arial, sans-serif;
  cursor: pointer;
  border: none; /* Geen rand */
  background: transparent; /* Geen achtergrond */
  padding: 0;
}

/* Algemene stijl voor alle iconen in knoppen */
button img {
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Footer / chat input */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#footer {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 50px;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center; /* Centreer de chat-groep */
  padding: 0 20px; /* Wat ruimte aan de zijkanten */
  box-sizing: border-box;
}

.footer-left, .footer-right {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  gap: 10px;
  width: 400px; /* Breder voor zoom knoppen */
}
.footer-left {
  left: 20px;
  gap: 20px; /* Meer ruimte tussen knoppen */
}
.footer-right { right: 20px; justify-content: flex-end; }

#chatInput {
  width: 300px;
  padding: 6px;
  font-size: 14px;
  border-radius: 24px;
  border: none;
  outline: none;
}

#charCounter {
  color: #aaa;
  font-size: 12px;
  font-family: Arial, sans-serif;
  min-width: 60px;
  text-align: left;
}

/* Nieuwe container voor de hele chat-groep */
.chat-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

#openChatLog, #buildBtn, #inventoryBtn, #adminBtn, #cheatBtn, #roomsBtn, #myRoomBtn, #friendsBtn, #zoomIn, #zoomOut, #centerCam {
  width: 24px;
  height: 24px;
}

#friendsBtn,
#myRoomBtn,
#roomsBtn {
  margin-left: 15px;
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* Bouwmenu */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#buildMenu {
  position: absolute; /* Nodig voor verplaatsen */
  left: 40px;
  top: 80px;
  /* 60px voor categorieÃ«n + 450px voor content */
  width: 510px;
  height: 470px; /* Iets hoger gemaakt voor de color picker */
  background: rgba(17, 17, 17, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none; /* Start verborgen, wordt 'flex' in JS */
  z-index: 20;
  overflow: hidden; /* Zorgt dat content binnen de afgeronde hoeken blijft */
  flex-direction: row; /* CategorieÃ«n links, content rechts */
}

#buildCategoryMenu {
  width: 60px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 20px; /* Meer ruimte */
  align-items: center; /* Centreer items voor vierkante knoppen */
}

.category-btn {
  width: 24px;
  height: 24px;
  background: transparent;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
}

#buildMainContent {
  width: 450px;
}

#objectCategoryView {
  display: flex; /* Standaard zichtbaar */
  flex-direction: column;
  height: 100%;
}

#colorCategoryView {
  display: none; /* Standaard verborgen */
  box-sizing: border-box;
  height: calc(100% - 36px); /* Volledige hoogte minus de header */
  display: flex;
  flex-direction: row;
}

#objectSubCategoryMenu {
  display: flex;
  flex-direction: column;
  gap: 20px; /* Meer ruimte */
  width: 60px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
  align-items: center; /* Horizontaal centreren */
}


#colorTools {
  display: flex;
  flex-direction: column;
  gap: 20px;
  width: 55px;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.2);
  padding: 10px;
  box-sizing: border-box;
  align-items: center;
}

#colorPickerWrapper {
  flex-grow: 1;
  padding: 10px;
  display: flex;
  flex-direction: column; /* Zorgt ervoor dat de color picker en details onder elkaar staan */
  justify-content: center;
  align-items: center;
}

#colorPicker {
  width: 100%;
  height: 100%;
  cursor: pointer;
  -webkit-color-swatch-wrapper { padding: 0; } /* Webkit specifieke styling */
  border: none;
  background: none;
}

#colorDetails {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

#colorPreview {
  width: 40px;
  height: 40px;
  border: 1px solid #fff;
  border-radius: 4px;
}

#hexInput {
  width: 100px;
  padding: 8px;
  background: #222;
  border: 1px solid #555;
  border-radius: 4px;
  color: #fff;
  font-family: monospace;
  font-size: 14px;
}

#buildTools {
  padding: 5px 10px; /* Minder verticale padding */
  /* border-top is nu border-bottom op de header */
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* Lijn knoppen rechts uit */
  background: rgba(0,0,0,0.1); /* Lichte achtergrond voor contrast */
  border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Scheidingslijn */
}

.tool-btn {
  width: 24px;
  height: 24px;
  background: transparent;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
}
#buildMenuHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;
  background: #1a1a1a;
  border-radius: 10px 10px 0 0;
  cursor: move;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Scheidingslijn */
  user-select: none;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#buildMenuContent {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Forceer 3 kolommen die de ruimte vullen */
  gap: 10px;
  padding: 10px; /* Padding voor de content zelf */
  height: calc(100% - 51px); /* Hoogte minus de dunnere #buildTools balk (50px + 1px border) */
  overflow-y: auto;
  box-sizing: border-box;
  justify-items: center; /* Centreer items binnen hun grid cel */
  align-items: start; /* Items bovenaan beginnen in hun cell */
  align-content: start; /* Zorgt dat rijen bovenaan beginnen en niet verspreiden */
}

.build-item {
  background: rgba(0, 0, 0, 0.4); /* Donkerder met transparantie */
  padding: 10px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between; /* Plaatje boven, tekst onder */
  gap: 8px;
  color: white;
  font-size: 12px;
  font-family: Arial, sans-serif; /* Consistent lettertype */
  width: 90px;
  height: 110px; /* Vaste hoogte teruggezet */
}


.build-item:hover {
  background: #555;
}

.build-item.selected {
  border-color: white;
}

#buildMenuHeader, #chatLogHeader, #inventoryHeader, #pongHeader, #shopHeader, #containerHeader, #pouchHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.close-btn {
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}

.build-item img {
  height: 64px; /* Vaste hoogte voor consistentie */
  max-width: 100%;
  object-fit: contain;
  image-rendering: pixelated;
}

/* NIEUW: Stijl voor inventory items (alleen plaatje, geen tekst) */
.inventory-item {
  background: transparent;
  border-radius: 6px;
  cursor: grab;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  width: auto;
  height: auto;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  transform: scale(6);
  transform-origin: top left;
}
.inventory-item:hover {
  background: transparent;
}
.inventory-item img {
  display: block;
  pointer-events: none;
  image-rendering: pixelated;
}
/* Fix voor shop output items zodat ze zichtbaar blijven */
#shopOutput .inventory-item {
  transform: scale(1);
  margin: 0 2px;
}
#shopOutput .inventory-item img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
/* Fix voor vicinity items zodat ze netjes in rijen staan */
#vicinityContent .inventory-item {
  transform: scale(1);
  margin: 0;
  width: 100% !important;
  height: 64px !important;
}
#vicinityContent .inventory-item img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

#chatLog {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 320px;
  height: 400px;

  background: rgba(17, 17, 17, 0.85); /* Transparantie toegevoegd */
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85); /* Transparantie toegevoegd */
  border-radius: 10px;

  font-family: Arial;
  font-size: 14px;

  display: none;
  overflow: hidden;
  z-index: 20;
}

#inventory {
  position: absolute;
  left: 150px;
  top: 120px;
  width: 400px; /* Breder gemaakt */
  height: 450px; /* Langer gemaakt */
  background: rgba(17, 17, 17, 0.85); /* Transparantie toegevoegd */
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85); /* Transparantie toegevoegd */
  border-radius: 10px;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none; /* Start verborgen */
  overflow: hidden;
  z-index: 20;
  flex-direction: column; /* Zorgt dat header en content onder elkaar staan */
}

#chatLogHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;

  background: #1a1a1a;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px 10px 0 0;

  cursor: move;
  user-select: none;
}

#inventoryHeader, #pongHeader, #shopHeader, #containerHeader, #pouchHeader, #vicinityHeader {
  height: 36px;
  line-height: 36px;
  padding: 0 12px;
  background: #1a1a1a;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px 10px 0 0;
  cursor: move;
  user-select: none;
}

#inventoryTools {
  padding: 5px 10px; /* Minder verticale padding */
  display: flex;
  gap: 10px;
  justify-content: space-between; /* Wallet links, dagboek rechts */
  align-items: center; /* Verticaal centreren */
  background: rgba(0,0,0,0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

#wallet {
  font-family: Arial, sans-serif;
  font-size: 14px;
  color: white; /* Goud-achtige kleur */
  padding: 5px 10px;
  border-radius: 5px;
}

#transactionFeed {
  font-family: Arial, sans-serif;
  font-size: 12px; /* 2px kleiner dan wallet (14px) */
  opacity: 0;
}

#chatLogContent {
  height: calc(100% - 36px);
  padding: 10px;
  overflow-y: auto;
  box-sizing: border-box;
}

#inventoryContent {
  height: calc(100% - 36px - 51px); /* Hoogte minus header en dunnere tools paneel */
  padding: 10px;
  overflow: hidden; /* Scrollen uitgeschakeld zoals gevraagd */
  box-sizing: border-box;
  display: block; /* Was grid, nu block voor vrije plaatsing */
  position: relative; /* Zodat items absoluut gepositioneerd kunnen worden */
}

/* â”€â”€â”€â”€â”€ Pong Minigame â”€â”€â”€â”€â”€ */
#pongGame {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 600px; /* Breder gemaakt zoals een tafel */
  height: 336px; /* 300 canvas + 36 header */
  background: rgba(17, 17, 17, 0.85); /* Subtiele transparantie */
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 30; /* Bovenop alles */
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}
#pongScoreboard {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(0,0,0,0.2);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  font-size: 14px;
}

#pongCanvas {
  background: rgba(0, 0, 0, 0.6); /* Half-transparant speelveld */
  width: 100%;
  height: 264px; /* Aangepast voor scorebord */
  cursor: default; /* Cursor wordt via JS geregeld */
}

/* Achtergrond voor Pong om clicks af te vangen en cursor te verbergen */
#pongBackdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 29; /* Net onder de pong game (30) */
  display: none;
}

/* Notificatie paneel */
#notification {
  position: absolute;
  bottom: 100px; /* Boven de status bar */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(17, 17, 17, 0.85);
  color: white;
  padding: 15px 25px;
  border-radius: 10px;
  border: 1px solid rgba(255, 255, 255, 0.85);
  font-family: Arial, sans-serif;
  font-size: 14px;
  z-index: 100;
  pointer-events: none; /* Klik er doorheen */
  opacity: 0;
  transition: opacity 0.5s ease-in-out;
}

#voteCounter {
  position: absolute;
  top: 100px;
  right: 20px;
  background: rgba(17, 17, 17, 0.85);
  color: white;
  padding: 10px 15px;
  border-radius: 10px;
  border: 1px solid rgba(255, 255, 255, 0.85);
  font-family: Arial, sans-serif;
  font-size: 14px;
  z-index: 95;
  display: none;
  text-align: center;
}

/* â”€â”€â”€â”€â”€ Winkel Venster â”€â”€â”€â”€â”€ */
#shopWindow {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 380px; /* Breder gemaakt voor mooiere spacing */
  height: 550px;
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 25;
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
}

#shopContent {
  padding: 10px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: max-content;
  gap: 5px;
  overflow-y: auto;
  overflow-x: hidden;
  justify-items: center;
  height: 300px;
}

/* â”€â”€â”€â”€â”€ Kamers Venster â”€â”€â”€â”€â”€ */
#roomsWindow {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 400px;
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 25;
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#roomsContent {
  padding: 10px;
  overflow-y: auto;
  height: calc(100% - 36px);
  font-size: 10px;
}

/* â”€â”€â”€â”€â”€ Mijn Kamer Venster â”€â”€â”€â”€â”€ */
#myRoomWindow {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 350px; /* Iets hoger voor de lijst */
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 25;
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

/* â”€â”€â”€â”€â”€ Kamer Spelers Venster â”€â”€â”€â”€â”€ */
#roomPlayersWindow {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 350px; /* Iets hoger voor de lijst */
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 25;
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 10px;
}

#friendsContent {
  padding: 20px;
}

#roomPlayersContent {
  padding: 20px;
}

/* â”€â”€â”€â”€â”€ Vrienden Venster â”€â”€â”€â”€â”€ */
#friendsWindow {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 350px; /* Iets hoger voor de lijst */
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  display: none;
  z-index: 25;
  flex-direction: column;
  overflow: hidden;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#myRoomContent {
  padding: 20px;
}

/* â”€â”€â”€â”€â”€ Role Selector â”€â”€â”€â”€â”€ */
#roleSelector {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 3000;
  color: white;
  font-family: Arial, sans-serif;
}
.role-btn {
  padding: 20px 40px;
  font-size: 20px;
  cursor: pointer;
  background: #333;
  color: white;
  border: 2px solid #fff;
  border-radius: 8px;
  transition: background 0.2s;
  margin: 0 10px;
}
.role-btn:hover {
  background: #555;
}

#shopOutput {
  flex-grow: 1;
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.2);
  padding: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  margin: 10px;
  border-radius: 6px;
  min-height: 100px;
}

/* â”€â”€â”€â”€â”€ Container Venster â”€â”€â”€â”€â”€ */
#containerWindow {
  position: absolute;
  left: 600px; /* Rechts van inventory */
  top: 120px;
  width: 260px;
  height: 300px;
  background: rgba(17, 17, 17, 0.85);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none;
  overflow: hidden;
  z-index: 20;
  flex-direction: column;
}

#containerTools {
  padding: 5px 10px;
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* Knoppen rechts uitlijnen */
  align-items: center;
  background: rgba(0,0,0,0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

/* â”€â”€â”€â”€â”€ Pouch Venster â”€â”€â”€â”€â”€ */
#pouchWindow {
  position: absolute;
  left: 200px;
  top: 150px;
  width: 260px;
  height: 300px;
  background: rgba(17, 17, 17, 0.85);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none;
  overflow: hidden;
  z-index: 20;
  flex-direction: column;
}

/* â”€â”€â”€â”€â”€ Vicinity Venster â”€â”€â”€â”€â”€ */
#vicinityWindow {
  position: absolute;
  left: 560px; /* Rechts van inventory (150 + 400 + 10) */
  top: 120px;
  width: 400px;
  height: 450px; /* Zelfde hoogte als inventory */
  background: rgba(17, 17, 17, 0.85);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.85);
  border-radius: 10px;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: none;
  overflow: hidden;
  z-index: 20;
  flex-direction: column;
}

/* â”€â”€â”€â”€â”€ Custom scrollbar (WebKit) voor Chat & Bouwmenu â”€â”€â”€â”€â”€ */
#chatLogContent::-webkit-scrollbar,
#buildMenuContent::-webkit-scrollbar,
#inventoryContent::-webkit-scrollbar,
#vicinityContent::-webkit-scrollbar,
#roomCategoryView::-webkit-scrollbar,
#roomList::-webkit-scrollbar,
#shopContent::-webkit-scrollbar {
  width: 6px;
}

#chatLogContent::-webkit-scrollbar-track,
#buildMenuContent::-webkit-scrollbar-track,
#inventoryContent::-webkit-scrollbar-track,
#vicinityContent::-webkit-scrollbar-track,
#roomCategoryView::-webkit-scrollbar-track,
#roomList::-webkit-scrollbar-track,
#shopContent::-webkit-scrollbar-track {
  background: transparent;
}

#chatLogContent::-webkit-scrollbar-thumb,
#buildMenuContent::-webkit-scrollbar-thumb,
#inventoryContent::-webkit-scrollbar-thumb,
#vicinityContent::-webkit-scrollbar-thumb,
#roomCategoryView::-webkit-scrollbar-thumb,
#roomList::-webkit-scrollbar-thumb,
#shopContent::-webkit-scrollbar-thumb {
  background: white;
  border-radius: 6px;
}

/* â”€â”€â”€â”€â”€ Custom scrollbar (Firefox) voor Chat & Bouwmenu â”€â”€â”€â”€â”€ */
#chatLogContent,
#buildMenuContent,
#inventoryContent,
#vicinityContent,
#roomCategoryView,
#roomList,
#shopContent {
  scrollbar-width: thin;
  scrollbar-color: white transparent;
}

/* â”€â”€â”€â”€â”€ Upload Modal â”€â”€â”€â”€â”€ */
#uploadModal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(17, 17, 17, 0.95);
  border: 1px solid white;
  padding: 20px;
  border-radius: 10px;
  z-index: 100;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
  width: 400px;
  display: none; /* Wordt 'flex' via JS */
  flex-direction: column;
  gap: 15px;
}

#pongNotification {
    text-align: center;
}

#customObjectName {
  width: 100%;
  padding: 8px;
  background: #333;
  border: 1px solid #555;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
  border-radius: 4px;
  box-sizing: border-box;
}

#templateGrid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  max-height: 300px;
  overflow-y: auto;
}

/* â”€â”€â”€â”€â”€ Pop-up Styling â”€â”€â”€â”€â”€ */
.popup-content { text-align: center; }
.popup-header { margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 8px; }
.popup-sub { margin-bottom: 10px; }
.popup-actions { display: flex; gap: 10px; justify-content: center; }

.popup-btn { padding: 5px 15px; color: white; border: none; border-radius: 50px; cursor: pointer; font-family: Arial, sans-serif; font-size: 10px; }
.popup-btn.confirm { background: transparent; border: 1px solid white; }
.popup-btn.confirm:hover { background: white; color: black; }
.popup-btn.deny { background: transparent; border: 1px solid #f44336; }
.popup-btn.deny:hover { background: #f44336; color: white; }
.popup-btn.neutral { background: transparent; border: 1px solid white; }
.popup-btn.neutral:hover { background: white; color: black; }

.ctx-item:hover { background-color: #444; }

.popup-input { width: 200px; padding: 8px; background: #333; border: 1px solid #555; color: white; border-radius: 50px; margin-bottom: 10px; font-family: Arial, sans-serif; }

/* â”€â”€â”€â”€â”€ Status Bar (Roken etc.) â”€â”€â”€â”€â”€ */
#statusBarContainer {
  position: absolute;
  bottom: 60px; /* Boven de footer (50px) + 10px marge */
  left: 50%;
  transform: translateX(-50%);
  width: 300px;
  height: 20px;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid rgb(255, 255, 255);
  border-radius: 8px;
  display: none; /* Start verborgen */
  overflow: hidden;
  z-index: 90;
}
#statusBarFill {
  height: 100%;
  width: 0%;
  background: #7bff00;
  transition: width 0.1s linear;
}
#statusBarText {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 10px;
  text-shadow: 1px 1px 0 #000;
}

</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
<script src="/socket.io/socket.io.js"></script>

<div id="statusBarContainer">
    <div id="statusBarFill"></div>
    <div id="statusBarText">Actie</div>
</div>

<div id="footer">

  <div class="footer-left">
    <button id="adminBtn" title="Admin"><img src="icons/admin.png"></button>
    <button id="cheatBtn" title="Cheats"><img src="icons/cheat.png"></button>
    <div style="display:flex; gap:10px; align-items:center;">
        <button id="zoomOut" title="Zoom Out"><img src="icons/min.png"></button>
        <button id="centerCam" title="Center"><img src="icons/center.png"></button>
        <button id="zoomIn" title="Zoom In"><img src="icons/max.png"></button>
    </div>
    <button id="buildBtn" title="Bouwen"><img src="icons/buildmenu.png"></button>
    <button id="inventoryBtn" title="Inventaris"><img src="icons/inventory.png"></button>
  </div>

  <div class="chat-group">
    <input id="chatInput" type="text" placeholder="Typ hier je bericht..." />
    <div id="charCounter">0 / 80</div>
    <button id="openChatLog" title="Chat"><img src="icons/chat.png"></button>
    <button id="friendsBtn" title="Vrienden"><img src="icons/heart.png"></button>
    <button id="myRoomBtn" title="Mijn Kamer Instellingen"><img src="icons/myroom.png"></button>
    <button id="roomsBtn" title="Kamers"><img src="icons/rooms.png"></button>
  </div>

</div>

<div id="roleSelector">
  <h1 style="margin-bottom: 40px;">Kies je rol</h1>
  <div style="display:flex;">
      <button id="rolePlayerBtn" class="role-btn">Speler</button>
      <button id="roleAdminBtn" class="role-btn">Admin</button>
  </div>
</div>

<div id="buildMenu" style="display: none;">
  <div id="buildCategoryMenu">
    <button class="category-btn selected" data-category="objecten" title="Objecten"><img src="icons/object_active.png"></button>
    <button class="category-btn" data-category="kleur" title="Kleur"><img src="icons/color.png"></button>
    <button class="category-btn" id="adminRoomBtn" data-category="kamers" title="Kamers" style="display: none;"><img src="icons/new_room.png"></button>
  </div>

  <div id="buildMainContent">
    <div id="buildMenuHeader"> 
        <span>Bouwmodus</span> 
        <span class="close-btn" id="closeBuildMenuBtn">Ã—</span>
    </div>

    <!-- Weergave voor Objecten Categorie -->
    <div id="objectCategoryView" style="flex-direction: row;"> <!-- Aangepast voor sub-categorie menu -->
      <div id="objectSubCategoryMenu">
        <!-- Sub-categorie knoppen worden hier dynamisch toegevoegd -->
      </div>
      <div style="width: 100%; height: 100%;"> <!-- Wrapper voor tools en content -->
        <div id="buildTools">
          <button id="moveToolBtn" class="tool-btn" title="Verplaatsen"><img src="icons/place.png"></button>
          <button id="deleteToolBtn" class="tool-btn" title="Verwijderen"><img src="icons/trash.png"></button>
          <button id="uploadToolBtn" class="tool-btn" title="Upload Custom Item" style="display:none;"><img src="icons/add.png"></button>
        </div>
        <div id="buildMenuContent">
          <!-- Items worden hier dynamisch toegevoegd -->
        </div>
      </div>
    </div>

    <!-- Weergave voor Kleur Categorie -->
    <div id="colorCategoryView">
      <div id="colorTools">
        <button class="tool-btn selected" data-tool="brush" title="Kwast"><img src="icons/paint_active.png"></button> 
        <button class="tool-btn" data-tool="bucket" title="Verfemmer"><img src="icons/fill.png"></button>
        <button class="tool-btn" data-tool="picker" title="Pipet"><img src="icons/pipet.png"></button>
      </div>
      <div id="colorPickerWrapper">
        <div id="color-picker-container"></div>
        <div id="colorDetails">
          <div id="colorPreview"></div>
          <input type="text" id="hexInput" maxlength="7">
        </div>
      </div>
    </div>

    <!-- Weergave voor Kamers Categorie -->
    <div id="roomCategoryView" style="display: none; padding: 20px; color: white; font-family: Arial; flex-direction: column; gap: 15px; height: calc(100% - 36px); overflow-y: auto; box-sizing: border-box;">
        <h4 style="margin: 0 0 5px 0; font-weight: normal;">Kamer Aanmaken</h4>
        
        <div style="margin-bottom: 15px;">
            <input type="text" id="roomNameInput" placeholder="Naam" style="width: 50%; padding: 8px; background: #333; border: 1px solid #666; color: white; border-radius: 4px; font-size: 14px;">
        </div>

        <div style="margin-bottom: 15px;">
            <select id="roomSizeSelect" style="width: 25%; padding: 8px; background: #333; border: 1px solid #666; color: white; border-radius: 4px; font-size: 10px;">
                <option value="5">5x5</option>
                <option value="5x10">5x10</option>
                <option value="10" selected>10x10</option>
                <option value="20">20x20</option>
                <option value="30">30x30</option>
            </select>
        </div>

        <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
            <!-- Always Online Toggle -->
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="font-size:14px;">Online</span>
                <img id="adminAlwaysOnlineToggle" src="icons/rood.png" style="width:24px; height:24px; cursor:pointer;" title="Altijd Online">
            </div>
            
            <!-- Build Permission Toggle -->
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="font-size:14px;">Bouwen</span>
                <img id="adminBuildToggle" src="icons/buildmenu_inactive.png" style="width:24px; height:24px; cursor:pointer;" title="Spelers mogen bouwen">
            </div>

            <!-- No Smoking Toggle -->
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="font-size:14px;">Roken</span>
                <img id="adminNoSmokingToggle" src="icons/verboden.png" style="width:24px; height:24px; cursor:pointer;" title="Roken verboden">
            </div>

            <!-- Tile Numbers Toggle -->
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="font-size:14px;">Nummers</span>
                <img id="adminTileNumbersToggle" src="icons/numbers.png" style="width:24px; height:24px; cursor:pointer;" title="Toon Tegel Nummers">
            </div>

            <script>
                // Inline script voor admin toggle logica
                const adminAlwaysOnlineToggle = document.getElementById('adminAlwaysOnlineToggle');
                adminAlwaysOnlineToggle.dataset.active = "false";
                adminAlwaysOnlineToggle.onclick = () => {
                    const current = adminAlwaysOnlineToggle.dataset.active === "true";
                    adminAlwaysOnlineToggle.dataset.active = !current;
                    adminAlwaysOnlineToggle.src = !current ? "icons/wit.png" : "icons/rood.png";
                };

                const adminBuildToggle = document.getElementById('adminBuildToggle');
                adminBuildToggle.dataset.allowed = "false";
                adminBuildToggle.onclick = () => {
                    const current = adminBuildToggle.dataset.allowed === "true";
                    adminBuildToggle.dataset.allowed = !current;
                    adminBuildToggle.src = !current ? "icons/buildmenu_active.png" : "icons/buildmenu_inactive.png";
                };

                const adminNoSmokingToggle = document.getElementById('adminNoSmokingToggle');
                adminNoSmokingToggle.dataset.forbidden = "false";
                adminNoSmokingToggle.onclick = () => {
                    const current = adminNoSmokingToggle.dataset.forbidden === "true";
                    adminNoSmokingToggle.dataset.forbidden = !current;
                    adminNoSmokingToggle.src = !current ? "icons/verboden_active.png" : "icons/verboden.png";
                };
            </script>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 10px; width: 100%;">
            <button id="createRoomBtn" style="flex: 1; padding: 10px 15px; border: white 1px solid; color: white; border-radius: 0px; cursor: pointer;">Aanmaken</button>
            <button id="saveRoomBtn" style="flex: 1; padding: 10px 15px; border: #7bff00 1px solid; color: #7bff00; border-radius: 0px; cursor: pointer;">Opslaan</button>
            <button id="clearRoomBtn" style="flex: 1; padding: 10px 15px; border: #f44336 1px solid; color: #f44336; border-radius: 0px; cursor: pointer;">Legen</button>
        </div>

        <hr style="width: 100%; border: 0; border-top: 1px solid #555; margin: 10px 0;">
        <h4 style="margin: 0 0 5px 0; font-weight: normal;">Kamers</h4>
        <div id="roomList" style="flex-grow: 1; overflow-y: auto; background: rgba(0,0,0,0.2); border: 1px solid #444; padding: 5px; min-height: 100px;"></div>

    </div>
  </div>
</div>

<div id="chatLog">
  <div id="chatLogHeader">
    <span>Chat geschiedenis</span>
    <span class="close-btn" id="closeChatLogBtn">Ã—</span>
  </div>
  <div id="chatLogContent"></div>
</div>

<div id="uploadModal">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h4 style="margin:0;">Object Uploaden</h4>
        <span id="closeUploadModalCross" style="cursor:pointer; font-size:24px; line-height:1;">Ã—</span>
    </div>
    
    <input type="text" id="customObjectName" placeholder="Naam van object (optioneel)" maxlength="20">
    <input type="number" id="customObjectPrice" placeholder="Prijs (optioneel)" style="width: 100%; padding: 8px; background: #333; border: 1px solid #555; color: white; font-family: Arial, sans-serif; font-size: 14px; border-radius: 4px; box-sizing: border-box; margin-top: 10px;">
    
    <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
        <input type="checkbox" id="customObjectAdminOnly">
        <label for="customObjectAdminOnly" style="font-size: 14px;">Alleen voor Admins</label>
    </div>

    <div style="margin-top: 10px;">
        <label style="font-size:14px; color:#ccc; display:block; margin-bottom:5px;">Functie Template:</label>
        <select id="templateSelect" style="width: 100%; padding: 8px; background: #333; border: 1px solid #555; color: white; border-radius: 4px; font-family: Arial;"></select>
    </div>
    
    <!-- NIEUW: Configuratie stap na bestandselectie -->
    <div id="uploadConfigStep" style="display:none; flex-direction:column; gap:10px; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
        <div style="display:flex; flex-direction:column; align-items:center; gap:10px;">
            <!-- Canvas voor visuele collision editor -->
            <div style="position:relative; border:1px solid #555; background:rgba(0,0,0,0.3); border-radius:4px;">
                <canvas id="collisionCanvas" width="128" height="128" style="display:block; cursor:nwse-resize; image-rendering:pixelated;"></canvas>
            </div>
            
            <!-- Inputs netjes op een rij eronder -->
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; width:100%;">
                <div>
                    <label style="font-size:10px; color:#aaa; display:block; text-align:center;">Breedte (X)</label>
                    <input type="number" id="confWidth" class="popup-input" style="width:100%; margin:0; text-align:center;" min="1" value="1">
                </div>
                <div>
                    <label style="font-size:10px; color:#aaa; display:block; text-align:center;">Diepte (Y)</label>
                    <input type="number" id="confDepth" class="popup-input" style="width:100%; margin:0; text-align:center;" min="1" value="1">
                </div>
                <div>
                    <label style="font-size:10px; color:#aaa; display:block; text-align:center;">Hoogte (Z)</label>
                    <input type="number" id="confHeight" class="popup-input" style="width:100%; margin:0; text-align:center;" min="1" value="1">
                </div>
            </div>
        </div>
        <div style="display:flex; gap:15px; margin-top:5px; justify-content:center;">
            <label style="display:flex; align-items:center; gap:5px; font-size:12px; cursor:pointer;">
                <input type="checkbox" id="confWalkable"> Beloopbaar (Vloer)
            </label>
            <label style="display:flex; align-items:center; gap:5px; font-size:12px; cursor:pointer;">
                <input type="checkbox" id="confMoveable"> Verplaatsbaar (Rigidbody)
            </label>
        </div>
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="doUploadBtn" class="popup-btn confirm" style="flex:1; padding:10px;">Bevestigen & Uploaden</button>
            <button id="cancelConfigBtn" class="popup-btn deny" style="flex:1; padding:10px;">Terug</button>
        </div>
    </div>

        <input type="file" id="customFileUpload" style="display:none;" accept="image/*">
</div>

<div id="inventory" style="display: none;">
  <div id="inventoryHeader">
    <span>Inventaris</span>
    <span class="close-btn" id="closeInventoryBtn">Ã—</span>
  </div>
  <div id="inventoryTools">
    <div style="display: flex; align-items: center; gap: 8px;">
      <div id="wallet">â‚¬0.00</div>
      <div id="transactionFeed"></div>
    </div>
    <button id="vicinityBtn" class="tool-btn" title="Omgeving"><img src="icons/vicinity.png"></button>
  </div>
  <div id="inventoryContent">
    <!-- Inventaris items komen hier -->
  </div>
</div>

<div id="vicinityWindow">
  <div id="vicinityHeader">
    <span>Omgeving</span>
  </div>
  <div id="vicinityContent" style="padding: 10px; overflow-y: auto; height: calc(100% - 36px); display: grid; grid-template-columns: repeat(auto-fill, minmax(64px, 1fr)); gap: 10px; padding-bottom: 20px; align-content: start;"></div>
</div>

<div id="movePreview" style="display: none; position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10000; background: rgba(0, 0, 0, 0.85); border: 1px solid rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 8px; color: white; font-family: Arial, sans-serif; font-size: 12px; align-items: center; gap: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); backdrop-filter: blur(4px);">
    <div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 4px;">
        <img id="movePreviewImg" src="" style="max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: pixelated;">
    </div>
    <div style="display: flex; flex-direction: column; gap: 2px;">
        <span id="movePreviewName" style="font-size: 10px; text-shadow: 1px 1px 0 #000;"></span>
        <span id="movePreviewActionText" style="color: #ccc; font-size: 10px; font-style: italic;">Verplaatsen</span>
        <span id="movePreviewPrice" style="display:none; color: #4cd137; font-size: 10px;"></span>
        <span id="movePreviewCount" style="display:none; color: #aaa; font-size: 10px; margin-top: 2px;"></span>
    </div>
</div>

<div id="pongBackdrop"></div>

<div id="notification"></div>
<div id="voteCounter"></div>

<div id="shopWindow">
  <div id="shopHeader">
    <span>Winkel</span>
    <span class="close-btn" id="closeShopBtn">Ã—</span>
  </div>
  <div id="shopTools" style="padding: 10px; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; gap: 8px;">
      <input type="text" id="shopSearchInput" placeholder="Zoeken..." style="padding: 6px; border-radius: 4px; border: 1px solid #555; background: #222; color: white; font-family: Arial, sans-serif; font-size: 12px;">
      <select id="shopSortSelect" style="padding: 6px; border-radius: 4px; border: 1px solid #555; background: #222; color: white; font-family: Arial, sans-serif; font-size: 12px;">
          <option value="name_asc">Naam (A-Z)</option>
          <option value="name_desc">Naam (Z-A)</option>
          <option value="price_asc">Prijs (Laag - Hoog)</option>
          <option value="price_desc">Prijs (Hoog - Laag)</option>
      </select>
  </div>
  <div id="shopContent"></div>
  <div id="shopOutput"></div>
</div>

<div id="roomsWindow">
  <div id="roomsHeader" class="window-header" style="height: 36px; line-height: 36px; padding: 0 12px; background: #1a1a1a; border-bottom: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px 10px 0 0; cursor: move; user-select: none; display: flex; justify-content: space-between; align-items: center;">
    <span>Kamers</span>
    <span class="close-btn" id="closeRoomsBtn">Ã—</span>
  </div>
  <div style="padding: 5px 10px; border-bottom: 1px solid #444; background: rgba(0,0,0,0.2);">
      <select id="roomSortSelect" style="width: 100%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 50px; font-size: 10px;">
          <option value="friends">Sorteren op: Vrienden</option>
          <option value="busy">Sorteren op: Druk</option>
          <option value="quiet">Sorteren op: Rustig</option>
      </select>
  </div>
  <div id="roomsContent"></div>
</div>

<div id="myRoomWindow">
  <div id="myRoomHeader" class="window-header" style="height: 36px; line-height: 36px; padding: 0 12px; background: #1a1a1a; border-bottom: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px 10px 0 0; cursor: move; user-select: none; display: flex; justify-content: space-between; align-items: center;">
    <span>Mijn Studio</span>
    <span class="close-btn" id="closeMyRoomBtn">Ã—</span>
  </div>
  <div id="myRoomContent"></div>
</div>

<div id="roomPlayersWindow">
  <div id="roomPlayersHeader" class="window-header" style="height: 36px; line-height: 36px; padding: 0 12px; background: #1a1a1a; border-bottom: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px 10px 0 0; cursor: move; user-select: none; display: flex; justify-content: space-between; align-items: center; font-size: 14px;">
    <span>Spelers in Kamer</span>
    <span class="close-btn" id="closeRoomPlayersBtn">Ã—</span>
  </div>
  <div id="roomPlayersContent" style="overflow-y: auto; height: calc(100% - 36px);"></div>
</div>

<div id="friendsWindow">
  <div id="friendsHeader" class="window-header" style="height: 36px; line-height: 36px; padding: 0 12px; background: #1a1a1a; border-bottom: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px 10px 0 0; cursor: move; user-select: none; display: flex; justify-content: space-between; align-items: center;">
    <span>Vrienden</span>
    <span class="close-btn" id="closeFriendsBtn">Ã—</span>
  </div>
  <div id="friendsContent" style="overflow-y: auto; height: calc(100% - 36px);"></div>
</div>

<div id="containerWindow">
  <div id="containerHeader">
    <span>Container</span>
    <span class="close-btn" id="closeContainerBtn">Ã—</span>
  </div>
  <div id="containerTools" style="display: none;"></div>
  <div id="containerContent" style="position: relative; height: calc(100% - 36px); overflow: hidden;"></div>
</div>

<!-- NIEUW: Pouch Venster (voor items in inventory) -->
<div id="pouchWindow">
  <div id="pouchHeader" class="window-header">
    <span>Pouch</span>
    <span class="close-btn" id="closePouchBtn">Ã—</span>
  </div>
  <div id="pouchContent" style="position: relative; height: calc(100% - 36px); overflow: hidden;"></div>
</div>

<!-- NIEUW: Context Menu voor Inventory Items -->
<div id="itemContextMenu" style="display: none; position: absolute; z-index: 2000; background: rgba(17, 17, 17, 0.95); border: 1px solid white; border-radius: 4px; min-width: 100px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
    <div id="ctxOpenBtn" class="ctx-item" style="padding: 8px 12px; cursor: pointer; color: white; font-family: Arial; font-size: 12px; border-bottom: 1px solid #444;">Openen</div>
    <div id="ctxCancelBtn" class="ctx-item" style="padding: 8px 12px; cursor: pointer; color: #aaa; font-family: Arial; font-size: 12px;">Annuleren</div>
</div>

<div id="pongGame">
  <div id="pongHeader"> <!-- Uniek ID voor slepen -->
    <span>Tafeltennis</span>
    <span class="close-btn" id="closePongBtn">Ã—</span>
  </div>
  <div id="pongScoreboard">
    <div class="score-player"><span id="playerNameLabel">Speler</span>: <span id="playerScore">0</span></div>
    <div class="score-ai"><span id="opponentNameLabel">Tegenstander</span>: <span id="aiScore">0</span></div>
  </div>
  <canvas id="pongCanvas" width="600" height="264"></canvas>
</div>

<canvas id="canvas"></canvas>

<script>
(function() { // Start van de IIFE
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŒ MULTIPLAYER SETUP (SOCKET.IO)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let socket;
let otherPlayers = {}; // Hier slaan we de andere spelers op
let mySocketId = null;
let myName = "Jij"; // NIEUW: Variabele voor eigen naam
let isUserAdmin = false; // NIEUW: Houdt bij of de gebruiker admin is
const nameHoverStates = {}; // NIEUW: Houdt hover status bij voor fade-out
let isRoomOwner = false; // Ben ik de eigenaar van de huidige kamer?
let myRoomId = null; // ID van MIJN kamer (ongeacht waar ik ben)
let myRoomSettings = { doorbell: false, alwaysOnline: false, allowBuilding: false, noSmoking: false }; // Instellingen van MIJN kamer
let currentRoomSettings = { doorbell: false, alwaysOnline: false, allowBuilding: false, noSmoking: false }; // Instellingen van huidige kamer

// NIEUW: Vriendenlijst
let myFriends = [];
let isWaitingForDoorbell = false; // Voorkom spammen van de bel

// NIEUW: Check for post-redirect messages
(function checkSessionMessages() {
    const wasKicked = sessionStorage.getItem('wasKicked');
    if (wasKicked) {
        showAlert({ message: "Je bent uit de kamer gezet!", icon: 'icons/rooms.png' });
        sessionStorage.removeItem('wasKicked');
    }
    const wasClosed = sessionStorage.getItem('roomClosed');
    if (wasClosed) {
        showAlert({ message: "De eigenaar is vertrokken.", subMessage: "Je bent terug in het Atrium.", icon: 'icons/rooms.png' });
        sessionStorage.removeItem('roomClosed');
    }
})();

// Genereer of laad een uniek User ID voor eigenaarschap
let myUserId = sessionStorage.getItem('habboUserId'); // Changed to sessionStorage for testing
if (!myUserId) {
    myUserId = 'user_' + Math.random().toString(36).substr(2, 9);
    sessionStorage.setItem('habboUserId', myUserId);
}

try {
    socket = io();
    
    socket.on('connect', () => {
        mySocketId = socket.id;
        
        // Haal laatst bekende positie op uit localStorage
        let savedPos = null;
        // Check URL voor room ID
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room') || 'testroom';
        const sizeParam = urlParams.get('size');
        const aoVal = urlParams.get('alwaysOnline');
        const alwaysOnlineParam = aoVal === null ? null : (aoVal === 'true');
        const abVal = urlParams.get('allowBuilding');
        const allowBuildingParam = abVal === null ? null : (abVal === 'true');
        const nsVal = urlParams.get('noSmoking');
        const noSmokingParam = nsVal === null ? null : (nsVal === 'true');

        try {
            const stored = localStorage.getItem(`habboCloneLastPos_${roomId}`);
            if (stored) savedPos = JSON.parse(stored);
        } catch(e) {}

        // Vraag om mee te doen op deze positie
        const sizeToSend = sizeParam && sizeParam.includes('x') ? sizeParam : (sizeParam ? parseInt(sizeParam) : null);
        socket.emit('joinRoom', { roomId: roomId, ...savedPos, size: sizeToSend, userId: myUserId, alwaysOnline: alwaysOnlineParam, allowBuilding: allowBuildingParam, noSmoking: noSmokingParam });

        // NIEUW: Vraag data van MIJN kamer op
        socket.emit('getMyRoomData', myUserId);

        // NIEUW: Vraag de lijst met custom objects op van de server
        socket.emit('getCustomObjects');

        // NIEUW: Vraag de vriendenlijst op
        socket.emit('getFriends');

        // Update de chatlog nu we een ID hebben, zodat eigen berichten links staan
        updateChatLog();
    });

    socket.on('joinError', (msg) => {
        alert(msg);
        window.location.search = '?room=atrium'; // Terug naar atrium
    });

    // Ontvang data van mijn kamer
    socket.on('myRoomData', (data) => {
        if (data.roomId) {
            myRoomId = data.roomId;
            myRoomSettings = data.settings || { doorbell: false, alwaysOnline: false, allowBuilding: false, noSmoking: false };
            if (document.getElementById('myRoomWindow').style.display === 'flex') {
                renderMyRoomSettings();
            }
        }
    });
    socket.on('myRoomSettingsUpdated', (data) => {
        if (data.roomId === myRoomId) myRoomSettings = data.settings;
    });

    // Helper om custom objecten te voorzien van hun plaatje
    function hydrateObject(obj) {
        if (obj.isCustom && obj.image) {
            const existing = typeof buildableObjects !== 'undefined' ? buildableObjects.find(b => b.image === obj.image) : null;
            if (existing && existing.runtimeImage) {
                obj.runtimeImage = existing.runtimeImage;
            } else {
                const img = new Image();
                img.src = obj.image;
                obj.runtimeImage = img;
            }
        }
    }

    // Server bevestigt deelname en geeft huidige status
    socket.on('initGame', (data) => {
        console.log("Joined game at", data.startX, data.startY);
        ball.x = data.startX;
        ball.y = data.startY;
        
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room') || 'testroom';
        
        // Update map grootte als de server die meestuurt
        if (data.mapW && !isNaN(data.mapW)) mapW = data.mapW;
        if (data.mapH && !isNaN(data.mapH)) mapH = data.mapH;

        // Check eigenaarschap
        isRoomOwner = data.isOwner || false;
        currentRoomSettings = data.roomSettings || { doorbell: false, alwaysOnline: false, allowBuilding: false, noSmoking: false };
        updateBuildButton(); // Update footer button state
        
        // Overschrijf onze lokale lijsten met die van de server
        if (data.objects) {
            objects.length = 0;
            // Als de testroom leeg is op de server, vul hem met de standaard objecten.
            if (roomId === 'testroom' && data.objects.length === 0) {
                defaultTestRoomObjects.forEach(o => objects.push(o));
            } else {
                data.objects.forEach(o => {
                    hydrateObject(o);
                    objects.push(o);
                });
            }
        }
        if (data.wallObjects) {
            wallObjects.length = 0;
            data.wallObjects.forEach(o => {
                hydrateObject(o);
                wallObjects.push(o);
            });
        }
        // Laad items van server
        if (data.items) {
            items.length = 0;
            data.items.forEach(i => items.push(createItemFromData(i)));
        }
        if (data.tileColors) {
            for (const key in tileColors) delete tileColors[key];
            Object.assign(tileColors, data.tileColors);
        }
        if (data.wallColors) {
            for (const key in wallColors) delete wallColors[key];
            Object.assign(wallColors, data.wallColors);
        }
    });

    // Luister naar updates van de kamer
    socket.on('updateObjects', (serverObjects) => {
        objects.length = 0;
        serverObjects.forEach(o => {
            hydrateObject(o);
            objects.push(o);
        });
    });
    socket.on('updateWallObjects', (serverWallObjects) => {
        wallObjects.length = 0;
        serverWallObjects.forEach(o => {
            hydrateObject(o);
            wallObjects.push(o);
        });
    });
    
    socket.on('updateTileColor', (data) => {
        tileColors[data.key] = data.color;
    });
    socket.on('updateWallColor', (data) => {
        wallColors[data.id] = data.color;
    });
    
    // Luister naar item updates (verplaatsingen door anderen)
    socket.on('updateItems', (serverItems) => {
        // Maak een map van huidige items om lokale state te behouden
        const currentMap = new Map(items.map(i => [i.id, i]));
        
        items.length = 0;
        serverItems.forEach(serverItem => {
            const localItem = currentMap.get(serverItem.id);
            
            // Als we dit item al hebben EN wij zijn de eigenaar, behoud lokale physics state
            if (localItem && localItem.lastTouchedBy === mySocketId && serverItem.lastTouchedBy === mySocketId) {
                items.push(localItem);
            } else {
                items.push(createItemFromData(serverItem));
            }
        });
    });

    // NIEUW: Ontvang live physics updates van andere spelers
    socket.on('updateItemPhysics', (updates) => {
        updates.forEach(u => {
            const item = items.find(i => i.id === u.id);
            if (item && item !== draggedItem) { // Update niet als wij het zelf slepen
                item.x = u.x;
                item.y = u.y;
                item.z = u.z;
                item.vx = u.vx;
                item.vy = u.vy;
                item.vz = u.vz;
                item.rotation = u.rotation;
                item.vr = u.vr;
                item.lastTouchedBy = u.lastTouchedBy; // Neem eigenaar over van server
            }
        });
    });

    // Synchroniseer de spelerslijst (vervangt newPlayer/playerDisconnected)
    socket.on('updatePlayerList', (allPlayers) => {
        console.log("Spelerslijst ontvangen:", allPlayers); // Debug log
        
        // NIEUW: Update eigen naam als we die in de lijst vinden
        if (mySocketId && allPlayers[mySocketId]) {
            myName = allPlayers[mySocketId].name;
        }

        const newIds = Object.keys(allPlayers);
        
        // 1. Voeg nieuwe spelers toe
        newIds.forEach(id => {
            if (id !== socket.id && id !== mySocketId && !otherPlayers[id]) {
                otherPlayers[id] = allPlayers[id];
                if (otherPlayers[id].isSmoking) {
                    otherPlayers[id].smokingStartTime = Date.now(); // Fallback starttijd voor nieuwe spelers
                }
                if (otherPlayers[id].isDrinking) {
                    otherPlayers[id].drinkingStartTime = Date.now();
                }
            }
        });

        // 2. Verwijder spelers die weg zijn
        Object.keys(otherPlayers).forEach(id => {
            if (!allPlayers[id]) {
                delete otherPlayers[id];
                if (nameHoverStates[id]) delete nameHoverStates[id];
            }
        });
    });

    // NIEUW: Ontvang de lijst met bestaande custom objects
    socket.on('customObjectList', (objectsFromServer) => {
        console.log(`Ontvangen: ${objectsFromServer.length} custom objects van server.`);
        objectsFromServer.forEach(obj => {
            // Voorkom duplicaten
            if (!buildableObjects.some(b => b.name === obj.name && b.image === obj.image)) {
                const img = new Image();
                img.src = obj.image;
                obj.runtimeImage = img;
                buildableObjects.push(obj);
            }
        });
    });

    // NIEUW: Ontvang een nieuw toegevoegd custom object
    socket.on('customObjectAdded', (newObj) => {
        console.log("Nieuw custom object ontvangen:", newObj);
        const img = new Image();
        img.src = newObj.image;
        newObj.runtimeImage = img;
        buildableObjects.push(newObj);

        // Als het bouwmenu open is, ververs de lijst
        if (isBuildMode && activeBuildCategory === 'objecten') {
            renderBuildItems();
        }
        showNotification(`Nieuw object toegevoegd: ${newObj.name}`);
    });

    // NIEUW: Custom object verwijderd door admin
    socket.on('customObjectDeleted', (data) => {
        const { name, price } = data;
        
        // NIEUW: Deselecteer het object als het momenteel geselecteerd is
        if (selectedBuildObject && selectedBuildObject.name === name && selectedBuildObject.isCustom) {
            selectedBuildObject = null;
            // De renderBuildItems() hieronder zal de visuele deselectie afhandelen
        }

        // Verwijder uit bouwmenu lijst
        const idx = buildableObjects.findIndex(b => b.name === name && b.isCustom);
        if (idx > -1) {
            buildableObjects.splice(idx, 1);
            if (isBuildMode) renderBuildItems();
        }

        // Check inventaris en geef geld terug
        let refundCount = 0;
        for (let i = inventoryItems.length - 1; i >= 0; i--) {
            if (inventoryItems[i].name === name) {
                inventoryItems.splice(i, 1);
                refundCount++;
            }
        }

        if (refundCount > 0 && price > 0) {
            const totalRefund = refundCount * price;
            addToWallet(totalRefund);
            showNotification(`â‚¬${totalRefund.toFixed(2)} terugbetaald aan portemonnee voor ${refundCount} verwijderde "${name}" item(s).`);
        }
        savePlayerData();
    });

    // NIEUW: Refund ontvangen (voor geplaatste items)
    socket.on('refund', (data) => {
        addToWallet(data.amount);
        showNotification(`<span style="color: #4cd137;">+â‚¬${data.amount.toFixed(2).replace('.', ',')}</span> (${data.reason})`);
    });

    // NIEUW: Resultaat van aanbellen (voor bezoeker)
    socket.on('doorbellResult', (data) => {
        isWaitingForDoorbell = false;
        if (data.accepted) {
            window.location.search = `?room=${data.roomId}`;
        } else {
            showNotification("Toegang geweigerd door eigenaar.");
        }
    });

    // NIEUW: Vriendenlijst ontvangen
    socket.on('friendsList', (friends) => {
        const content = document.getElementById('friendsContent');
        myFriends = friends; // Update lokale lijst
        content.innerHTML = '';
        
        if (friends.length === 0) {
            content.innerHTML = '<div style="text-align:center; color:#aaa; margin-top:20px;">Je hebt nog geen vrienden.</div>';
            return;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const currentRoomId = urlParams.get('room') || 'testroom';

        friends.forEach(f => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.padding = '8px 0';
            row.style.borderBottom = '1px solid #333';

            const name = document.createElement('span');
            name.textContent = f.name;
            
            // Klik op naam om te joinen als online
            if (f.isOnline && f.roomId && f.roomId !== currentRoomId) {
                name.style.cursor = 'pointer';
                name.title = 'Ga naar vriend';
                name.onclick = () => {
                    window.location.search = `?room=${f.roomId}`;
                };
            }

            const statusDiv = document.createElement('div');
            statusDiv.style.display = 'flex';
            statusDiv.style.alignItems = 'center';
            statusDiv.style.gap = '8px';

            // Online status icon
            const statusIcon = document.createElement('img');
            statusIcon.src = f.isOnline ? 'icons/groen.png' : 'icons/rood.png';
            statusIcon.style.width = '12px';
            statusIcon.style.height = '12px';
            statusIcon.title = f.isOnline ? 'Online' : 'Offline';
            
            const delBtn = document.createElement('img');
            delBtn.src = 'icons/trash.png';
            delBtn.style.width = '16px';
            delBtn.style.height = '16px';
            delBtn.style.cursor = 'pointer';
            delBtn.title = 'Vriend verwijderen';
            delBtn.onclick = () => {
                showConfirmation({
                    message: `Wil je ${f.name} verwijderen als vriend?`,
                    icon: 'icons/trash.png',
                    onConfirm: () => socket.emit('removeFriend', f.userId)
                });
            };

            statusDiv.appendChild(statusIcon);
            statusDiv.appendChild(delBtn);

            row.appendChild(name);
            row.appendChild(statusDiv);
            content.appendChild(row);
        });
    });

    // NIEUW: Room settings updated
    socket.on('roomSettingsUpdated', (settings) => {
        currentRoomSettings = settings;
        updateBuildButton();
    });

    // NIEUW: Kicked
    socket.on('kicked', (roomId) => {
        sessionStorage.setItem('wasKicked', 'true');
        window.location.search = '?room=atrium';
    });

    // NIEUW: Room Closed (Owner left)
    socket.on('roomClosed', () => {
        sessionStorage.setItem('roomClosed', 'true');
        window.location.search = '?room=atrium';
    });

    // NIEUW: Friend Request Received
    socket.on('friendRequestReceived', (data) => {
        showConfirmation({
            message: `${data.senderName} wil vrienden met je worden`,
            icon: 'icons/heart.png',
            confirmText: 'Accepteren',
            denyText: 'Weigeren',
            onConfirm: () => {
                socket.emit('respondFriendRequest', { senderId: data.senderId, accepted: true });
                socket.emit('getFriends'); // Update onze lijst
            },
            onDeny: () => {
                socket.emit('respondFriendRequest', { senderId: data.senderId, accepted: false });
            }
        });
    });

    // NIEUW: Friend Request Result
    socket.on('friendRequestResult', (data) => {
        if (data.accepted) {
            showAlert({
                message: `${data.responderName} heeft je verzoek geaccepteerd!`,
                icon: 'icons/heart_active.png'
            });
            socket.emit('getFriends'); // Update onze lijst
        } else {
            showAlert({
                message: `${data.responderName} heeft je verzoek geweigerd.`,
                icon: 'icons/heart.png'
            });
        }
    });

    // NIEUW: Vote Kick Started
    socket.on('voteKickStarted', (data) => {
        // Als jij het target bent, krijg je geen vote optie (of een melding)
        if (data.targetId === socket.id) {
            showNotification(`Er is een stemming gestart om jou te kicken door ${data.initiatorName}.`);
            return;
        }

        // Als jij de initiator bent, krijg je geen popup (je hebt al automatisch voorgestemd)
        if (data.initiatorId === socket.id) {
            showNotification(`Stemming gestart om ${data.targetName} te kicken.`);
            return;
        }

        showConfirmation({
            message: `Stemming: ${data.targetName} kicken?`,
            subMessage: `Gestart door ${data.initiatorName}`,
            icon: 'icons/kick.png',
            confirmText: 'Ja',
            denyText: 'Nee',
            onConfirm: () => socket.emit('castKickVote', { vote: true }),
            onDeny: () => socket.emit('castKickVote', { vote: false })
        });
    });

    // NIEUW: Vote Update (teller)
    socket.on('voteUpdate', (data) => {
        const el = document.getElementById('voteCounter');
        el.style.display = 'block';
        el.innerHTML = `Stemming ${data.targetName}:<br><strong>${data.count} / ${data.needed}</strong> stemmen`;
    });

    // NIEUW: Vote Kick Result
    socket.on('voteKickResult', (data) => {
        document.getElementById('voteCounter').style.display = 'none';
        if (data.success) {
            showNotification(`${data.targetName} is uit de kamer gestemd.`);
        } else {
            showNotification(`Stemming mislukt. ${data.targetName} mag blijven.`);
        }
    });

    // NIEUW: Iemand belt aan (alleen voor eigenaar relevant)
    socket.on('doorbellRung', (data) => {
        if (!isRoomOwner) return; // Alleen eigenaar reageert
        showConfirmation({
            message: 'Iemand belt aan!',
            subMessage: 'Wil je deze speler binnenlaten?',
            icon: 'icons/bel.png',
            confirmText: 'Binnenlaten',
            denyText: 'Weigeren',
            onConfirm: () => socket.emit('answerDoorbell', { visitorId: data.visitorId, accepted: true }),
            onDeny: () => socket.emit('answerDoorbell', { visitorId: data.visitorId, accepted: false })
        });
    });





    socket.on('playerMoved', (playerInfo) => {
        if (otherPlayers[playerInfo.id]) {
            const p = otherPlayers[playerInfo.id];
            p.startX = p.x;
            p.startY = p.y;
            p.targetX = playerInfo.x;
            p.targetY = playerInfo.y;
            p.progress = 0;
            p.moving = true;
            if (playerInfo.isSmoking && !p.isSmoking) {
                p.smokingStartTime = Date.now(); // NIEUW: Starttijd zetten als iemand begint te roken
            }
            p.isSmoking = playerInfo.isSmoking; // NIEUW: Update rookstatus van anderen
            p.smokingItemType = playerInfo.smokingItemType; // NIEUW: Update type sigaret
            
            if (playerInfo.isDrinking && !p.isDrinking) {
                p.drinkingStartTime = Date.now();
            }
            p.isDrinking = playerInfo.isDrinking;
            p.drinkingItemType = playerInfo.drinkingItemType;
        }
    });

    // Ontvang chatgeschiedenis bij binnenkomst
    socket.on('chatHistory', (history) => {
        history.forEach(msg => {
            receiveChatMessage(msg);
        });
    });

    // ðŸ“ PONG EVENTS
    socket.on('startPongAI', () => {
        startPongGame(true, "AI"); // true = AI mode
    });

    socket.on('pongWaiting', (data) => {
        showNotification(`Wachten op ${data.opponentName}...`);
    });

    socket.on('pongChallenge', (data) => {
        // Toon een speciale notificatie met knop
        const notif = document.getElementById('notification');
        // Zorg dat we kunnen klikken op de knoppen (standaard is notification pointer-events: none)
        notif.style.pointerEvents = 'auto'; 
        
        notif.innerHTML = `
            <div id="pongNotification" class="popup-content">
                <div class="popup-sub">${data.challengerName} wil tafeltennissen!</div>
                <div class="popup-actions">
                    <button id="acceptPongBtn" class="popup-btn confirm">Accepteren</button>
                    <button id="declinePongBtn" class="popup-btn deny">Weigeren</button>
                </div>
            </div>
        `;
        notif.style.display = 'block';
        notif.style.opacity = '1';
        
        document.getElementById('acceptPongBtn').onclick = () => {
            // Check of speler een batje heeft
            const hasPaddle = inventoryItems.some(item => item.name && item.name.toLowerCase().includes("batje"));
            if (hasPaddle) {
                socket.emit('acceptPong', { challengerId: data.challengerId });
                notif.style.pointerEvents = 'none'; // Reset
                notif.style.display = 'none';
            } else {
                showNotification("Je hebt een batje nodig om te accepteren!");
            }
        };
        
        document.getElementById('declinePongBtn').onclick = () => {
            notif.style.pointerEvents = 'none'; // Reset
            notif.style.display = 'none';
            // Optioneel: stuur een 'decline' bericht terug naar de server/uitdager
        };
    });

    socket.on('startPongPvP', (data) => {
        startPongGame(false, data.opponentName, data.opponentId, data.isHost);
    });

    socket.on('pongBallUpdate', (data) => {
        pongBall.x = data.x;
        pongBall.y = data.y;
    });

    socket.on('pongScoreUpdate', (data) => {
        playerPaddle.score = data.playerScore;
        aiPaddle.score = data.aiScore;
        playerScoreEl.textContent = playerPaddle.score;
        aiScoreEl.textContent = aiPaddle.score;
    });

    socket.on('pongPaused', (data) => {
        initiatePongPause(data.name);
    });

    socket.on('pongStopped', (data) => {
        stopPongGame();
        showNotification(`${data.name} heeft het spel gestopt.`);
    });

    // NIEUW: Ontvang lijst met kamers
    socket.on('roomList', (rooms) => {
        const list = document.getElementById('roomList');
        if (!list) return;
        list.innerHTML = '';
        
        if (rooms.length === 0) {
            list.innerHTML = '<div style="padding: 5px; color: #aaa;">Geen kamers gevonden.</div>';
            return;
        }

        // NIEUW: Haal favoriete kamers op uit localStorage
        let starredRooms = [];
        try {
            starredRooms = JSON.parse(localStorage.getItem('habboCloneStarredRooms')) || [];
        } catch(e) {}

        let currentRoom = new URLSearchParams(window.location.search).get('room') || 'testroom';
        const sortType = document.getElementById('roomSortSelect').value;

        // Sorteer logica:
        // 1. Favorieten (Starred) bovenaan
        // 2. Huidige kamer
        // 3. Dan op basis van selectie
        rooms.sort((a, b) => {
            const aStarred = starredRooms.includes(a.id);
            const bStarred = starredRooms.includes(b.id);
            if (aStarred && !bStarred) return -1;
            if (!aStarred && bStarred) return 1;

            if (a.id === currentRoom) return -1;
            if (b.id === currentRoom) return 1;
            
            if (sortType === 'friends') {
                // Eerst op aantal vrienden, dan op aantal spelers
                if (b.friendCount !== a.friendCount) return b.friendCount - a.friendCount;
                return b.playerCount - a.playerCount;
            } else if (sortType === 'quiet') {
                return a.playerCount - b.playerCount;
            }
            
            // Default: busy
            return b.playerCount - a.playerCount;
        });

        // Update ook de spelers kamerlijst (deze code stond dubbel, nu geconsolideerd in de loop)
        const roomsContent = document.getElementById('roomsContent');
        if (roomsContent) roomsContent.innerHTML = '';

        rooms.forEach(roomData => {
            const roomId = roomData.id;

            // Verberg testroom voor spelers
            if (!isUserAdmin && roomId === 'testroom') return;
            
            // Verberg offline kamers voor spelers
            if (!isUserAdmin && !roomData.isOwnerOnline && roomId !== 'testroom') return;

            // Admin lijst item
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.padding = '6px';
            row.style.borderBottom = '1px solid #444';
            
            const name = document.createElement('span');
            name.textContent = roomId;
            name.style.cursor = 'pointer';
            name.style.flexGrow = '1';
            name.onclick = () => {
                if (roomData.playerCount >= roomData.maxPlayers) {
                    showNotification("Kamer is vol!", "icons/player.png");
                    return;
                }
                window.location.search = `?room=${roomId}`;
            };

            if (roomId === currentRoom) {
                name.style.color = '#7bff00';
            }

            // Player count info
            const playerCountDiv = document.createElement('div');
            playerCountDiv.style.display = 'flex';
            playerCountDiv.style.alignItems = 'center';
            // Geen gap, we gebruiken vaste slots voor uitlijning
            playerCountDiv.style.marginRight = '10px';

            // Helper voor vaste slots
            const createSlot = (src, title) => {
                const slot = document.createElement('div');
                slot.style.width = '15px'; // Vaste breedte per icoon
                slot.style.display = 'flex';
                slot.style.justifyContent = 'center';
                if (src) {
                    const img = document.createElement('img');
                    img.src = src;
                    img.style.width = '12px';
                    img.style.height = '12px';
                    if (title) img.title = title;
                    slot.appendChild(img);
                }
                return slot;
            };

            
            let iconSrc = 'icons/player.png';
            let maxP = roomData.maxPlayers;
            
            if (roomId === 'testroom') {
                iconSrc = 'icons/admin.png';
            }
            
            // Slot 4: Player Icon
            playerCountDiv.appendChild(createSlot(iconSrc, 'Spelers'));

            const countSpan = document.createElement('span');
            countSpan.textContent = `${roomData.playerCount}/${maxP}`;
            countSpan.style.width = '35px'; // Vaste breedte voor tekst
            countSpan.style.textAlign = 'right';
            
            if (roomData.playerCount >= maxP) {
                countSpan.style.color = '#f44336';
            } else {
                countSpan.style.color = '#aaa';
            }

            playerCountDiv.appendChild(countSpan);

            const btnGroup = document.createElement('div');
            btnGroup.style.display = 'flex';
            btnGroup.style.alignItems = 'center';
            btnGroup.style.gap = '5px';

            if (roomId !== 'testroom' && isUserAdmin) {
                // Always Online knop
                const aoBtn = document.createElement('button');
                const aoImg = document.createElement('img');
                aoImg.src = roomData.isAlwaysOnline ? 'icons/wit.png' : 'icons/rood.png';
                aoImg.style.width = '16px';
                aoImg.style.height = '16px';
                aoBtn.appendChild(aoImg);
                aoBtn.title = roomData.isAlwaysOnline ? 'Zet Altijd Online UIT' : 'Zet Altijd Online AAN';
                aoBtn.style.padding = '4px';
                aoBtn.style.cursor = 'pointer';
                aoBtn.onclick = () => socket.emit('toggleAlwaysOnline', roomId);

                // Build Permission knop
                const buildBtn = document.createElement('button');
                const buildImg = document.createElement('img');
                buildImg.src = roomData.allowBuilding ? 'icons/buildmenu_active.png' : 'icons/buildmenu_inactive.png';
                buildImg.style.width = '16px';
                buildImg.style.height = '16px';
                buildBtn.appendChild(buildImg);
                buildBtn.title = roomData.allowBuilding ? 'Bouwen toegestaan' : 'Bouwen verboden';
                buildBtn.style.padding = '4px';
                buildBtn.style.cursor = 'pointer';
                buildBtn.onclick = () => {
                    socket.emit('toggleAllowBuilding', roomId);
                };

                // No Smoking knop
                const smokeBtn = document.createElement('button');
                const smokeImg = document.createElement('img');
                smokeImg.src = roomData.noSmoking ? 'icons/verboden_active.png' : 'icons/verboden.png';
                smokeImg.style.width = '16px';
                smokeImg.style.height = '16px';
                smokeBtn.appendChild(smokeImg);
                smokeBtn.title = roomData.noSmoking ? 'Roken verboden' : 'Roken toegestaan';
                smokeBtn.style.padding = '4px';
                smokeBtn.style.cursor = 'pointer';
                smokeBtn.onclick = () => socket.emit('toggleNoSmoking', roomId);

                // Hernoem knop
                const renameBtn = document.createElement('button');
                const renameImg = document.createElement('img');
                renameImg.src = 'icons/rename.png';
                renameImg.style.width = '16px';
                renameImg.style.height = '16px';
                renameBtn.appendChild(renameImg);
                renameBtn.title = 'Hernoem Kamer';
                renameBtn.style.padding = '4px';
                renameBtn.style.cursor = 'pointer';

                renameBtn.onclick = () => {
                    showInputPrompt({
                        message: `Hernoem "${roomId}":`,
                        defaultValue: roomId,
                        onConfirm: (newName) => {
                            if (newName && newName.trim() && newName.trim() !== roomId) {
                                socket.emit('renameRoom', { oldId: roomId, newId: newName.trim() });
                            }
                        }
                    });
                };

                // Verwijder knop
                const delBtn = document.createElement('button');
                const delImg = document.createElement('img');
                delImg.src = 'icons/trash.png';
                delImg.style.width = '16px';
                delImg.style.height = '16px';
                delBtn.appendChild(delImg);
                delBtn.title = 'Verwijder Kamer';
                delBtn.style.padding = '4px';
                delBtn.style.cursor = 'pointer';
                
                delBtn.onmousedown = () => { delImg.src = 'icons/trash_active.png'; };
                delBtn.onmouseup = () => { delImg.src = 'icons/trash.png'; };
                delBtn.onmouseleave = () => { delImg.src = 'icons/trash.png'; };

                delBtn.onclick = () => {
                    showConfirmation({
                        message: `Weet je zeker dat je kamer "${roomId}" wilt verwijderen?`,
                        icon: 'icons/trash.png',
                        onConfirm: () => socket.emit('deleteRoom', roomId)
                    });
                };

                btnGroup.appendChild(aoBtn);
                btnGroup.appendChild(buildBtn);
                btnGroup.appendChild(smokeBtn);
                btnGroup.appendChild(renameBtn);
                btnGroup.appendChild(delBtn);
            }
            
            row.appendChild(name);
            row.appendChild(playerCountDiv);
            row.appendChild(btnGroup);
            list.appendChild(row);
        });

        // Spelers lijst item (hergebruik de gesorteerde 'rooms' array)
        if (roomsContent) {
            if (rooms.length === 0) {
                roomsContent.innerHTML = '<div style="padding: 5px; color: #aaa;">Geen kamers gevonden.</div>';
            } else {
                rooms.forEach(roomData => {
                    const roomId = roomData.id;
                    const playerCount = roomData.playerCount;
                    const maxPlayers = roomData.maxPlayers;
                    const hasDoorbell = roomData.hasDoorbell;
                    const isAlwaysOnline = roomData.isAlwaysOnline;

                    // Verberg testroom voor spelers
                    if (!isUserAdmin && roomId === 'testroom') return;
                    
                    // Verberg offline kamers voor spelers
                    if (!isUserAdmin && !roomData.isOwnerOnline && !isAlwaysOnline && roomId !== 'testroom') return;

                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.padding = '8px';
                    row.style.borderBottom = '1px solid #444';
                    
                    // NIEUW: Ster icoon voor favorieten
                    const starIcon = document.createElement('img');
                    const isStarred = starredRooms.includes(roomId);
                    starIcon.src = isStarred ? 'icons/star_active.png' : 'icons/star.png';
                    starIcon.style.width = '16px';
                    starIcon.style.height = '16px';
                    starIcon.style.cursor = 'pointer';
                    starIcon.style.marginRight = '8px';
                    starIcon.title = isStarred ? 'Verwijder uit favorieten' : 'Markeer als favoriet';
                    starIcon.onclick = (e) => {
                        e.stopPropagation(); // Voorkom dat we de kamer joinen
                        const newStarred = isStarred ? starredRooms.filter(id => id !== roomId) : [...starredRooms, roomId];
                        localStorage.setItem('habboCloneStarredRooms', JSON.stringify(newStarred));
                        socket.emit('getRooms'); // Ververs de lijst direct
                    };

                    const name = document.createElement('span');
                    name.textContent = roomId;
                    name.style.cursor = 'pointer';
                    name.style.flexGrow = '1';
                    name.onclick = () => {
                        if (hasDoorbell) {
                            if (isWaitingForDoorbell) {
                                showNotification("Je hebt al aangebeld, even geduld...");
                                return;
                            }
                            socket.emit('ringDoorbell', roomId);
                            isWaitingForDoorbell = true;
                            showNotification("Aangebeld... wachten op antwoord.");
                        } else {
                            if (playerCount >= maxPlayers) {
                                showNotification("Kamer is vol!", "icons/player.png");
                                return;
                            }
                            window.location.search = `?room=${roomId}`;
                        }
                    };

                    if (roomId === currentRoom) {
                        name.style.color = '#7bff00';                    
                    }

                    const playerCountDiv = document.createElement('div');
                    playerCountDiv.style.display = 'flex';
                    playerCountDiv.style.alignItems = 'center';
                    playerCountDiv.style.color = '#aaa';

                    // Helper voor vaste slots
                    const createSlot = (src, title) => {
                        const slot = document.createElement('div');
                        slot.style.width = '15px'; // Vaste breedte
                        slot.style.display = 'flex';
                        slot.style.justifyContent = 'center';
                        if (src) {
                            const img = document.createElement('img');
                            img.src = src;
                            img.style.width = '12px';
                            img.style.height = '12px';
                            if (title) img.title = title;
                            slot.appendChild(img);
                        }
                        return slot;
                    };

                    // Slot 1: No Smoking
                    playerCountDiv.appendChild(createSlot(roomData.noSmoking ? 'icons/verboden_active.png' : null, 'Roken niet toegestaan'));
                    
                    // Slot 2: Heart
                    playerCountDiv.appendChild(createSlot(roomData.friendCount > 0 ? 'icons/heart.png' : null, 'Vrienden'));

                    // Slot 3: Bell
                    const bellSlot = createSlot(hasDoorbell ? 'icons/bel.png' : null, 'Deurbel');
                    bellSlot.style.marginRight = '8px';
                    playerCountDiv.appendChild(bellSlot);
                    
                    // Klikken op poppetje opent spelerslijst van die kamer
                    const playerSlot = createSlot('icons/player.png', 'Bekijk spelers');
                    const playerIcon = playerSlot.querySelector('img');
                    playerIcon.style.cursor = 'pointer';
                    playerIcon.onmouseover = () => { playerIcon.src = 'icons/player_active.png'; };
                    playerIcon.onmouseout = () => { playerIcon.src = 'icons/player.png'; };
                    playerIcon.onclick = () => {
                        const roomPlayersWindow = document.getElementById('roomPlayersWindow');
                        roomPlayersWindow.style.display = 'flex';
                        bringToFront(roomPlayersWindow);
                        // Vraag spelers op voor deze kamer
                        socket.emit('getRoomPlayers', roomId);
                    };
                    playerCountDiv.appendChild(playerSlot);

                    const countSpan = document.createElement('span');
                    countSpan.textContent = `${playerCount}/${maxPlayers}`;
                    countSpan.style.width = '35px'; // Vaste breedte
                    countSpan.style.textAlign = 'right';
                    playerCountDiv.appendChild(countSpan);

                    row.appendChild(starIcon); // Voeg ster toe
                    row.appendChild(name);
                    row.appendChild(playerCountDiv);
                    roomsContent.appendChild(row);
                });
            }
        }
    });

    // Her-sorteer wanneer de optie verandert
    document.getElementById('roomSortSelect').addEventListener('change', () => {
        socket.emit('getRooms');
    });

    socket.on('roomDeleted', (deletedId) => {
        showNotification(`Kamer "${deletedId}" verwijderd.`);
        // Ververs de lijst
        socket.emit('getRooms');
        // Als we in die kamer zaten, ga naar testroom
        const currentRoom = new URLSearchParams(window.location.search).get('room') || 'testroom';
        if (currentRoom === deletedId) {
            window.location.search = '?room=atrium';
        }
    });

    socket.on('roomAlwaysOnlineToggled', () => {
        if (document.getElementById('roomCategoryView').style.display === 'block') {
            socket.emit('getRooms');
        }
    });

    socket.on('roomAllowBuildingToggled', () => {
        if (document.getElementById('roomCategoryView').style.display === 'block') {
            socket.emit('getRooms');
        }
    });

    socket.on('roomNoSmokingToggled', () => {
        if (document.getElementById('roomCategoryView').style.display === 'block') {
            socket.emit('getRooms');
        }
    });

    socket.on('roomRenamed', (data) => {
        showNotification(`Kamer "${data.oldId}" is nu "${data.newId}".`);
        // Ververs de admin lijst als die open is
        if (document.getElementById('roomCategoryView').style.display === 'block') {
            socket.emit('getRooms');
        }
        // Ververs de speler lijst als die open is
        if (document.getElementById('roomsWindow').style.display === 'flex') {
            socket.emit('getRooms');
        }

        // Als we in de hernoemde kamer zaten, laad de pagina opnieuw met de nieuwe URL
        const currentRoom = new URLSearchParams(window.location.search).get('room') || 'testroom';
        if (currentRoom === data.oldId) {
            window.location.search = `?room=${data.newId}`;
        }
    });

    socket.on('renameError', (message) => alert(`Fout bij hernoemen: ${message}`));

    // NIEUW: Ontvang spelerslijst van een kamer
    socket.on('roomPlayersList', (data) => {
        // Update header titel
        const headerTitle = document.querySelector('#roomPlayersHeader span');
        if (headerTitle) {
            headerTitle.textContent = `Alumni in ${data.roomId}`;
        }

        const content = document.getElementById('roomPlayersContent');
        content.innerHTML = '';
        
        if (data.players.length === 0) {
            content.innerHTML = '<div style="text-align:center; color:#aaa; margin-top:20px;">Geen spelers in deze kamer.</div>';
            return;
        }

        const currentRoomId = new URLSearchParams(window.location.search).get('room') || 'testroom';
        const isCurrentRoom = data.roomId === currentRoomId;

        data.players.forEach(p => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.padding = '8px 0';
            row.style.borderBottom = '1px solid #333';

            const name = document.createElement('span');
            name.textContent = p.name;
            
            // Heart Icon
            const isAlreadyFriend = myFriends.some(friend => friend.userId === p.userId);
            const heartBtn = document.createElement('img');
            heartBtn.src = isAlreadyFriend ? "icons/heart_active.png" : "icons/heart.png"; 
            heartBtn.style.width = "20px";
            heartBtn.style.height = "20px";
            heartBtn.title = isAlreadyFriend ? "Vrienden" : "Vriend toevoegen";
            
            if (!isAlreadyFriend && p.id !== socket.id) { // Niet jezelf en geen vriend
                heartBtn.style.cursor = "pointer";
                heartBtn.onclick = () => {
                    showConfirmation({
                        message: `Wil je een vriendschapsverzoek sturen naar ${p.name}?`,
                        icon: 'icons/heart.png',
                        onConfirm: () => socket.emit('sendFriendRequest', { targetId: p.id })
                    });
                };
            }

            // Kick knop logica:
            // 1. Als kamer privÃ© is (ownerId bestaat): Alleen eigenaar ziet knop.
            // 2. Als kamer publiek is (geen ownerId): Iedereen ziet knop (start vote).
            // 3. Je moet wel in die kamer zijn om te kicken/voten.
            const canKick = isCurrentRoom && ( (data.ownerId && data.ownerId === myUserId) || (!data.ownerId) );

            if (canKick && p.id !== socket.id) {
                const kickBtn = document.createElement('img');
                kickBtn.src = "icons/kick.png";
                kickBtn.style.width = "20px";
                kickBtn.style.height = "20px";
                kickBtn.style.cursor = "pointer";
                kickBtn.title = data.ownerId ? "Kicken" : "Start kick stemming";
                
                kickBtn.onclick = () => {
                    const msg = data.ownerId ? `Wil je ${p.name} kicken?` : `Wil je een stemming starten om ${p.name} te kicken?`;
                    showConfirmation({
                        message: msg,
                        icon: 'icons/kick.png',
                        onConfirm: () => socket.emit('kickPlayer', { targetId: p.id })
                    });
                };
                
                // Voeg kick knop toe aan row (naast heart of ipv heart als we dat willen, hier ernaast)
                // We maken een container voor acties
                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.alignItems = 'center';
                actionsDiv.style.gap = '10px';
                
                actionsDiv.appendChild(kickBtn);
                if (p.id !== socket.id) actionsDiv.appendChild(heartBtn);
                
                row.appendChild(name);
                row.appendChild(actionsDiv);
            } else {
                row.appendChild(name);
                if (p.id !== socket.id) row.appendChild(heartBtn);
            }
            
            content.appendChild(row);
        });
    });

} catch (e) {
    console.log("Geen backend gedetecteerd, singleplayer modus.");
}

// High DPI setup
const dpr = window.devicePixelRatio || 1;
canvas.width = window.innerWidth * dpr;
canvas.height = window.innerHeight * dpr;
canvas.style.width = window.innerWidth + 'px';
canvas.style.height = window.innerHeight + 'px';
ctx.imageSmoothingEnabled = false; // Zorgt voor scherpe pixel-art (geen wazige randjes bij zoomen)

const MAX_CHARS = 80;
const charCounter = document.getElementById("charCounter");

const urlParams = new URLSearchParams(window.location.search);
const sizeParam = urlParams.get('size');

let tileW = 64;
let tileH = 32;
let mapW = 25;
let mapH = 25;

if (sizeParam) {
    if (sizeParam.includes('x')) {
        const parts = sizeParam.split('x');
        const w = parseInt(parts[0]);
        const h = parseInt(parts[1]);
        if (!isNaN(w) && !isNaN(h)) {
            mapW = w;
            mapH = h;
        }
    } else {
        const newSize = parseInt(sizeParam);
        if (!isNaN(newSize) && [5, 10, 15, 20, 30].includes(newSize)) {
            mapW = newSize;
            mapH = newSize;
        }
    }
}

// Snelheid speler FPS Hz
let lastLogicTime = Date.now(); // NIEUW: Voor de logic loop

// Speler
const ball = { x:0.5, y:0.5 };
let hopOffset = 0;

// Jump variables
let jumpProgress = 0;
let jumping = false;
let jumpStart = {x:0, y:0};
let jumpEnd = {x:0, y:0};
const jumpHeight = 12;

// Hover
let hoverCell = null;

// Click-to-walk
let path = [];
let highlightedPath = []; // Voor het tekenen van het volledige pad

// Zoom
const zoomLevels = [0.8, 0.9, 1.0, 1.2, 1.4]; // Fijnere zoom-stappen
let currentZoomIndex = 2; // Start op neutraal niveau (1.0)
let scale = zoomLevels[currentZoomIndex];

// Camera
let camX = 0; 
let camY = 0;
let mouseWorldX = 0; // NIEUW: Globale muis wereldcoÃ¶rdinaten
let mouseWorldY = 0; // NIEUW: Globale muis wereldcoÃ¶rdinaten

// Drag-camera
let isCameraDragging = false; // Nieuwe variabele voor camera slepen
let isObjectDragging = false; // Nieuwe variabele voor object slepen
let isItemDragging = false;   // NIEUW: Variabele voor het slepen van items
let isDraggingFromInventory = false; // NIEUW: Houdt bij of we vanuit de inventaris slepen
let isDraggingFromShop = false; // NIEUW: Houdt bij of we vanuit de winkel slepen
let isDraggingFromVicinity = false; // NIEUW: Houdt bij of we vanuit de omgeving slepen
let isDraggingFromContainer = false; // NIEUW: Houdt bij of we vanuit een container slepen
let isRearrangingInventory = false; // NIEUW: Voor het verplaatsen binnen de inventaris
let isRearrangingContainer = false; // NIEUW: Voor het verplaatsen binnen de container
let activeInventoryItem = null; // NIEUW: Het item dat we binnen de inventaris verplaatsen
let activePouchItem = null; // For dragging items within a pouch
let activeContainerItem = null; // NIEUW: Het item dat we binnen de container verplaatsen
let activeInventoryDiv = null; // The DOM element being rearranged
let inventoryDragOffset = {x:0, y:0}; // NIEUW: Offset voor slepen in inventaris
let containerDragOffset = {x:0, y:0}; // NIEUW: Offset voor slepen in container
let pickupTimer = null; // NIEUW: Timer voor vertraagd oppakken
let pendingPickup = null; // NIEUW: Data voor vertraagd oppakken
let dragStart = {x:0, y:0};
let camStart = {x:0, y:0};

// Smooth center
let camTargetX = 0;
let camTargetY = 0;
let camSmooth = false;

// Bouwmodus
let highestZ = 21; // Startwaarde voor z-index management

function bringToFront(element) {
    // Reset z-index van alle vensters naar een basiswaarde
    document.getElementById('buildMenu').style.zIndex = 20;
    document.getElementById('pouchWindow').style.zIndex = 20;
    document.getElementById('chatLog').style.zIndex = 20;
    document.getElementById('inventory').style.zIndex = 20;
    document.getElementById('vicinityWindow').style.zIndex = 20;
    document.getElementById('shopWindow').style.zIndex = 20;
    document.getElementById('containerWindow').style.zIndex = 20;
    document.getElementById('roomsWindow').style.zIndex = 20;
    document.getElementById('myRoomWindow').style.zIndex = 20;
    document.getElementById('roomPlayersWindow').style.zIndex = 20;
    document.getElementById('friendsWindow').style.zIndex = 20;
    // Plaats het geklikte element op de voorgrond
    element.style.zIndex = highestZ;
}

function closeSecondaryWindows() {
    document.getElementById('chatLog').style.display = 'none';
    document.getElementById('inventory').style.display = 'none';
    document.getElementById('vicinityWindow').style.display = 'none';
    document.getElementById('pouchWindow').style.display = 'none';
    document.getElementById('shopWindow').style.display = 'none';
    document.getElementById('containerWindow').style.display = 'none';
    document.getElementById('roomsWindow').style.display = 'none';
    document.getElementById('myRoomWindow').style.display = 'none';
    document.getElementById('roomPlayersWindow').style.display = 'none';
    document.getElementById('friendsWindow').style.display = 'none';
}

function closeAllWindows() {
    closeSecondaryWindows();
    if (isBuildMode) {
        // Gebruik de bestaande klik-logica om de bouwmodus correct af te sluiten en op te ruimen
        buildBtn.click();
    }
}

let isBuildMode = false;
let selectedBuildObject = null;
let isBuildObjectFlipped = false; // Voor het spiegelen van objecten
let buildTool = 'place'; // 'place', 'move', 'delete'
let showTileNumbers = false; // Toggle voor tegelnummers
let movingObject = null; // Object dat wordt verplaatst

let selectedColor = '#ff0000'; // Default kleur
let windowStatesBeforeDrag = null; // Onthoudt welke vensters open waren
let draggedObject = null; // Voor het verslepen van 'moveable' objecten buiten bouwmodus
let draggedItem = null; // NIEUW: Item dat wordt versleept
let draggedItemOriginalPos = null; // NIEUW: Originele positie van het versleepte item
let dragImageElement = null; // NIEUW: DOM element voor visuele weergave tijdens slepen
let draggedObjectOriginalPos = null;
let camOriginalPos = null; // Voor het resetten van de camera na het slepen van een object

let activeObjectSubCategory = 'objects'; // Start met 'objects' geselecteerd
let activeMenuContext = 'player'; // 'player' or 'admin'
let activeBuildCategory = 'objecten'; // 'objecten', 'kleur', etc.
let colorTool = 'brush'; // 'brush', 'bucket'

let tileColors = {}; // Slaat de aangepaste tegelkleuren op
let wallColors = {}; // Slaat de muurkleuren op per segment, bv: { 'top_5': '#ff0000' }
let wallObjects = []; // Slaat geplaatste muurobjecten op, bv: { wallId: 'top_5', name: 'Muurdecoratie', flipped: false }

let hoverTarget = null; // Houdt bij wat er gehoverd wordt: { type: 'tile'/'wall', id: 'x,y'/'top'/'left' }
let activeInteractionButton = null; // NIEUW: Voor klikbare interacties

// Object image
const objectImg = new Image();
objectImg.src = "object_template.png"; // 64x64 symmetrisch
const objectImg96 = new Image();
objectImg96.src = "object_template_96.png"; // 64x96 symmetrisch
const objectImg96B = new Image();
objectImg96B.src = "object_template_96_B.png"; // 1 hoog, 2 breed
const moveableObjectImg = new Image();
moveableObjectImg.src = "object_moveable_template.png";
const moveableObjectImg96B = new Image();
moveableObjectImg96B.src = "object_moveable_template_96_B.png";
const wallItemImg = new Image();
wallItemImg.src = "wall_template.png";
const wallItem2Img = new Image(); // NIEUW
wallItem2Img.src = "wall_2_template.png"; // NIEUW
const wallFreeImg = new Image(); // NIEUW
wallFreeImg.src = "wall_free_template.png"; // NIEUW
const wallFree2Img = new Image(); // NIEUW
wallFree2Img.src = "wall_2_free_template.png"; // NIEUW
const floorImg = new Image();
floorImg.src = "floor_template.png";

const pongImg = new Image();
pongImg.src = "objects/pong.png";
const pongPromptImg = new Image();
pongPromptImg.src = "prompts/pong.png";
const shopPromptImg = new Image();
shopPromptImg.src = "prompts/winkel.png";
const winkelImg = new Image();
winkelImg.src = "winkel_template_96.png";
const winkelImg96B = new Image();
winkelImg96B.src = "winkel_template_96_B.png";
const containerImg = new Image();
containerImg.src = "container_template.png";
const containerPromptImg = new Image();
containerPromptImg.src = "prompts/container.png";
const trashPromptImg = new Image();
trashPromptImg.src = "prompts/trash.png";
const containerImg96 = new Image();
containerImg96.src = "container_template_96.png";
const containerImg96B = new Image();
containerImg96B.src = "container_template_96_B.png";
const trashImg = new Image();
trashImg.src = "trash_template.png";
const trashImg96B = new Image();
trashImg96B.src = "trash_template_96_B.png";

// Nieuwe afbeelding voor oppakbare items
const itemImg = new Image();
itemImg.src = "item_block.png"; // Zorg ervoor dat dit bestand bestaat

const itemRoundImg = new Image();
itemRoundImg.src = "item_round.png"; // De nieuwe ronde afbeelding

const currencyItemImg = new Image();
currencyItemImg.src = "currency_item.png";

const currencyItemBigImg = new Image();
currencyItemBigImg.src = "currency_item_big.png";

const itemStickImg = new Image();
itemStickImg.src = "item_stick.png";

const itemContainerImg = new Image();
itemContainerImg.src = "item_container.png";

const batjeRoodImg = new Image();
batjeRoodImg.src = "items/batje_rood.png";

const batjeZwartImg = new Image();
batjeZwartImg.src = "items/batje_zwart.png";

const sigarettenContainerImg = new Image();
sigarettenContainerImg.src = "items/sigaretten_container.png";

const sigaretStickImg = new Image();
sigaretStickImg.src = "items/sigaret_stick.png";

const sigaretHalfStickImg = new Image(); // NIEUW: Halve sigaret afbeelding
sigaretHalfStickImg.src = "items/sigaret_half.png";

const aanstekerStickImg = new Image();
aanstekerStickImg.src = "items/aansteker_stick.png";

const sigaretHalfImg = new Image();
sigaretHalfImg.src = "items/sigaret_half.png";

const peukStickImg = new Image();
peukStickImg.src = "items/peuk_stick.png";

const bottleFullImg = new Image();
bottleFullImg.src = "items/bottle_W_full.png";

const bottleEmptyImg = new Image();
bottleEmptyImg.src = "items/bottle_W_empty.png";

const bottleHalfImg = new Image();
bottleHalfImg.src = "items/bottle_W_50.png";

// Helper om server data om te zetten naar client item (met plaatje)
function createItemFromData(data) {
    let img = itemImg;
    if (data.type === 'ball') img = itemRoundImg;
    else if (data.type === 'currency') img = currencyItemImg;
    else if (data.type === 'currency_big') img = currencyItemBigImg;
    else if (data.type === 'stick') img = itemStickImg;
    else if (data.type === 'pouch') img = itemContainerImg;
    else if (data.type === 'bat_red') img = batjeRoodImg;
    else if (data.type === 'bat_black') img = batjeZwartImg;
    else if (data.type === 'sigaretten_container') img = sigarettenContainerImg;
    else if (data.type === 'sigaret') img = sigaretStickImg;
    else if (data.type === 'aansteker') img = aanstekerStickImg;
    else if (data.type === 'sigaret_half') img = sigaretHalfImg;
    else if (data.type === 'peuk') img = peukStickImg;
    else if (data.type === 'bottle_full') img = bottleFullImg;
    else if (data.type === 'bottle_empty') img = bottleEmptyImg;
    else if (data.type === 'bottle_half') img = bottleHalfImg;
    
    // Recursief hydrateren van items in een pouch
    if (data.items && Array.isArray(data.items)) {
        data.items = data.items.map(createItemFromData);
    }

    return {
        ...data,
        image: img
    };
}

// Helper om client item om te zetten naar server data (zonder plaatje)
function serializeItem(item) {
    let { image, ...data } = item;
    data = { ...data }; // Maak een kopie om het originele object niet te muteren

    // Recursief serialiseren van items in een pouch
    if (data.items && Array.isArray(data.items)) {
        data.items = data.items.map(serializeItem);
    }
    return data;
}

// Functie om items naar server te sturen
function syncItems() {
    if (socket) {
        const serializedItems = items.map(serializeItem);
        socket.emit('updateItems', serializedItems);
    }
}

// Array voor oppakbare items (wordt nu gevuld door server)
const items = [];

// Array voor items in de inventaris
const inventoryItems = [];
let walletBalance = 0.00;
const shopOutputItems = []; // Items in de uitgiftebak van de winkel
let highestInventoryZ = 10; // Voor z-index management in inventory
let highestContainerZ = 10; // Voor z-index management in container
let transactionFadeTimeout;

// NIEUW: Persistente data functies (Opslaan & Laden)
function savePlayerData() {
    const data = {
        wallet: walletBalance,
        inventory: inventoryItems.map(serializeItem)
    };
    sessionStorage.setItem('habboClonePlayerData', JSON.stringify(data));
}

function loadPlayerData() {
    const stored = sessionStorage.getItem('habboClonePlayerData');
    if (stored) {
        try {
            const data = JSON.parse(stored);
            if (typeof data.wallet === 'number') {
                walletBalance = data.wallet;
                document.getElementById('wallet').textContent = `â‚¬${walletBalance.toFixed(2)}`;
            }
            if (Array.isArray(data.inventory)) {
                inventoryItems.length = 0;
                data.inventory.forEach(itemData => {
                    inventoryItems.push(createItemFromData(itemData));
                });
            }
        } catch (e) {
            console.error("Fout bij laden speler data", e);
        }
    }
}

// Laad data direct bij opstarten
loadPlayerData();

function addToWallet(amount) {
    walletBalance += amount;
    document.getElementById('wallet').textContent = `â‚¬${walletBalance.toFixed(2)}`;

    const feed = document.getElementById('transactionFeed');
    const sign = amount >= 0 ? '+' : '';
    feed.textContent = `${sign}â‚¬${amount.toFixed(2)}`;
    feed.style.color = amount >= 0 ? '#4cd137' : '#ff4757'; // Groen of Rood
    
    // Reset animatie
    feed.style.transition = 'none';
    feed.style.opacity = '1';
    
    if (transactionFadeTimeout) clearTimeout(transactionFadeTimeout);
    
    // Start fade out
    transactionFadeTimeout = setTimeout(() => {
        feed.style.transition = 'opacity 2s ease-out';
        feed.style.opacity = '0';
    }, 1000);
    
    savePlayerData(); // Opslaan bij wijziging van geld
}

let notificationTimer = null;
let notificationFadeTimer = null;

function clearNotificationTimers() {
    if (notificationTimer) clearTimeout(notificationTimer);
    if (notificationFadeTimer) clearTimeout(notificationFadeTimer);
    notificationTimer = null;
    notificationFadeTimer = null;
}

function showNotification(message, iconSrc = null) {
    clearNotificationTimers();
    const notif = document.getElementById('notification');
    notif.style.pointerEvents = 'none'; // Default for simple notifications

    let content = message;
    if (iconSrc) {
        content = `
            <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                <img src="${iconSrc}" style="width:24px; height:24px; image-rendering:pixelated;">
                <span>${message}</span>
            </div>
        `;
    }
    notif.innerHTML = content;
    notif.style.display = 'block';
    // Force reflow om transitie te triggeren
    void notif.offsetWidth;
    notif.style.opacity = '1';
    
    notificationTimer = setTimeout(() => {
        notif.style.opacity = '0';
        notificationFadeTimer = setTimeout(() => {
            notif.style.display = 'none';
        }, 500); // Wacht op transitie
    }, 3000);
}

// NIEUW: Generieke bevestiging pop-up
function showConfirmation(options) {
    clearNotificationTimers();
    // options = { message, subMessage, icon, onConfirm, onDeny, confirmText, denyText }
    const notif = document.getElementById('notification');
    notif.style.pointerEvents = 'auto';

    const iconHtml = options.icon ? `<img src="${options.icon}" style="width:16px; height:16px; image-rendering:pixelated; vertical-align:middle; margin-right: 5px;">` : '';
    const confirmText = options.confirmText || 'Ja';
    const denyText = options.denyText || 'Nee';

    notif.innerHTML = `
        <div class="popup-content">
            <div class="popup-header">
                ${iconHtml}
                <span>${options.message}</span>
            </div>
            ${options.subMessage ? `<div class="popup-sub">${options.subMessage}</div>` : ''}
            <div class="popup-actions">
                <button id="confirmYes" class="popup-btn confirm">${confirmText}</button>
                <button id="confirmNo" class="popup-btn deny">${denyText}</button>
            </div>
        </div>
    `;
    notif.style.display = 'block';
    notif.style.opacity = '1';

    const close = () => {
        notif.style.display = 'none';
        notif.style.pointerEvents = 'none';
    };

    document.getElementById('confirmYes').onclick = () => {
        if (options.onConfirm) options.onConfirm();
        close();
    };
    document.getElementById('confirmNo').onclick = () => {
        if (options.onDeny) options.onDeny();
        close();
    };
}

// NIEUW: Generieke melding pop-up (Ã©Ã©n knop)
function showAlert(options) {
    clearNotificationTimers();
    const notif = document.getElementById('notification');
    notif.style.pointerEvents = 'auto';

    const iconHtml = options.icon ? `<img src="${options.icon}" style="width:16px; height:16px; image-rendering:pixelated; vertical-align:middle; margin-right: 5px;">` : '';

    notif.innerHTML = `
        <div class="popup-content">
            <div class="popup-header">
                ${iconHtml}
                <span>${options.message}</span>
            </div>
            ${options.subMessage ? `<div class="popup-sub">${options.subMessage}</div>` : ''}
            <div class="popup-actions">
                <button id="alertOk" class="popup-btn neutral">OkÃ©</button>
            </div>
        </div>
    `;
    notif.style.display = 'block';
    notif.style.opacity = '1';

    document.getElementById('alertOk').onclick = () => {
        if (options.onOk) options.onOk();
        notif.style.display = 'none';
        notif.style.pointerEvents = 'none';
    };
}

// NIEUW: Generieke input prompt (voor hernoemen etc.)
function showInputPrompt(options) {
    clearNotificationTimers();
    const notif = document.getElementById('notification');
    notif.style.pointerEvents = 'auto';

    notif.innerHTML = `
        <div class="popup-content">
            <div class="popup-header">${options.message}</div>
            <input type="text" id="promptInput" value="${options.defaultValue || ''}" class="popup-input">
            <div class="popup-actions">
                <button id="promptOk" class="popup-btn confirm">Bevestigen</button>
                <button id="promptCancel" class="popup-btn deny">Annuleren</button>
            </div>
        </div>
    `;
    notif.style.display = 'block';
    notif.style.opacity = '1';

    const input = document.getElementById('promptInput');
    input.focus();
    input.select();

    const close = () => {
        notif.style.display = 'none';
        notif.style.pointerEvents = 'none';
    };

    document.getElementById('promptOk').onclick = () => {
        if (options.onConfirm) options.onConfirm(input.value);
        close();
    };
    document.getElementById('promptCancel').onclick = () => {
        close();
    };
    
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            if (options.onConfirm) options.onConfirm(input.value);
            close();
        }
    });
}

// Standaard objecten voor de 'testroom' als deze leeg is op de server.
const defaultTestRoomObjects = [
    { x: 5, y: 5, height: 1, width: 2, depth: 1, flipped: false, name: "Tafel" },
    { x: 5, y: 8, height: 1, width: 2, depth: 1, flipped: true, name: "Tafel" },
    { x: 10, y: 5, height: 1, width: 2, depth: 1, flipped: false, name: "Pong" },
    { x: 10, y: 10, height: 2, flipped: false, name: "Hoge Blok" },
    { x: 15, y: 8, height: 1, flipped: false, name: "Blok" },
    { x: 3, y: 18, height: 2, flipped: true, name: "Hoge Blok" },
    { x: 20, y: 20, height: 1, flipped: false, name: "Blok" },
    { x: 18, y: 3, height: 2, flipped: false, name: "Hoge Blok" },
    { x: 8, y: 12, height: 1, flipped: false, moveable: true, name: "Verplaatsbaar Blok" },
    { x: 16, y: 5, height: 2, flipped: false, name: "Winkel" },
    { x: 19, y: 5, height: 2, flipped: true, name: "Winkel" },
    { x: 12, y: 5, height: 1, flipped: false, name: "Container" },
    { x: 12, y: 8, height: 2, flipped: false, name: "Grote Container" },
    { x: 14, y: 8, height: 1, width: 2, depth: 1, flipped: false, name: "Brede Container" },
    { x: 8, y: 8, height: 1, flipped: false, name: "Prullenbak" }
];

// Objecten array - wordt gevuld door de server.
const objects = [];

let isSmoking = false;
let smokeInterval = null;
let currentSmokingItemType = null;
let isDrinking = false;
let drinkInterval = null;
let currentDrinkingItemType = null;

// Helper om te checken of er een aansteker is (ook in pouches)
function hasLighterInInventory(items) {
    return items.some(i => {
        if (i.type === 'aansteker' || (i.name && i.name.toLowerCase() === 'aansteker')) return true;
        if (i.items && Array.isArray(i.items)) {
            return hasLighterInInventory(i.items);
        }
        return false;
    });
}

// NIEUW: Functie om een aansteker te vinden en te gebruiken
function findAndUseLighter(items) {
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.type === 'aansteker') {
            // Initialiseer 'uses' als het niet bestaat
            if (item.uses === undefined) {
                item.uses = 50; // AANGEPAST: 50 uses default
            }

            if (item.uses > 0) {
                item.uses--; // Verminder gebruik
                if (item.uses <= 0) {
                    showNotification("Je aansteker is leeg!");
                }
                
                savePlayerData(); // Sla wijzigingen op
                renderInventoryItems(); // Her-render om wijziging te tonen
                return true; // Aansteker gevonden en gebruikt
            }
        }

        // Recursief zoeken in pouches
        if (item.items && Array.isArray(item.items)) {
            if (findAndUseLighter(item.items)) {
                // Als gevonden in een sub-pouch, her-render de relevante UI
                if (openPouch) renderPouchItems();
                if (openContainer) renderContainerItems();
                return true;
            }
        }
    }
    return false; // Geen aansteker gevonden
}

function smokeCigarette(item) {
    if (isSmoking) {
        showNotification("Je bent al aan het roken!");
        return;
    }

    // NIEUW: Check of roken is toegestaan in deze kamer
    if (currentRoomSettings.noSmoking && !isUserAdmin && !isRoomOwner) {
        showConfirmation({
            message: "Verboden te roken in deze ruimte.",
            subMessage: "Wil je naar buiten?",
            icon: 'icons/verboden_active.png',
            confirmText: 'Ja',
            denyText: 'Nee',
            onConfirm: () => { window.location.search = '?room=buiten'; }
        });
        return;
    }

    // Check of de speler een aansteker heeft en gebruik deze
    if (!findAndUseLighter(inventoryItems)) {
        showNotification("Je hebt geen aansteker!");
        return;
    }

    const cigaretteIndex = inventoryItems.indexOf(item);

    if (cigaretteIndex === -1) return; // Sigaret is niet (meer) in inventory.

    // Verwijder nu pas de sigaret uit de array.
    inventoryItems.splice(cigaretteIndex, 1);
    
    savePlayerData();
    renderInventoryItems();
    currentSmokingItemType = item.type;
    isSmoking = true;
    ball.smokingStartTime = Date.now(); // NIEUW: Starttijd opslaan voor animatie
    ball.smokingItemType = item.type; // Opslaan welk type we roken
    if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isSmoking: true, smokingItemType: item.type }); // NIEUW: Vertel server wat we roken

    if (typeof sendChatMessage === 'function') {
            sendChatMessage("*steekt een sigaret op*");
    }

        // UI Setup
        const barContainer = document.getElementById('statusBarContainer');
        const barFill = document.getElementById('statusBarFill');
        const barText = document.getElementById('statusBarText');
        
        barContainer.style.display = 'block';
        barText.textContent = "Roken";
        barFill.style.width = '0%';

        const duration = (item.type === 'sigaret_half') ? 5000 : 10000; // 5s voor half, 10s voor heel

        // NIEUW: 10% kans op een opmerking tijdens het roken
        if (Math.random() < 0.1) {
            const randomTime = Math.random() * (duration - 2000) + 1000; // Zeg iets tussen 1s en (duur-1)s
            setTimeout(() => {
                if (isSmoking && currentSmokingItemType === item.type) { // Alleen als we nog roken
                    const phrases = ["*kuch*", "*paf*", "*zucht*"];
                    const phrase = phrases[Math.floor(Math.random() * phrases.length)];
                    if (typeof sendChatMessage === 'function') sendChatMessage(phrase);
                }
            }, randomTime);
        }

        const startTime = Date.now();
        const intervalTime = 100; // update elke 100ms

        smokeInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(100, (elapsed / duration) * 100);
            barFill.style.width = `${progress}%`;

            if (elapsed >= duration) {
                clearInterval(smokeInterval);
                isSmoking = false;
                barContainer.style.display = 'none';
                currentSmokingItemType = null;
                if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isSmoking: false, smokingItemType: null }); // NIEUW: Stop roken op server

                // NIEUW: Laat een peuk vallen
                const buttItem = {
                    type: 'peuk',
                    name: 'Peuk',
                    x: ball.x + (Math.random() * 0.4 - 0.2), // Klein beetje random offset
                    y: ball.y + (Math.random() * 0.4 - 0.2),
                    z: 20, // Valt van heuphoogte
                    rotation: Math.random() * Math.PI * 2, // Willekeurige rotatie
                    mass: 0.01,
                    canTopple: true,
                    vx: 0, vy: 0, vz: 0, vr: 0 // Initialiseer physics variabelen
                };
                // Stuur naar server zodat iedereen hem ziet vallen
                if (socket) socket.emit('placeItem', buttItem);
            }
        }, intervalTime);    
}

function drinkBottle(item) {
    if (isSmoking || isDrinking || document.getElementById('statusBarContainer').style.display === 'block') {
        showNotification("Je bent al bezig met iets!");
        return;
    }

    const index = inventoryItems.indexOf(item);
    if (index === -1) return;

    // Verwijder volle fles
    inventoryItems.splice(index, 1);
    savePlayerData();
    renderInventoryItems();

    currentDrinkingItemType = item.type;
    ball.drinkingStartTime = Date.now();
    ball.drinkingItemType = item.type;
    if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isDrinking: true, drinkingItemType: item.type });

    // UI Setup
    const barContainer = document.getElementById('statusBarContainer');
    const barFill = document.getElementById('statusBarFill');
    const barText = document.getElementById('statusBarText');
    
    barContainer.style.display = 'block';
    barText.textContent = "Drinken";
    barFill.style.width = '0%';

    isDrinking = true;
    const startTime = Date.now(); // NIEUW: Gebruik tijdstempel
    // Volle fles 4 sec, halve fles 2 sec
    const duration = (item.type === 'bottle_full') ? 4000 : 2000; 
    const intervalTime = 100;

    drinkInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(100, (elapsed / duration) * 100);
        barFill.style.width = `${progress}%`;

        if (elapsed >= duration) {
            clearInterval(drinkInterval);
            isDrinking = false;
            currentDrinkingItemType = null;
            if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isDrinking: false, drinkingItemType: null });
            barContainer.style.display = 'none';

            const emptyBottle = {
                type: 'bottle_empty',
                name: 'Leeg flesje',
                mass: 0.8,
                image: bottleEmptyImg,
                vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0,
                invX: Math.floor(Math.random() * 250) + 20,
                invY: Math.floor(Math.random() * 200) + 20
            };
            inventoryItems.push(emptyBottle);
            savePlayerData();
            renderInventoryItems();
        }
    }, intervalTime);
}

function interruptAction() {
    if (isSmoking) {
        clearInterval(smokeInterval);
        isSmoking = false;
        if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isSmoking: false, smokingItemType: null });
        document.getElementById('statusBarContainer').style.display = 'none';
        
        if (currentSmokingItemType === 'sigaret') {
            const halfItem = {
                type: 'sigaret_half',
                name: 'Halve Sigaret',
                mass: 0.05,
                canTopple: true,
                image: sigaretHalfImg,
                vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0,
                invX: Math.floor(Math.random() * 250) + 20,
                invY: Math.floor(Math.random() * 200) + 20
            };
            
            inventoryItems.push(halfItem);
            savePlayerData();
            renderInventoryItems();
            showNotification("Roken onderbroken");
        } else if (currentSmokingItemType === 'sigaret_half') {
            const buttItem = {
                type: 'peuk',
                name: 'Peuk',
                x: ball.x + (Math.random() * 0.4 - 0.2),
                y: ball.y + (Math.random() * 0.4 - 0.2),
                z: 20,
                rotation: Math.random() * Math.PI * 2,
                mass: 0.01,
                canTopple: true,
                vx: 0, vy: 0, vz: 0, vr: 0
            };
            if (socket) socket.emit('placeItem', buttItem);
            showNotification("Roken onderbroken");
        }
        
        currentSmokingItemType = null;
    }
    if (isDrinking) {
        clearInterval(drinkInterval);
        isDrinking = false;
        document.getElementById('statusBarContainer').style.display = 'none';
        currentDrinkingItemType = null;
        if (socket) socket.emit('playerMovement', { x: ball.x, y: ball.y, isDrinking: false, drinkingItemType: null });
        
        // Als onderbroken, krijg je een halfvol flesje terug (of het nou vol of half was)
        const halfBottle = {
            type: 'bottle_half',
            name: 'Halfvol flesje',
            mass: 1.0,
            image: bottleHalfImg,
            vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0,
            invX: Math.floor(Math.random() * 250) + 20,
            invY: Math.floor(Math.random() * 200) + 20
        };
        inventoryItems.push(halfBottle);
        savePlayerData();
        renderInventoryItems();
        showNotification("Drinken onderbroken");
    }
}

function drawPlacementOutline() {
    const obj = (selectedBuildObject?.placement === 'floor' && selectedBuildObject) || movingObject || draggedObject || draggedItem;
    if (obj && hoverCell) {
        const isFlipped = (obj === selectedBuildObject) ? isBuildObjectFlipped : (obj.flipped || false);
        const w = isFlipped ? (obj.depth || 1) : (obj.width || 1);
        const d = isFlipped ? (obj.width || 1) : (obj.depth || 1);
        
        let isValidPlacement = true;
        for(let dx = 0; dx < w; dx++) {
            for(let dy = 0; dy < d; dy++) {
                const tx = hoverCell.x + dx;
                const ty = hoverCell.y + dy;
                if (tx >= mapW || ty >= mapH) {
                    isValidPlacement = false;
                } else if (!obj.isFloor && !obj.isItem && obj !== draggedItem && (isBlocked(tx, ty) || (Math.floor(ball.x) === tx && Math.floor(ball.y) === ty))) {
                    isValidPlacement = false;
                }
            }
        }
        
        // NIEUW: Check afstand voor draggedItem (max 2 tegels)
        if (obj === draggedItem) {
             const dist = Math.sqrt(Math.pow(hoverCell.x - Math.floor(ball.x), 2) + Math.pow(hoverCell.y - Math.floor(ball.y), 2));
             if (dist > 2) isValidPlacement = false;
        }

        const p0 = toScreen(hoverCell.x, hoverCell.y);
        const p1 = toScreen(hoverCell.x + w, hoverCell.y);
        const p2 = toScreen(hoverCell.x + w, hoverCell.y + d);
        const p3 = toScreen(hoverCell.x, hoverCell.y + d);

        ctx.save();
        ctx.strokeStyle = isValidPlacement ? "white" : "red";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p0.sx, p0.sy);
        ctx.lineTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);
        ctx.lineTo(p3.sx, p3.sy);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }
}

function renderInventoryItems() {
    const inventoryContent = document.getElementById('inventoryContent');
    inventoryContent.innerHTML = ''; // Maak de lijst leeg

    inventoryItems.forEach((item, index) => {
        // Self-healing: herstel afbeelding indien nodig
        if (!item.image) {
            const hydrated = createItemFromData(item);
            item.image = hydrated.image;
        }

        const div = document.createElement("div"); // NIEUW: Gebruik item.name voor weergave
        div.className = "inventory-item"; // NIEUW: Gebruik specifieke stijl zonder tekst
        const imgSrc = item.image ? item.image.src : '';
        
        // Zet de positie (of default naar 0,0 of een grid-achtige startpositie als het nieuw is)
        // Als invX/invY nog niet bestaat, geven we het een plekje op basis van index (simpele grid fallback)
        if (item.invX === undefined) {
            item.invX = (index % 3) * 110 + 20;
            item.invY = Math.floor(index / 3) * 110 + 20;
        }
        
        div.style.position = 'absolute';
        div.style.left = item.invX + 'px';
        div.style.top = item.invY + 'px';
        
        div.innerHTML = `<img src="${imgSrc}" alt="Item" title="Sleep naar de kamer">`;
        
        // NIEUW: Rechtermuisknop menu (Context Menu)
        div.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (item.isPouch || item.type === 'pouch' || item.type === 'sigaret' || item.type === 'sigaret_half' || item.type === 'bottle_full' || item.type === 'bottle_half') {
                showItemContextMenu(e.clientX, e.clientY, item);
            }
        });

        // Event listener om items vanuit de inventaris te slepen
        div.addEventListener("mousedown", (e) => {
            // Handmatige dubbelklik detectie om conflicten te voorkomen
            const now = Date.now();
            const lastClick = parseFloat(div.dataset.lastClick) || 0;

            if (now - lastClick < 300) { // 300ms is een goede drempel
                e.preventDefault();
                e.stopPropagation();
                
                if (item.isPouch || item.type === 'pouch') {
                    if (!item.items) {
                        item.items = []; // Initialiseer als het niet bestaat
                    }
                    openContainerWindow(item);
                } else if (item.type === 'sigaret' || item.type === 'sigaret_half') {
                    smokeCigarette(item);
                } else if (item.type === 'bottle_full' || item.type === 'bottle_half') {
                    drinkBottle(item);
                }
                
                div.dataset.lastClick = 0; // Reset voor volgende klik
                isRearrangingInventory = false; // Zorg dat drag niet start
                activeInventoryItem = null;
                activeInventoryDiv = null;
                return;
            }
            div.dataset.lastClick = now;

            // --- Start van de normale 'enkele klik' / sleep logica ---

            // NIEUW: Breng item naar voorgrond
            div.style.zIndex = ++highestInventoryZ;
            
            // Update array volgorde zodat dit ook zo blijft bij her-renderen
            const idx = inventoryItems.indexOf(item);
            if (idx > -1) {
                inventoryItems.push(inventoryItems.splice(idx, 1)[0]);
            }

            e.preventDefault();
            if (e.button === 0) { // Alleen linkermuisknop
                // Start met verplaatsen BINNEN de inventaris
                isRearrangingInventory = true;
                activeInventoryItem = item;
                activeInventoryDiv = div;
                
                // Bereken offset zodat het item niet verspringt onder de muis
                const rect = div.getBoundingClientRect();
                inventoryDragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                e.stopPropagation(); // Voorkom dat andere kliks (zoals op het menu zelf) afgaan
            }
        });

        inventoryContent.appendChild(div);
    });
}

// NIEUW: Logica voor het context menu
const itemContextMenu = document.getElementById('itemContextMenu');
const ctxOpenBtn = document.getElementById('ctxOpenBtn');
const ctxCancelBtn = document.getElementById('ctxCancelBtn');
let currentCtxItem = null;
let ctxDynamicButtons = []; // Houdt dynamisch toegevoegde knoppen bij

function showItemContextMenu(x, y, item) {
    currentCtxItem = item;
    
    // Verwijder oude dynamische knoppen
    ctxDynamicButtons.forEach(btn => btn.remove());
    ctxDynamicButtons = [];

    // Verberg standaard knop tijdelijk
    ctxOpenBtn.style.display = 'none';

    if (item.type === 'sigaret' || item.type === 'sigaret_half') {
        ctxOpenBtn.textContent = "Roken";
        ctxOpenBtn.style.display = 'block';
    } else if (item.type === 'bottle_full' || item.type === 'bottle_half') {
        ctxOpenBtn.textContent = "Drinken";
        ctxOpenBtn.style.display = 'block';
    } else {
        ctxOpenBtn.textContent = "Openen";
        ctxOpenBtn.style.display = 'block';
    }

    itemContextMenu.style.display = 'block';
    itemContextMenu.style.left = x + 'px';
    itemContextMenu.style.top = y + 'px';
}

ctxOpenBtn.addEventListener('click', () => {
    if (currentCtxItem) {
        if (currentCtxItem.type === 'sigaret' || currentCtxItem.type === 'sigaret_half') {
            smokeCigarette(currentCtxItem);
        } else if (currentCtxItem.type === 'bottle_full' || currentCtxItem.type === 'bottle_half') {
            drinkBottle(currentCtxItem);
        } else {
            if (!currentCtxItem.items) currentCtxItem.items = [];
            openContainerWindow(currentCtxItem);
        }
        itemContextMenu.style.display = 'none';
        currentCtxItem = null;
    }
});

ctxCancelBtn.addEventListener('click', () => {
    itemContextMenu.style.display = 'none';
    currentCtxItem = null;
});

window.addEventListener('click', (e) => {
    if (itemContextMenu.style.display === 'block' && !e.target.closest('#itemContextMenu')) {
        itemContextMenu.style.display = 'none';
        currentCtxItem = null;
    }
});

const inventory = document.getElementById("inventory");
const inventoryBtn = document.getElementById("inventoryBtn");

inventoryBtn.addEventListener("click", () => {
    inventory.style.display = inventory.style.display === 'flex' ? 'none' : 'flex';
    inventoryBtn.querySelector('img').src = inventory.style.display === 'flex' ? "icons/inventory_active.png" : "icons/inventory.png";
    renderInventoryItems(); // Update de inventaris wanneer deze wordt geopend

    if (inventory.style.display === 'none') {
        document.getElementById('vicinityWindow').style.display = 'none';
        if (vicinityInterval) clearInterval(vicinityInterval);
        document.querySelector('#vicinityBtn img').src = "icons/vicinity.png";
    }
});

// Vicinity knop logica (visueel)
const vicinityBtn = document.getElementById('vicinityBtn');
if (vicinityBtn) {
    vicinityBtn.addEventListener('click', () => {
        if (vicinityWindow.style.display === 'flex') {
            vicinityWindow.style.display = 'none';
            vicinityBtn.querySelector('img').src = "icons/vicinity.png";
            if (vicinityInterval) clearInterval(vicinityInterval);
        } else {
            vicinityWindow.style.display = 'flex';
            vicinityBtn.querySelector('img').src = "icons/vicinity_active.png";
            renderVicinityItems();
            vicinityInterval = setInterval(renderVicinityItems, 500); // Update elke 500ms
        }
    });
}

// NIEUW: Functie om de hoogte van het oppervlak op een tegel te bepalen
function getSurfaceHeight(x, y) {
    // Zoek het hoogste object op deze tegel
    const obj = objects.find(o => {
        if (o.isFloor) return false; // Vloeren tellen als 0
        const w = o.flipped ? (o.depth || 1) : (o.width || 1);
        const d = o.flipped ? (o.width || 1) : (o.depth || 1);
        return x >= o.x && x < o.x + w && y >= o.y && y < o.y + d;
    });
    if (obj) {
        return (obj.height || 1) * 32; // 32 pixels per hoogte-eenheid
    }
    return 0; // Grond
}

// Collision check
function isBlocked(x, y) {
    // Player kan niet op object tile staan
    return objects.some(o => {
        if (o.isFloor) return false; // Vloer objecten blokkeren niet
        const w = o.flipped ? (o.depth || 1) : (o.width || 1);
        const d = o.flipped ? (o.width || 1) : (o.depth || 1);
        // Check of x,y binnen de bounding box van het object valt
        return x >= o.x && x < o.x + w && y >= o.y && y < o.y + d;
    });
}

// NIEUW: Check of een tegel bezet is door een item (exclusief het item dat we nu slepen)
function isItemOccupied(x, y) {
    return items.some(item => item !== draggedItem && Math.floor(item.x) === x && Math.floor(item.y) === y);
}

// Bouwmodus logica
const buildBtn = document.getElementById("buildBtn");
const buildMenu = document.getElementById("buildMenu");
const buildCategoryMenu = document.getElementById("buildCategoryMenu");
const buildMenuContent = document.getElementById("buildMenuContent");



const buildableObjects = [
    // Admin/Template Objects
    // subCategory: 'objects' (was blok)
    { name: "Blok", height: 1, image: objectImg.src, category: 'objecten', subCategory: 'objects', placement: 'floor', isTemplate: true, price: 10 },
    { name: "Hoge Blok", height: 2, image: objectImg96.src, category: 'objecten', subCategory: 'objects', placement: 'floor', isTemplate: true, price: 20 },
    { name: "Tafel", height: 1, width: 2, depth: 1, image: objectImg96B.src, category: 'objecten', subCategory: 'objects', placement: 'floor', isTemplate: true, price: 50 },
    { name: "Pong", height: 1, width: 2, depth: 1, image: pongImg.src, category: 'objecten', subCategory: 'objects', placement: 'floor', isTemplate: true, price: 1000, interactionType: 'pong' },
    
    // subCategory: 'moveable'
    { name: "Verplaatsbaar Blok", height: 1, image: moveableObjectImg.src, category: 'objecten', subCategory: 'moveable', placement: 'floor', moveable: true, isTemplate: true, price: 30 },
    { name: "Verplaatsbare Tafel", height: 1, width: 2, depth: 1, image: moveableObjectImg96B.src, category: 'objecten', subCategory: 'moveable', placement: 'floor', moveable: true, isTemplate: true, price: 75 },
    
    // subCategory: 'shop'
    { name: "Winkel", height: 2, image: winkelImg.src, category: 'objecten', subCategory: 'shop', placement: 'floor', isTemplate: true, price: 500 },
    { name: "Brede Winkel", height: 1, width: 2, depth: 1, image: winkelImg96B.src, category: 'objecten', subCategory: 'shop', placement: 'floor', isTemplate: true, price: 750 },
    
    // subCategory: 'containers'
    { name: "Container", height: 1, image: containerImg.src, category: 'objecten', subCategory: 'containers', placement: 'floor', isTemplate: true, price: 100 },
    { name: "Grote Container", height: 2, image: containerImg96.src, category: 'objecten', subCategory: 'containers', placement: 'floor', isTemplate: true, price: 200 },
    { name: "Brede Container", height: 1, width: 2, depth: 1, image: containerImg96B.src, category: 'objecten', subCategory: 'containers', placement: 'floor', isTemplate: true, price: 150 },
    
    // subCategory: 'trash'
    { name: "Prullenbak", height: 1, image: trashImg.src, category: 'objecten', subCategory: 'trash', placement: 'floor', isTemplate: true, price: 25 },
    { name: "Brede Prullenbak", height: 1, width: 2, depth: 1, image: trashImg96B.src, category: 'objecten', subCategory: 'trash', placement: 'floor', isTemplate: true, price: 40 },

    // subCategory: 'wall' (was muur)
    { name: "Muurdecoratie", image: wallItemImg.src, category: 'objecten', subCategory: 'wall', placement: 'wall', isTemplate: true, price: 15 },
    { name: "Brede Muurdecoratie", image: wallItem2Img.src, category: 'objecten', subCategory: 'wall', placement: 'wall', isTemplate: true, price: 30, width: 2 },
    { name: "Vrije Muurdecoratie", image: wallFreeImg.src, category: 'objecten', subCategory: 'wall', placement: 'wall', isTemplate: true, price: 20, isFree: true },
    { name: "Brede Vrije Muurdecoratie", image: wallFree2Img.src, category: 'objecten', subCategory: 'wall', placement: 'wall', isTemplate: true, price: 40, isFree: true, width: 2 },

    // subCategory: 'floor'
    { name: "Vloer", image: floorImg.src, category: 'objecten', subCategory: 'floor', placement: 'floor', isTemplate: true, price: 5, isFloor: true },

    // NIEUW: Item Spawns (Items die je kunt plaatsen als objecten)
    // subCategory: 'items'
    { name: "Bal Spawn", image: itemRoundImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'ball', mass: 0.8, canRotate: true, price: 5, isTemplate: true },
    { name: "Blok Item", image: itemImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'block', mass: 1.2, price: 5, isTemplate: true },
    { name: "Pouch", image: itemContainerImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'pouch', isPouch: true, mass: 1.0, price: 50, isTemplate: true },
    { name: "Stok Item", image: itemStickImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'stick', mass: 0.4, canTopple: true, price: 2, isTemplate: true },
    { name: "Geld (Klein)", image: currencyItemImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'currency', mass: 0.5, price: 100, isTemplate: true },
    { name: "Geld (Groot)", image: currencyItemBigImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'currency_big', mass: 0.5, price: 500, isTemplate: true },
    { name: "Batje Rood", image: batjeRoodImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'bat_red', mass: 0.4, canTopple: true, price: 15, isTemplate: true },
    { name: "Batje Zwart", image: batjeZwartImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'bat_black', mass: 0.4, canTopple: true, price: 15, isTemplate: true },
    { name: "Pakje sigaretten", image: sigarettenContainerImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'sigaretten_container', isPouch: true, mass: 0.2, price: 12, isTemplate: true },
    { name: "Sigaret", image: sigaretStickImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'sigaret', mass: 0.05, canTopple: true, price: 1, isTemplate: true },
    { name: "Aansteker", image: aanstekerStickImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'aansteker', mass: 0.1, canTopple: true, price: 2, isTemplate: true, uses: 50 },
    { name: "Flesje water", image: bottleFullImg.src, category: 'objecten', subCategory: 'items', placement: 'floor', isItem: true, itemType: 'bottle_full', mass: 1.2, price: 3, isTemplate: true }
];

function renderBuildItems() {
    const moveToolBtn = document.getElementById("moveToolBtn");
    const deleteToolBtn = document.getElementById("deleteToolBtn");

    buildMenuContent.innerHTML = ''; // Maak de lijst leeg
    const itemsToShow = buildableObjects.filter(item => {
        const isTemplate = !!item.isTemplate; // Convert undefined to false
        
        let contextMatch;
        if (item.isCustom) {
            // Custom items: als adminOnly true is, alleen zichtbaar voor admin. Anders voor iedereen.
            contextMatch = item.adminOnly ? (activeMenuContext === 'admin') : true;
        } else {
            // Standaard items: Admin ziet templates, Speler ziet niet-templates
            contextMatch = (activeMenuContext === 'admin') ? isTemplate : !isTemplate;
        }

        return contextMatch && item.category === activeBuildCategory && item.subCategory === activeObjectSubCategory;
    });

    itemsToShow.forEach(item => {
    const div = document.createElement("div");
    div.className = "build-item";
    let priceHtml = '';
    if (!isUserAdmin && item.price !== undefined) {
        priceHtml = `<div style="color: #4cd137; font-size: 10px;">â‚¬${item.price}</div>`;
    }
    div.innerHTML = `<img src="${item.image}" alt="${item.name}"><div style="text-align: center; width: 100%; font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.name}</div>${priceHtml}`;
    
    // NIEUW: Delete knop voor admins bij custom objecten
    if (activeMenuContext === 'admin' && item.isCustom) {
        const delBtn = document.createElement('span');
        delBtn.innerHTML = 'Ã—';
        delBtn.style.position = 'absolute';
        delBtn.style.top = '2px';
        delBtn.style.right = '2px';
        delBtn.style.color = 'white';
        delBtn.style.background = 'red';
        delBtn.style.borderRadius = '50%';
        delBtn.style.width = '18px';
        delBtn.style.height = '18px';
        delBtn.style.display = 'flex';
        delBtn.style.alignItems = 'center';
        delBtn.style.justifyContent = 'center';
        delBtn.style.cursor = 'pointer';
        delBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm(`Wil je "${item.name}" definitief verwijderen? Dit verwijdert het ook bij alle spelers en geeft geld terug.`)) {
                socket.emit('deleteCustomObject', item.name);
            }
        };
        div.style.position = 'relative';
        div.appendChild(delBtn);
    }

    div.onclick = () => {
        // Activeer 'place' tool
        setBuildTool('place');

        // Deselecteer als het al geselecteerd was
        if (selectedBuildObject && selectedBuildObject.name === item.name) {
            selectedBuildObject = null;
            div.classList.remove("selected");
        } else {
            // Deselecteer tools
            moveToolBtn.classList.remove('selected');
            deleteToolBtn.classList.remove('selected');
            // Deselecteer andere items
            document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
            // Selecteer dit item
            selectedBuildObject = item;
            div.classList.add("selected");
            isBuildObjectFlipped = false; // Reset flip state bij nieuwe selectie
        }
    };
    buildMenuContent.appendChild(div);
    });
}

function renderObjectSubCategories() {
    const subCategoryMenu = document.getElementById('objectSubCategoryMenu');
    subCategoryMenu.innerHTML = ''; // Leegmaken

    // Verzamel unieke subcategorieÃ«n
    const foundCategories = buildableObjects.filter(item => {
        if (item.category !== 'objecten') return false;
        if (item.subCategory === 'items' && activeMenuContext !== 'admin') return false;
        return true;
    }).map(item => item.subCategory);

    // Voeg 'wall' altijd toe zodat de categorie zichtbaar blijft
    const subCategories = [...new Set([...foundCategories, 'wall'])];

    // Maak voor elke subcategorie een knop
    subCategories.forEach(subCat => {
        const btn = document.createElement('button');
        btn.className = 'category-btn'; // Gebruik dezelfde styling
        if (subCat === activeObjectSubCategory) {
            btn.classList.add('selected');
        }
        btn.dataset.subCategory = subCat;
        btn.title = subCat.charAt(0).toUpperCase() + subCat.slice(1); // bv. 'Blok'
        // Kies een icoon op basis van de subcategorie
        const isActive = subCat === activeObjectSubCategory;
        if (subCat === 'objects') {
            btn.innerHTML = `<img src="icons/object${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'wall') {
            btn.innerHTML = `<img src="icons/wall${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'floor') {
            btn.innerHTML = `<img src="icons/floor${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'items') {
            btn.innerHTML = `<img src="icons/items${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'moveable') {
            btn.innerHTML = `<img src="icons/moveable${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'shop') {
            btn.innerHTML = `<img src="icons/winkel${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'containers') {
            btn.innerHTML = `<img src="icons/inventory${isActive ? '_active' : ''}.png">`;
        } else if (subCat === 'trash') {
            btn.innerHTML = `<img src="icons/trash_buildmenu${isActive ? '_active' : ''}.png">`;
        } else {
            // Fallback icoon voor nieuwe categorieÃ«n (moveable, shop, etc.)
            // Je kunt hier specifieke iconen toevoegen zoals 'icons/shop.png' als je die hebt.
            btn.innerHTML = `<img src="icons/object${isActive ? '_active' : ''}.png">`;
        }
        
        
        btn.onclick = () => {
            activeObjectSubCategory = subCat;
            renderObjectSubCategories(); // Her-render om selectie te tonen
            renderBuildItems(); // Her-render de items in de grid
        };
        subCategoryMenu.appendChild(btn);
    });
}

function setBuildTool(tool) {
    buildTool = tool;
    // Deselecteer meubel als we een andere tool kiezen
    if (tool === 'move' || tool === 'delete') {
        selectedBuildObject = null;
        document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
    }

    // Annuleer altijd een 'move' actie als we een andere tool selecteren
    if (movingObject) {
        objects.push(movingObject); // Zet het object terug
        movingObject = null;
    }
}

moveToolBtn.addEventListener('click', () => {
    const img = moveToolBtn.querySelector('img');
    if (buildTool === 'move') {
        setBuildTool('place'); // Terug naar neutraal
        img.src = "icons/place.png";
    } else {
        setBuildTool('move');
        closeSecondaryWindows(); // Sluit andere vensters om conflicten te voorkomen
        img.src = "icons/place_active.png";
        deleteToolBtn.querySelector('img').src = "icons/trash.png"; // Reset delete
    }
});

deleteToolBtn.addEventListener('click', () => {
    const img = deleteToolBtn.querySelector('img');
    setBuildTool(buildTool === 'delete' ? 'place' : 'delete');
    img.src = buildTool === 'delete' ? "icons/trash_active.png" : "icons/trash.png";
    moveToolBtn.querySelector('img').src = "icons/place.png"; // Reset move
});

// --- Kruisjes om menu's te sluiten ---
document.getElementById('closeBuildMenuBtn').addEventListener('click', () => {
    closeBuildAdminMenu();
});

document.getElementById('closeChatLogBtn').addEventListener('click', () => {
    chatLog.style.display = 'none';
    document.querySelector('#openChatLog img').src = "icons/chat.png";
});

document.getElementById('closeInventoryBtn').addEventListener('click', () => {
    inventory.style.display = 'none';
    document.querySelector('#inventoryBtn img').src = "icons/inventory.png";

    document.getElementById('vicinityWindow').style.display = 'none';
    if (vicinityInterval) clearInterval(vicinityInterval);
    document.querySelector('#vicinityBtn img').src = "icons/vicinity.png";
});

buildCategoryMenu.addEventListener('click', (e) => {
    const btn = e.target.closest('.category-btn');
    if (btn) {
        // Verwijder 'selected' van alle categorieknoppen
        buildCategoryMenu.querySelectorAll('.category-btn').forEach(b => {
            b.classList.remove('selected');
            // Reset iconen naar inactive
            const img = b.querySelector('img');
            if (img) {
                if (b.dataset.category === 'objecten') img.src = "icons/object.png";
                if (b.dataset.category === 'kleur') img.src = "icons/color.png";
                if (b.dataset.category === 'kamers') img.src = "icons/new_room.png";
            }
        });
        // Deselecteer de losse tools
        setBuildTool('place');
        
        // Reset tool icons
        document.querySelector('#moveToolBtn img').src = "icons/place.png";
        document.querySelector('#deleteToolBtn img').src = "icons/trash.png";


        // Annuleer een eventuele 'move' actie
        if (movingObject) {
            objects.push(movingObject); // Zet het object terug
            movingObject = null;
        }

        // Annuleer ook een 'place' actie (deselecteer object)
        if (selectedBuildObject) {
            selectedBuildObject = null;
            document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
            isBuildObjectFlipped = false;
        }

        // Voeg 'selected' toe aan de geklikte knop
        btn.classList.add('selected');
        activeBuildCategory = btn.dataset.category;
        
        // Set active icon
        const activeImg = btn.querySelector('img');
        if (activeImg) {
            if (activeBuildCategory === 'objecten') activeImg.src = "icons/object_active.png";
            if (activeBuildCategory === 'kleur') activeImg.src = "icons/color_active.png";
            if (activeBuildCategory === 'kamers') activeImg.src = "icons/new_room_active.png";
        }

        // Wissel de zichtbare content
        document.getElementById('objectCategoryView').style.display = activeBuildCategory === 'objecten' ? 'flex' : 'none';
        document.getElementById('colorCategoryView').style.display = activeBuildCategory === 'kleur' ? 'flex' : 'none';        
        document.getElementById('roomCategoryView').style.display = activeBuildCategory === 'kamers' ? 'block' : 'none';
        
        if (activeBuildCategory === 'objecten') {
            renderObjectSubCategories(); // Render de subcategorie-knoppen
            renderBuildItems(); // Render de items voor de actieve subcategorie
        } else if (activeBuildCategory === 'kamers') {
            // Vraag de server om de lijst met kamers
            if (socket) socket.emit('getRooms');
        }
    }
});



// --- Logica voor Kleur-tools ---
const colorToolsContainer = document.getElementById('colorTools');
colorToolsContainer.addEventListener('click', (e) => {
    const clickedButton = e.target.closest('.tool-btn');
    if (!clickedButton) return;

    // Update de geselecteerde tool
    colorTool = clickedButton.dataset.tool;

    // Update de visuele selectie
    colorToolsContainer.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('selected');
        // Reset icons
        const img = btn.querySelector('img');
        if (btn.dataset.tool === 'brush') img.src = "icons/paint.png";
        if (btn.dataset.tool === 'bucket') img.src = "icons/fill.png";
        if (btn.dataset.tool === 'picker') img.src = "icons/pipet.png";
    });
    clickedButton.classList.add('selected');
    // Set active icon
    const activeImg = clickedButton.querySelector('img');
    if (colorTool === 'brush') activeImg.src = "icons/paint_active.png";
    if (colorTool === 'bucket') activeImg.src = "icons/fill_active.png";
    if (colorTool === 'picker') activeImg.src = "icons/pipet_active.png";
});

// --- iro.js Color Picker Initialisatie ---
const colorPicker = new iro.ColorPicker("#color-picker-container", {
  width: 280, // Iets kleiner voor betere centrering
  color: selectedColor,
  borderWidth: 1,
  borderColor: "#fff",
  layout: [
    {
      component: iro.ui.Box, // Het vierkante kleurvlak
    },
    {
      component: iro.ui.Slider, // De slider voor de kleurtint
      options: { sliderType: 'hue' }
    }
  ]
});

// Update de 'selectedColor' variabele wanneer de kleur verandert
function updateColor(color, source) {
    selectedColor = color.hexString;
    document.getElementById('colorPreview').style.backgroundColor = selectedColor;

    // Voorkom een oneindige loop door niet te updaten als de input de bron was
    if (source !== 'input') {
        document.getElementById('hexInput').value = selectedColor;
    }
}

colorPicker.on('color:change', color => updateColor(color, 'picker'));

document.getElementById('hexInput').addEventListener('change', (e) => {
    const hex = e.target.value;
    // Simpele validatie voor een hex kleur
    if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
        colorPicker.color.hexString = hex;
        // De 'color:change' event van de picker wordt automatisch getriggerd,
        // dus we hoeven updateColor() hier niet expliciet aan te roepen.
    }
});

const adminBtn = document.getElementById("adminBtn");
const buildMenuHeaderSpan = buildMenu.querySelector('#buildMenuHeader span');

function closeBuildAdminMenu() {
    isBuildMode = false;
    buildMenu.style.display = "none";

    // Reset icons
    buildBtn.querySelector('img').src = "icons/buildmenu.png";
    adminBtn.querySelector('img').src = "icons/admin.png";

    // Cleanup logic
    selectedBuildObject = null;
    document.querySelectorAll('.build-item.selected').forEach(el => el.classList.remove('selected'));
    isBuildObjectFlipped = false;
    setBuildTool('place');
    document.querySelector('#moveToolBtn img').src = "icons/place.png";
    document.querySelector('#deleteToolBtn img').src = "icons/trash.png";
    
    // Reset to objecten categorie for the next time
    const objBtn = document.querySelector('.category-btn[data-category="objecten"]'); // Default naar objects/blok
    if(objBtn) objBtn.click();
}

function openBuildAdminMenu(context) {
    // If we click the same button again while the menu is open, close it.
    if (isBuildMode && activeMenuContext === context) {
        closeBuildAdminMenu();
        return;
    }

    isBuildMode = true;
    activeMenuContext = context;
    buildMenu.style.display = "flex";

    // Update header text
    buildMenuHeaderSpan.textContent = (context === 'admin') ? "Admin" : "Bouwmodus";

    // Update button icons
    buildBtn.querySelector('img').src = (context === 'player') ? "icons/buildmenu_active.png" : "icons/buildmenu.png";
    adminBtn.querySelector('img').src = (context === 'admin') ? "icons/admin_active.png" : "icons/admin.png";

    // Toon/verberg de kamers knop
    const roomBtn = document.getElementById('adminRoomBtn');
    if (roomBtn) {
        roomBtn.style.display = (context === 'admin') ? 'flex' : 'none';
    }

    const uploadBtn = document.getElementById('uploadToolBtn');
    if (uploadBtn) {
        uploadBtn.style.display = (context === 'admin') ? 'flex' : 'none';
    }

    // Render content for the new context
    // Reset subcategory to 'objects' (was blok) when opening menu to ensure valid state
    activeObjectSubCategory = 'objects';
    
    const activeCatBtn = document.querySelector('.category-btn[data-category="objecten"]');
    if(activeCatBtn) {
        activeCatBtn.click(); // Trigger click to refresh view
    }
}

buildBtn.addEventListener("click", () => openBuildAdminMenu('player'));
adminBtn.addEventListener("click", () => openBuildAdminMenu('admin'));

document.getElementById('createRoomBtn').addEventListener('click', () => {
    const roomNameInput = document.getElementById('roomNameInput');
    const roomName = roomNameInput.value.trim();
    const selectedSize = document.getElementById('roomSizeSelect').value;
    const alwaysOnline = document.getElementById('adminAlwaysOnlineToggle').dataset.active === "true";
    const allowBuilding = document.getElementById('adminBuildToggle').dataset.allowed === "true";
    const noSmoking = document.getElementById('adminNoSmokingToggle').dataset.forbidden === "true";

    if (!roomName) {
        showNotification("Benoem de kamer.");
        return;
    }
    // Maak een URL-vriendelijke naam
    const sanitizedName = roomName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

    if (!sanitizedName) {
        showNotification("De ingevoerde naam is ongeldig.");
        return;
    }

    // Omdat we geen bestanden kunnen schrijven (browser security), gebruiken we URL parameters.
    // Dit herlaadt de pagina met de nieuwe instellingen (naam en grootte).
    window.location.search = `?room=${sanitizedName}&size=${selectedSize}&alwaysOnline=${alwaysOnline}&allowBuilding=${allowBuilding}&noSmoking=${noSmoking}`;
});

document.getElementById('saveRoomBtn').addEventListener('click', () => {
    socket.emit('manualSaveRoom', { 
        objects: objects, 
        wallObjects: wallObjects, 
        tileColors: tileColors, 
        wallColors: wallColors,
        items: items.map(serializeItem) 
    });
    showNotification("Kamer opgeslagen!");
});

document.getElementById('adminTileNumbersToggle').addEventListener('click', () => {
    showTileNumbers = !showTileNumbers;
    const img = document.getElementById('adminTileNumbersToggle');
    img.src = showTileNumbers ? 'icons/numbers_active.png' : 'icons/numbers.png';
});

document.getElementById('clearRoomBtn').addEventListener('click', () => {
    if (confirm("Weet je zeker dat je alle losse items wilt verwijderen? Geplaatste objecten blijven staan.")) {
        [...items].forEach(item => {
            socket.emit('removeItem', { 
                x: Math.floor(item.x), 
                y: Math.floor(item.y),
                type: item.type,
                name: item.name,
                id: item.id
            });
        });
        showNotification("Alle items verwijderd!");
    }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“¤ UPLOAD CUSTOM ITEM LOGICA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const uploadToolBtn = document.getElementById('uploadToolBtn');
const uploadModal = document.getElementById('uploadModal');
const customFileUpload = document.getElementById('customFileUpload');
const closeUploadModal = document.getElementById('closeUploadModal');
const closeUploadModalCross = document.getElementById('closeUploadModalCross');
const uploadConfigStep = document.getElementById('uploadConfigStep');
let selectedTemplate = null;
let currentUploadFile = null;

// Variabelen voor de visuele editor
const collisionCanvas = document.getElementById('collisionCanvas');
const collisionCtx = collisionCanvas.getContext('2d');
let previewImageObj = null;
let isResizingCollision = false;
let colBox = { x: 0, y: 0, w: 1, h: 1 }; // w,h in tegels, x,y in pixels
let dragMode = null; // 'move', 'se', etc.
let dragStartMouse = { x: 0, y: 0 };
let dragStartBox = { x: 0, y: 0, w: 1, h: 1 };

if (uploadToolBtn) {
    uploadToolBtn.addEventListener('mousedown', () => {
        uploadToolBtn.querySelector('img').src = "icons/add_active.png";
    });
    const resetUploadBtn = () => {
        uploadToolBtn.querySelector('img').src = "icons/add.png";
    };
    uploadToolBtn.addEventListener('mouseup', resetUploadBtn);
    uploadToolBtn.addEventListener('mouseleave', resetUploadBtn);

    uploadToolBtn.addEventListener('click', () => {
        customFileUpload.click();
    });
}

if (closeUploadModal) {
    closeUploadModal.addEventListener('click', () => {
        uploadModal.style.display = 'none';
    });
}

if (closeUploadModalCross) {
    closeUploadModalCross.addEventListener('click', () => {
        uploadModal.style.display = 'none';
    });
}

if (customFileUpload) {
    customFileUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        currentUploadFile = file;

        uploadModal.style.display = 'flex';

        // Toon configuratie stap
        uploadConfigStep.style.display = 'flex';

        // Vul template select
        const templateSelect = document.getElementById('templateSelect');
        templateSelect.innerHTML = '';
        
        const uniqueTemplates = [];
        const seenProps = new Set();
        const allTemplates = buildableObjects.filter(o => o.isTemplate);

        allTemplates.forEach(t => {
             const key = t.name + (t.interactionType || '') + (t.subCategory || '');
             if(!seenProps.has(key)){
                 seenProps.add(key);
                 uniqueTemplates.push(t);
             }
        });

        uniqueTemplates.forEach(t => {
            const option = document.createElement('option');
            option.value = t.name;
            option.text = t.name;
            option.dataset.json = JSON.stringify(t);
            templateSelect.appendChild(option);
        });

        // Selecteer eerste als default
        if(uniqueTemplates.length > 0) {
            selectedTemplate = uniqueTemplates[0];
            document.getElementById('confWalkable').checked = selectedTemplate.isFloor || false;
            document.getElementById('confMoveable').checked = selectedTemplate.moveable || false;
        }

        // Reset inputs
        document.getElementById('confWidth').value = 1;
        document.getElementById('confDepth').value = 1;
        document.getElementById('confHeight').value = 1;

        // Toon preview
        previewImageObj = new Image();
        const reader = new FileReader();
        reader.onload = (evt) => {
            previewImageObj.src = evt.target.result;
            previewImageObj.onload = () => {
                // Reset box naar standaard (isometrisch: ankerpunt in het midden onderaan)
                colBox.w = parseInt(document.getElementById('confWidth').value) || 1;
                colBox.h = parseInt(document.getElementById('confDepth').value) || 1;
                // Zet het ankerpunt (top van de diamant) in het midden van de afbeelding, iets boven de onderkant
                colBox.x = Math.floor(previewImageObj.width / 2);
                colBox.y = Math.max(0, previewImageObj.height - 32); 
                drawCollisionPreview();
            };
        };
        reader.readAsDataURL(file);
    });
}

// Update template bij selectie
document.getElementById('templateSelect').addEventListener('change', (e) => {
    const option = e.target.options[e.target.selectedIndex];
    if(option && option.dataset.json) {
        selectedTemplate = JSON.parse(option.dataset.json);
        document.getElementById('confWalkable').checked = selectedTemplate.isFloor || false;
        document.getElementById('confMoveable').checked = selectedTemplate.moveable || false;
    }
});

// Functie om de preview en het grid te tekenen
function drawCollisionPreview() {
    if (!previewImageObj) return;

    // Haal huidige waarden op
    const w = colBox.w;
    const d = colBox.h;

    // Pas canvas grootte aan op plaatje (met minimum voor grid)
    // We voegen flink wat padding toe zodat je buiten het plaatje kunt slepen
    const canvasW = Math.max(previewImageObj.width + 64, 250); // Kleiner gemaakt
    const canvasH = Math.max(previewImageObj.height + 64, 250); // Kleiner gemaakt
    
    // Voorkom dat canvas reset als grootte niet verandert (voorkomt flikkering)
    if (collisionCanvas.width !== canvasW || collisionCanvas.height !== canvasH) {
        collisionCanvas.width = canvasW;
        collisionCanvas.height = canvasH;
    }

    collisionCtx.clearRect(0, 0, collisionCanvas.width, collisionCanvas.height);
    
    // 1. Teken het plaatje (gecentreerd in canvas)
    const imgX = (canvasW - previewImageObj.width) / 2;
    const imgY = (canvasH - previewImageObj.height) / 2;
    
    // Teken een kader om het plaatje ter referentie
    collisionCtx.strokeStyle = "rgba(255,255,255,0.1)";
    collisionCtx.strokeRect(imgX, imgY, previewImageObj.width, previewImageObj.height);
    
    collisionCtx.drawImage(previewImageObj, imgX, imgY);

    // Sla de offset op voor berekeningen
    collisionCanvas.imgOffset = { x: imgX, y: imgY };

    // 2. Teken het ISOMETRISCHE collision grid
    const originX = imgX + colBox.x;
    const originY = imgY + colBox.y;

    // Helper om schermcoÃ¶rdinaten te krijgen van een tegel (relatief aan origin)
    const getIsoPt = (tx, ty) => {
        const sx = (tx - ty) * 32; // 64 breed / 2
        const sy = (tx + ty) * 16; // 32 hoog / 2
        return { x: originX + sx, y: originY + sy };
    };

    // Punten van de diamant (buitenkant)
    const pTop = getIsoPt(0, 0);
    const pRight = getIsoPt(w, 0);
    const pBottom = getIsoPt(w, d);
    const pLeft = getIsoPt(0, d);

    // Teken het blauwe vlak
    collisionCtx.beginPath();
    collisionCtx.moveTo(pTop.x, pTop.y);
    collisionCtx.lineTo(pRight.x, pRight.y);
    collisionCtx.lineTo(pBottom.x, pBottom.y);
    collisionCtx.lineTo(pLeft.x, pLeft.y);
    collisionCtx.closePath();

    collisionCtx.fillStyle = "rgba(0, 100, 255, 0.4)";
    collisionCtx.fill();
    collisionCtx.strokeStyle = "rgba(0, 100, 255, 0.8)";
    collisionCtx.lineWidth = 2;
    collisionCtx.stroke();
    
    // 3. Teken grid lijnen binnen het vlak
    collisionCtx.strokeStyle = "rgba(255, 255, 255, 0.5)";
    collisionCtx.lineWidth = 1;
    collisionCtx.beginPath();
    for (let i = 0; i <= w; i++) {
        const p1 = getIsoPt(i, 0);
        const p2 = getIsoPt(i, d);
        collisionCtx.moveTo(p1.x, p1.y);
        collisionCtx.lineTo(p2.x, p2.y);
    }
    for (let j = 0; j <= d; j++) {
        const p1 = getIsoPt(0, j);
        const p2 = getIsoPt(w, j);
        collisionCtx.moveTo(p1.x, p1.y);
        collisionCtx.lineTo(p2.x, p2.y);
    }
    collisionCtx.stroke();

    // 4. Teken de 4 hoekpunten (hendels)
    const drawHandle = (pt, color) => {
        collisionCtx.beginPath();
        collisionCtx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
        collisionCtx.fillStyle = color;
        collisionCtx.fill();
        collisionCtx.strokeStyle = "black";
        collisionCtx.lineWidth = 1;
        collisionCtx.stroke();
    };

    drawHandle(pTop, "#ffffff");   // Wit: Verplaatsen (Origin)
    drawHandle(pRight, "#ffeb3b"); // Geel: Breedte (X)
    drawHandle(pLeft, "#ffeb3b");  // Geel: Diepte (Y)
    drawHandle(pBottom, "#ffeb3b"); // Geel: Beide
}

// Muis interactie voor het canvas
collisionCanvas.addEventListener('mousedown', (e) => {
    if (!previewImageObj) return;
    const rect = collisionCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const imgX = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.x : 0;
    const imgY = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.y : 0;
    const originX = imgX + colBox.x;
    const originY = imgY + colBox.y;

    // Helper voor iso punten
    const getIsoPt = (tx, ty) => {
        const sx = (tx - ty) * 32;
        const sy = (tx + ty) * 16;
        return { x: originX + sx, y: originY + sy };
    };

    const pTop = getIsoPt(0, 0);
    const pRight = getIsoPt(colBox.w, 0);
    const pLeft = getIsoPt(0, colBox.h);
    const pBottom = getIsoPt(colBox.w, colBox.h);

    const dist = (p) => Math.sqrt((mx - p.x)**2 + (my - p.y)**2);
    const hitRadius = 12; // Grotere radius voor makkelijker klikken

    // Check handles
    if (dist(pTop) < hitRadius) dragMode = 'move';
    else if (dist(pRight) < hitRadius) dragMode = 'resizeW';
    else if (dist(pLeft) < hitRadius) dragMode = 'resizeD';
    else if (dist(pBottom) < hitRadius) dragMode = 'resizeWD';
    else {
        // Check of we IN de diamant klikken voor verplaatsen
        // Inverse iso transformatie om tegel-coÃ¶rdinaten te vinden
        const dx = mx - originX;
        const dy = my - originY;
        // tx = (dx/32 + dy/16) / 2
        // ty = (dy/16 - dx/32) / 2
        const tileX = (dx / 32 + dy / 16) / 2;
        const tileY = (dy / 16 - dx / 32) / 2;

        if (tileX >= 0 && tileX <= colBox.w && tileY >= 0 && tileY <= colBox.h) {
            dragMode = 'move';
        } else {
            return;
        }
    }

    isResizingCollision = true;
    dragStartMouse = { x: mx, y: my };
    dragStartBox = { ...colBox };
});

window.addEventListener('mousemove', (e) => {
    if (isResizingCollision && uploadModal.style.display === 'flex') {
        const rect = collisionCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const dx = mx - dragStartMouse.x;
        const dy = my - dragStartMouse.y;

        if (dragMode === 'move') {
            colBox.x = dragStartBox.x + dx;
            colBox.y = dragStartBox.y + dy;
        } else {
            // Resize logica (isometrisch)
            // We moeten de muisbeweging vertalen naar 'tegel' delta's
            
            // Origin positie (die verandert niet tijdens resize)
            const imgX = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.x : 0;
            const imgY = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.y : 0;
            const originX = imgX + colBox.x;
            const originY = imgY + colBox.y;

            // Huidige muispositie relatief aan origin
            const relX = mx - originX;
            const relY = my - originY;

            // Converteer naar tegel-eenheden
            const rawTileX = (relX / 32 + relY / 16) / 2;
            const rawTileY = (relY / 16 - relX / 32) / 2;

            let newW = colBox.w;
            let newH = colBox.h;

            if (dragMode === 'resizeW' || dragMode === 'resizeWD') {
                newW = Math.max(1, Math.round(rawTileX));
            }
            if (dragMode === 'resizeD' || dragMode === 'resizeWD') {
                newH = Math.max(1, Math.round(rawTileY));
            }
            
            // Maximaal (bijv 10x10 om gekkigheid te voorkomen)
            if (newW > 10) newW = 10;
            if (newH > 10) newH = 10;

            colBox.w = newW;
            colBox.h = newH;
            
            // Update inputs
            document.getElementById('confWidth').value = newW;
            document.getElementById('confDepth').value = newH;
        }

        drawCollisionPreview();
    } else {
        // Cursor updates
        const rect = collisionCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const imgX = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.x : 0;
        const imgY = collisionCanvas.imgOffset ? collisionCanvas.imgOffset.y : 0;
        const originX = imgX + colBox.x;
        const originY = imgY + colBox.y;

        const getIsoPt = (tx, ty) => {
            const sx = (tx - ty) * 32;
            const sy = (tx + ty) * 16;
            return { x: originX + sx, y: originY + sy };
        };

        const pTop = getIsoPt(0, 0);
        const pRight = getIsoPt(colBox.w, 0);
        const pLeft = getIsoPt(0, colBox.h);
        const pBottom = getIsoPt(colBox.w, colBox.h);
        const dist = (p) => Math.sqrt((mx - p.x)**2 + (my - p.y)**2);
        const hitRadius = 12;

        if (dist(pTop) < hitRadius) collisionCanvas.style.cursor = 'move';
        else if (dist(pRight) < hitRadius || dist(pLeft) < hitRadius || dist(pBottom) < hitRadius) collisionCanvas.style.cursor = 'pointer';
        else {
            // Check inside
            const dx = mx - originX;
            const dy = my - originY;
            const tileX = (dx / 32 + dy / 16) / 2;
            const tileY = (dy / 16 - dx / 32) / 2;
            if (tileX >= 0 && tileX <= colBox.w && tileY >= 0 && tileY <= colBox.h) {
                collisionCanvas.style.cursor = 'move';
            } else {
                collisionCanvas.style.cursor = 'default';
            }
        }
    }
});

window.addEventListener('mouseup', () => {
    isResizingCollision = false;
    dragMode = null;
});

// Update preview als je handmatig getallen typt
document.getElementById('confWidth').addEventListener('input', (e) => {
    colBox.w = parseInt(e.target.value) || 1;
    drawCollisionPreview();
});
document.getElementById('confDepth').addEventListener('input', (e) => {
    colBox.h = parseInt(e.target.value) || 1;
    drawCollisionPreview();
});

// NIEUW: Knoppen voor configuratie stap
document.getElementById('cancelConfigBtn').addEventListener('click', () => {
    uploadModal.style.display = 'none';
    customFileUpload.value = ''; // Reset file input
});

document.getElementById('doUploadBtn').addEventListener('click', () => {
    if (!currentUploadFile || !selectedTemplate) return;

    const nameInput = document.getElementById('customObjectName');
    const enteredName = nameInput.value.trim();
    const priceInput = document.getElementById('customObjectPrice');
    const adminOnlyInput = document.getElementById('customObjectAdminOnly');

    // Haal configuratie waarden op
    const width = colBox.w;
    const depth = colBox.h;
    const height = parseInt(document.getElementById('confHeight').value) || 1;
    const isFloor = document.getElementById('confWalkable').checked;
    const moveable = document.getElementById('confMoveable').checked;

    if (socket) {
        socket.emit('uploadCustomObject', {
            imageData: currentUploadFile,
            template: selectedTemplate,
            name: enteredName,
            price: priceInput.value,
            adminOnly: adminOnlyInput.checked,
            // Stuur custom eigenschappen mee
            width, depth, height, isFloor, moveable,
            xOffset: colBox.x,
            yOffset: colBox.y
        });
        showNotification("Object wordt geÃ¼pload...");
    }

    // Sluit en reset
    uploadModal.style.display = 'none';
    customFileUpload.value = ''; 
    document.getElementById('customObjectName').value = '';
    priceInput.value = '';
    adminOnlyInput.checked = false;
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ PONG MINIGAME LOGICA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const pongCanvas = document.getElementById('pongCanvas');
const pongCtx = pongCanvas.getContext('2d');
const playerScoreEl = document.getElementById('playerScore');
const aiScoreEl = document.getElementById('aiScore');
let pongGameStarted = false; // NIEUW: Houdt bij of we voorbij het startscherm zijn
let pongRunning = false;
let isScoring = false; // NIEUW: Pauze na score
let pongAnimationId;

const pongBall = { x: 300, y: 132, vx: 3, vy: 3, size: 6 }; // Startpositie gecentreerd op 600x264
const paddleHeight = 60;
const paddleWidth = 10;
const playerPaddle = { x: 10, y: 120, score: 0 };
const aiPaddle = { x: 580, y: 120, score: 0 }; // Aangepast naar rechts (600 - 20)

let isPongAI = true; // Default AI
let currentPongOpponentId = null; // ID van tegenstander voor PvP
let pongCountdown = 0; // Afteller
let isPongPaused = false; // Pauze status
let isPongHost = false; // Ben ik de baas over de bal?
let pongPauseCountdown = 0; // Pauze afteller
let pongPauseInterval = null; // Interval voor pauze
let pongPauseInitiator = ""; // Wie heeft gepauzeerd?

function startPongGame(aiMode = true, opponentName = "Tegenstander", opponentId = null, isHost = false) {
    const pongGame = document.getElementById('pongGame');
    pongGame.style.display = 'flex';
    resetPongBall();
    playerPaddle.score = 0;
    aiPaddle.score = 0;
    playerScoreEl.textContent = '0';
    aiScoreEl.textContent = '0';
    
    // Namen instellen
    document.getElementById('playerNameLabel').textContent = "Jij";
    document.getElementById('opponentNameLabel').textContent = opponentName;
    
    currentPongOpponentId = opponentId;
    isPongAI = aiMode;
    isPongHost = isHost;

    // Reset pauze variabelen
    isPongPaused = false;
    if (pongPauseInterval) clearInterval(pongPauseInterval);

    isScoring = false;
    document.getElementById('pongBackdrop').style.display = 'block';
    updatePongCursorState(true); // Verberg cursor wel alvast

    if (isPongAI) {
        pongGameStarted = false; // AI: Wacht op spatie
        pongRunning = false;
    } else {
        // PvP: Start direct met countdown
        pongGameStarted = true;
        pongRunning = false;
        pongCountdown = 3;
        
        // Start aftellen
        const countInterval = setInterval(() => {
            pongCountdown--;
            if (pongCountdown <= 0) {
                clearInterval(countInterval);
                pongRunning = true;
            }
        }, 1000);
    }

    pongLoop();
}

function stopPongGame() {
    const pongGame = document.getElementById('pongGame');
    pongGame.style.display = 'none';
    document.getElementById('pongBackdrop').style.display = 'none';
    pongRunning = false;
    pongGameStarted = false;
    isPongPaused = false;
    if (pongPauseInterval) clearInterval(pongPauseInterval);
    updatePongCursorState(false);
    cancelAnimationFrame(pongAnimationId);
}

document.getElementById('closePongBtn').addEventListener('click', () => {
    // Als we PvP spelen en we sluiten, stuur quit bericht
    if (!isPongAI && socket && currentPongOpponentId) {
        socket.emit('quitPong', { opponentId: currentPongOpponentId });
    }
    stopPongGame();
});

let lastPaddleSend = 0; // Voor throttling

window.addEventListener('mousemove', (e) => {
    // Bestuur batje alleen als spel draait EN we niet het venster aan het slepen zijn
    if (pongRunning && !isDraggingPong && !isPongPaused) {
        const rect = pongCanvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        playerPaddle.y = mouseY - paddleHeight / 2;
    
        // Clamp paddle binnen canvas
        if(playerPaddle.y < 0) playerPaddle.y = 0;
        if(playerPaddle.y > pongCanvas.height - paddleHeight) playerPaddle.y = pongCanvas.height - paddleHeight;

        // Stuur positie naar server voor PvP
        if (socket && !isPongAI) {
            // THROTTLING: Stuur max 1x per 50ms (20fps) om lag te voorkomen
            const now = Date.now();
            if (now - lastPaddleSend > 50) {
                socket.emit('pongPaddleMove', { 
                    y: playerPaddle.y, 
                    opponentId: currentPongOpponentId 
                });
                lastPaddleSend = now;
            }

        }
    }
});

function resetPongBall() {
    pongBall.x = pongCanvas.width / 2;
    pongBall.y = pongCanvas.height / 2;
    pongBall.vx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2); // Snelheid iets verlaagd
    pongBall.vy = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2); // Snelheid iets verlaagd
}

function scorePause() {
    isScoring = true;
    resetPongBall();
    setTimeout(() => {
        isScoring = false;
    }, 1000);
}

function updatePong() {
    // Als we PvP spelen en GEEN host zijn, berekenen we niks zelf.
    // We wachten puur op data van de server.
    if (!isPongAI && !isPongHost) return;

    pongBall.x += pongBall.vx;
    pongBall.y += pongBall.vy;

    // Botsing boven/onder
    if (pongBall.y < 0 || pongBall.y > pongCanvas.height) pongBall.vy = -pongBall.vy;

    if (isPongAI) {
        // AI Beweging (simpel volgen met vertraging)
        const aiCenter = aiPaddle.y + paddleHeight / 2;
        if (aiCenter < pongBall.y - 10) aiPaddle.y += 2.5; 
        else if (aiCenter > pongBall.y + 10) aiPaddle.y -= 2.5;
        
        // Clamp AI
        if(aiPaddle.y < 0) aiPaddle.y = 0;
        if(aiPaddle.y > pongCanvas.height - paddleHeight) aiPaddle.y = pongCanvas.height - paddleHeight;
    }

    // Botsing Speler Paddle
    if (pongBall.x < playerPaddle.x + paddleWidth && pongBall.y > playerPaddle.y && pongBall.y < playerPaddle.y + paddleHeight) {
            pongBall.vx = -pongBall.vx * 1.05; // Versnellen
            pongBall.x = playerPaddle.x + paddleWidth;
    }
    // Botsing AI Paddle
    if (pongBall.x > aiPaddle.x - pongBall.size && pongBall.y > aiPaddle.y && pongBall.y < aiPaddle.y + paddleHeight) {
            pongBall.vx = -pongBall.vx * 1.05;
            pongBall.x = aiPaddle.x - pongBall.size;
    }

    // Score
    if (pongBall.x < 0) { 
        aiPaddle.score++; 
        aiScoreEl.textContent = aiPaddle.score;
        scorePause(); 
        if (!isPongAI) sendScoreUpdate();
    }
    else if (pongBall.x > pongCanvas.width) { 
        playerPaddle.score++; 
        playerScoreEl.textContent = playerPaddle.score;
        scorePause(); 
        if (!isPongAI) sendScoreUpdate();
    }

    // Als Host: stuur bal positie naar tegenstander
    if (!isPongAI && isPongHost && socket) {
        socket.emit('pongBallUpdate', {
            x: pongBall.x,
            y: pongBall.y,
            vx: pongBall.vx,
            vy: pongBall.vy,
            opponentId: currentPongOpponentId
        });
    }
}

function sendScoreUpdate() {
    if (socket && currentPongOpponentId) {
        socket.emit('pongScoreUpdate', {
            playerScore: playerPaddle.score,
            aiScore: aiPaddle.score,
            opponentId: currentPongOpponentId
        });
    }
}

function drawPong() {
    pongCtx.clearRect(0, 0, pongCanvas.width, pongCanvas.height); // Leegmaken voor transparantie
    
    pongCtx.fillStyle = 'white';
    pongCtx.fillRect(playerPaddle.x, playerPaddle.y, paddleWidth, paddleHeight);
    pongCtx.fillRect(aiPaddle.x, aiPaddle.y, paddleWidth, paddleHeight);
    
    pongCtx.beginPath();
    pongCtx.arc(pongBall.x, pongBall.y, pongBall.size, 0, Math.PI * 2);
    pongCtx.fill();

    // Teken countdown als die bezig is
    if (pongCountdown > 0) {
        pongCtx.fillStyle = "white";
        pongCtx.font = "60px Arial";
        pongCtx.textAlign = "center";
        pongCtx.fillText(pongCountdown, pongCanvas.width/2, pongCanvas.height/2);
    }
}

// Luister naar tegenstander beweging
if (socket) {
    socket.on('opponentPaddleMove', (data) => {
        aiPaddle.y = data.y; // Update de rechter paddle met data van de ander
    });
}

function updatePongCursorState(isRunning) {
    const val = isRunning ? 'none' : 'default';
    document.body.style.cursor = val;
    document.getElementById('pongGame').style.cursor = val;
    // Header cursor: 'none' als we spelen, 'move' als we gepauzeerd zijn
    document.getElementById('pongHeader').style.cursor = isRunning ? 'none' : 'move';
    document.getElementById('pongCanvas').style.cursor = val;
}

function pongLoop() {
    if (document.getElementById('pongGame').style.display === 'none') return;

    if (!pongGameStarted) {
        // Startscherm tekenen
        drawPong();
        pongCtx.fillStyle = "rgba(0,0,0,0.5)";
        pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
        pongCtx.fillStyle = "white";
        pongCtx.font = "30px Arial";
        pongCtx.textAlign = "center";
        pongCtx.fillText("Druk op SPATIE om te starten", pongCanvas.width/2, pongCanvas.height/2);
    } else if (pongCountdown > 0) {
        // Tijdens countdown tekenen we alleen de game state (die tekent de cijfers)
        drawPong();
    } else if (isPongPaused) {
        // Pauze scherm
        drawPong();
        pongCtx.fillStyle = "rgba(0,0,0,0.5)";
        pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
        pongCtx.fillStyle = "white";
        pongCtx.font = "30px Arial";
        pongCtx.textAlign = "center";
        pongCtx.fillText(`Gepauzeerd door ${pongPauseInitiator}: ${pongPauseCountdown}`, pongCanvas.width/2, pongCanvas.height/2);
        pongCtx.font = "16px Arial";
        pongCtx.fillText("Klik op kruisje om te stoppen", pongCanvas.width/2, pongCanvas.height/2 + 30);
    } else if (pongRunning) {
        if (!isScoring) updatePong(); // Alleen updaten als we niet in score-pauze zitten
        drawPong();
    } else {
        // Als gepauzeerd: teken de game (statisch) en de overlay
        drawPong();
        pongCtx.fillStyle = "rgba(0,0,0,0.5)";
        pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);
        pongCtx.fillStyle = "white";
        pongCtx.font = "30px Arial";
        pongCtx.textAlign = "center";
        pongCtx.fillText("Gepauzeerd", pongCanvas.width/2, pongCanvas.height/2);
        pongCtx.font = "16px Arial";
        pongCtx.fillText("Druk op ESC om verder te gaan", pongCanvas.width/2, pongCanvas.height/2 + 30);
    }
    
    pongAnimationId = requestAnimationFrame(pongLoop);
}

// Chat
const chatInput = document.getElementById("chatInput");
let chatMessages = [];
let allRoomMessages = [];

const chatLog = document.getElementById("chatLog");
const openChatLogBtn = document.getElementById("openChatLog");

openChatLogBtn.addEventListener("click", () => {
    const img = openChatLogBtn.querySelector('img');
    if (chatLog.style.display === "block") {
        chatLog.style.display = "none";
        img.src = "icons/chat.png";
    } else {
        chatLog.style.display = "block";
        img.src = "icons/chat_active.png";
        chatLog.scrollTop = chatLog.scrollHeight; // naar beneden scrollen
    }
});


function sendChatMessage(text, user = "Jij") {
    if (socket) {
        socket.emit('chatMessage', text);
    } else {
        receiveChatMessage({ user: "Jij", text: text, id: 'local' });
    }
}

function receiveChatMessage(data) {
    const now = Date.now();
    const msg = {
        text: data.text,
        user: data.user,
        id: data.id,
        userId: data.userId,
        time: data.time || now, // Gebruik server tijd indien beschikbaar
        duration: 5000
    };
    chatMessages.push(msg);
    allRoomMessages.push(msg);
    updateChatLog();
}

if (socket) {
    socket.on('chatMessage', (data) => {
        receiveChatMessage(data);
    });
}

function updateChatLog() {
    const content = document.getElementById("chatLogContent");
    content.innerHTML = "";

    allRoomMessages.forEach(m => {
        const time = new Date(m.time).toLocaleTimeString("nl-NL", {
            hour: "2-digit",
            minute: "2-digit"
        });

        const line = document.createElement("div");
        line.style.marginBottom = "6px";
        line.style.wordBreak = "break-word";
        
        // NIEUW: Check op userId voor persistentie, fallback naar socket id
        const currentId = socket ? (socket.id || mySocketId) : null;
        const isLocal = (m.userId && m.userId === myUserId) || (!m.userId && ((currentId && m.id === currentId) || m.user === "Jij"));
        
        line.style.textAlign = isLocal ? "left" : "right";
        
        let displayText = m.text;
        // NIEUW: Styling voor acties (*...*)
        if (displayText.startsWith('*') && displayText.endsWith('*')) {
            displayText = `<span style="font-style: italic; color: #aaa;">${displayText}</span>`;
        }
        
        line.innerHTML = `<span style="color:#888">[${time}]</span> <b>${m.user}:</b> ${displayText}`;

        content.appendChild(line);
    });

    content.scrollTop = content.scrollHeight;

}

function findPath(start, end) {
    const openSet = [];
    const closedSet = new Set();
    const cameFrom = new Map();


    function nodeKey(n){ return `${n.x},${n.y}`; }

    const gScore = {};
    const fScore = {};

    gScore[nodeKey(start)] = 0;
    fScore[nodeKey(start)] = Math.abs(start.x - end.x) + Math.abs(start.y - end.y);

    openSet.push({ ...start, f: fScore[nodeKey(start)] });
    
    while(openSet.length > 0){
        // Kies node met laagste f
        openSet.sort((a,b)=>a.f-b.f);
        const current = openSet.shift();

        if(current.x === end.x && current.y === end.y){
            // Reconstruct path
            const path = [];
            let currKey = nodeKey(current);
            while(cameFrom.has(currKey)){
                path.push(cameFrom.get(currKey));
                currKey = nodeKey(cameFrom.get(currKey));
            }
            path.reverse();

            // Voeg het eindpunt zelf toe zodat de speler er echt naartoe gaat
            path.push({x: end.x, y: end.y});

            return path;
        }

        closedSet.add(nodeKey(current));

        // buren inclusief diagonalen
        const neighbors = [
            {x: current.x+1, y: current.y},
            {x: current.x-1, y: current.y},
            {x: current.x, y: current.y+1},
            {x: current.x, y: current.y-1},
            {x: current.x+1, y: current.y+1}, 
            {x: current.x+1, y: current.y-1},
            {x: current.x-1, y: current.y+1},
            {x: current.x-1, y: current.y-1}
        ].filter(n => n.x >=0 && n.x < mapW && n.y >=0 && n.y < mapH);

        for(let neighbor of neighbors){
            const nKey = nodeKey(neighbor);
            if(closedSet.has(nKey)) continue;
            if(isBlocked(neighbor.x, neighbor.y)) continue;

            const tentativeG = gScore[nodeKey(current)] + 1;

            if(!gScore.hasOwnProperty(nKey) || tentativeG < gScore[nKey]){
                cameFrom.set(nKey, {x: current.x, y: current.y});
                gScore[nKey] = tentativeG;
                fScore[nKey] = tentativeG + Math.abs(neighbor.x - end.x) + Math.abs(neighbor.y - end.y);
                if(!openSet.some(n => n.x===neighbor.x && n.y===neighbor.y)){
                    openSet.push({ ...neighbor, f: fScore[nKey] });
                }
            }
        }
    }

    // geen pad gevonden
    return [];
}



// Tile naar scherm
function toScreen(ix, iy) {
    const sx = (ix - iy) * tileW/2;
    const sy = (ix + iy) * tileH/2;
    return {sx, sy};
}

function toTile(mx, my){
    const cx = (mx - window.innerWidth/2 - camX)/scale;
    const cy = (my - window.innerHeight/4 - camY)/scale;

    const tyOffset = 1.5; // capsule is 1.5 tegel hoog
    const tx = (cx/tileW + cy/tileH);
    const ty = (cy/tileH - cx/tileW) - tyOffset + 1; // +1 zodat onderkant op tegel
    return {x: Math.floor(tx), y: Math.floor(ty)};
}

function toWorld(mx, my) {
    // Converteert schermcoÃ¶rdinaten (muis) naar wereldcoÃ¶rdinaten (isometrisch)
    const worldMouseX = (mx - window.innerWidth / 2 - camX) / scale;
    const worldMouseY = (my - window.innerHeight / 4 - camY) / scale;

    // Inverse transformatie van toScreen
    const isoX = worldMouseX / (tileW / 2);
    const isoY = worldMouseY / (tileH / 2);

    const worldX = (isoX + isoY) / 2;
    const worldY = (isoY - isoX) / 2;
    return { x: worldX, y: worldY };
}


function wrapText(text, maxWidth) {    
    const words = text.split(" ");
    const lines = [];
    let line = "";

    for (let word of words) {
        // Check of het woord zelf al te breed is
        if (ctx.measureText(word).width > maxWidth) {
            // Eerst de huidige regel opslaan
            if (line !== "") {
                lines.push(line);
                line = "";
            }

            // Breek het woord op
            let part = "";
            for (let char of word) {
                const test = part + char;
                if (ctx.measureText(test + "-").width > maxWidth) {
                    lines.push((part + "-").trim());
                    part = char;
                } else {
                    part = test;
                }
            }
            line = part; // Het resterende deel wordt de nieuwe regel
        } else {
            const testLine = line + word + " ";
            if (ctx.measureText(testLine).width > maxWidth) {
                // Voeg de vorige regel toe, maar alleen als deze niet leeg is
                if (line.trim() !== "") lines.push(line.trim());
                line = word + " ";
            } else {
                line = testLine;
            }
        }
    }

    // Voeg de allerlaatste regel toe, maar alleen als deze niet leeg is
    if (line.trim() !== "") lines.push(line.trim());
    return lines;
}



function drawTiles() {
    for (let y = 0; y < mapH; y++) {
        for (let x = 0; x < mapW; x++) {
            const { sx, sy } = toScreen(x, y);
            const tileKey = `${x},${y}`;
 
            // Basis tegel
            let fill = "#444";

            // Check of er een custom kleur is voor deze tegel (dit overschrijft de basiskleur)
            if (tileColors[tileKey]) {
                fill = tileColors[tileKey];
            }

            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fillStyle = fill;
            ctx.fill();

            if (showTileNumbers) {
                // Tile nummer tekenen
                ctx.save();
                ctx.imageSmoothingEnabled = true; // Maak tekst tijdelijk glad
                ctx.fillStyle = "white";
                ctx.font = "10px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                const tileNum = y * mapW + x; // nummer van 0 t/m mapW*mapH-1
                ctx.fillText(tileNum, sx, sy + tileH / 2);
                ctx.restore(); // Herstelt imageSmoothingEnabled naar de default (false)
            }
        }
    }

    // Teken het gehighlighte pad
    if (highlightedPath.length > 0) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)"; // Wit met meer zichtbaarheid
        highlightedPath.forEach(tile => {
            const { sx, sy } = toScreen(tile.x, tile.y);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fill();
        });
    }


    // Hover-effect voor de kwast
    if (isBuildMode && activeBuildCategory === 'kleur' && hoverTarget) {
        if (hoverTarget.type === 'tile') {
            const { sx, sy } = toScreen(hoverTarget.id.x, hoverTarget.id.y);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
            ctx.lineTo(sx, sy + tileH);
            ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
            ctx.closePath();
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill();
        } else if (hoverTarget.type === 'wall') {
            // Dit wordt afgehandeld in de drawWall functies
        }
    } else if (hoverCell && !isBuildMode && !isItemDragging && !isObjectDragging) { // Oude hover voor padvinden
        const { sx, sy } = toScreen(hoverCell.x, hoverCell.y);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + tileW / 2, sy + tileH / 2);
        ctx.lineTo(sx, sy + tileH);
        ctx.lineTo(sx - tileW / 2, sy + tileH / 2);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fill();
    }

    // Bouwmodus hover (plaatsen & verplaatsen)
    const activeObj = selectedBuildObject || movingObject;
    const isWallObject = activeObj && ((activeObj.placement === 'wall') || activeObj.wallId);

    if (isWallObject && hoverTarget?.type === 'wall') {
        // Preview voor muurobjecten
        const wallId = hoverTarget.id;
        const isValidPlacement = true;

        // Teken de preview direct in de juiste wall-draw functie
        // We voegen een tijdelijke vlag toe aan hoverTarget
        hoverTarget.preview = {
            color: isValidPlacement ? "rgba(0, 255, 0, 0.5)" : "rgba(255, 0, 0, 0.5)",
            image: activeObj.runtimeImage || wallItemImg,
            valid: isValidPlacement
        };
    } else if (hoverTarget?.preview) {
        // Reset de preview als we niet meer hoveren
        delete hoverTarget.preview;
    }

}




function drawCharacter(x, y, isLocal, color = "blue", hop = 0, isSmoking = false, smokingStartTime = 0, smokingItemType = 'sigaret', isDrinking = false, drinkingStartTime = 0, drinkingItemType = 'bottle_full') {
    const drawXPos = isLocal ? ball.x : x;
    const drawYPos = isLocal ? ball.y : y;
    const currentHop = isLocal ? hopOffset : hop;

    const {sx, sy} = toScreen(drawXPos, drawYPos); 

    const capsuleWidth = 32;
    const capsuleHeight = 48;
    const radius = capsuleWidth / 2;

    // Onderkant capsule = tegel midden
    const drawY = sy - currentHop - capsuleHeight;

    // Capsule speler
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(sx - capsuleWidth/2, drawY + radius);
    ctx.arcTo(sx - capsuleWidth/2, drawY + capsuleHeight, sx + capsuleWidth/2, drawY + capsuleHeight, radius);
    ctx.arcTo(sx + capsuleWidth/2, drawY + capsuleHeight, sx + capsuleWidth/2, drawY, radius);
    ctx.arcTo(sx + capsuleWidth/2, drawY, sx - capsuleWidth/2, drawY, radius);
    ctx.arcTo(sx - capsuleWidth/2, drawY, sx - capsuleWidth/2, drawY + capsuleHeight, radius);
    ctx.closePath();
    ctx.fill();

    // Hoed boven capsule
    const hatWidth = 32;
    const hatHeight = 16;
    const capsuleTop = drawY;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(sx, capsuleTop - hatHeight);
    ctx.lineTo(sx - hatWidth/2, capsuleTop);
    ctx.lineTo(sx + hatWidth/2, capsuleTop);
    ctx.closePath();
      ctx.fill();

    // NIEUW: Rook animatie
    if (isSmoking) {
        const mouthX = sx + 6;
        const mouthY = drawY + 14;
        
        // Bepaal welke sigaret we tekenen
        let cigImg = sigaretStickImg;
        
        if (smokingItemType === 'sigaret_half') {
            cigImg = sigaretHalfStickImg; // Direct de halve als we die roken
        } else {
            const elapsed = Date.now() - (smokingStartTime || Date.now());
            cigImg = (elapsed < 5000) ? sigaretStickImg : sigaretHalfStickImg; // Anders wissel na 5s
        }

        // Teken de sigaret in de mond, -90 graden gedraaid
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.translate(mouthX, mouthY);
        ctx.rotate(-Math.PI / 2); // -90 graden
        // Teken gecentreerd en met de bovenkant op het rotatiepunt
        const imgWidth = cigImg.width || 16;
        ctx.drawImage(cigImg, -imgWidth / 2, 0);
        ctx.restore();

        // Rookwolkjes
        const cigTipX = mouthX;
        const cigTipY = mouthY + (cigImg.width || 16); // Positie van het uiteinde

        ctx.save();
        // if (ctx.filter !== undefined) ctx.filter = 'blur(4px)'; // Blur uit voor grainy effect

        const numParticles = 25; // Meer deeltjes voor meer "ruis"
        for (let i = 0; i < numParticles; i++) {
            // Elke particle heeft zijn eigen cyclus en offset voor variatie
            const cycleDuration = 3000 + (i * 150); // Iets snellere cyclus voor meer chaos
            const offset = i * (cycleDuration / numParticles);
            const t = ((Date.now() + offset) % cycleDuration) / cycleDuration; // Levensduur van 0 tot 1

            if (t < 0.05) continue; // Niet tekenen direct bij het uiteinde

            // Ruis toevoegen (pseudo-random op basis van index i)
            const noiseFactor = Math.sin(i * 999); 
            const spread = noiseFactor * 15 * t; // Spreiding neemt toe naarmate rook stijgt

            const rise = t * 60; // Hoe ver de rook opstijgt
            const drift = Math.sin(t * Math.PI * 1.5) * 20; // Langzame S-curve voor de algemene richting
            const turbulence = (Math.sin(t * Math.PI * 8 + i)) * (1 - t) * 15; // Snellere turbulentie

            const px = cigTipX + drift + turbulence + spread;
            const py = cigTipY - rise;
            
            // Grootte groeit en krimpt dan weer voor een "puff" effect
            // Ruis in grootte
            const sizeNoise = Math.cos(i * 50) * 3;
            const size = Math.max(1, (Math.sin(t * Math.PI) * 12) + sizeNoise);
            const alpha = Math.max(0, 0.4 * (1 - t * t)); // Iets transparanter voor rokeriger effect
            
            ctx.fillStyle = `rgba(220, 220, 220, ${alpha})`;
            
            // Grainy effect: teken wolkje van losse pixels i.p.v. cirkel
            const grains = Math.max(1, size * 2); 
            for(let g=0; g<grains; g++){
                ctx.fillRect(px + (Math.random()-0.5)*size*2, py + (Math.random()-0.5)*size*2, 2, 2);
            }
        }
        ctx.restore();
    }

    // NIEUW: Drink animatie
    if (isDrinking) {
        const mouthX = sx + 10;
        const mouthY = drawY + 14;
        
        const elapsed = Date.now() - (drinkingStartTime || Date.now());

        let bottleImg = bottleFullImg;
        if (drinkingItemType === 'bottle_half') bottleImg = bottleHalfImg;
        else if (drinkingItemType === 'bottle_empty') bottleImg = bottleEmptyImg;
        else if (drinkingItemType === 'bottle_full' && elapsed > 2000) bottleImg = bottleHalfImg;

        // Fles kantelen naar mond
        const baseAngle = Math.PI * 0.7; // Schuine hoek
        const wobble = Math.sin(elapsed * 0.008) * 0.1; // Beetje beweging
        
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.translate(mouthX, mouthY);
        ctx.scale(-1, 1);
        ctx.rotate(baseAngle + wobble);
        
        const imgWidth = bottleImg.width || 16;
        const imgHeight = bottleImg.height || 32;
        
        ctx.drawImage(bottleImg, -imgWidth / 2, 0, imgWidth, imgHeight);
        ctx.restore();
    }
}

function drawBall() {
    drawCharacter(ball.x, ball.y, true, "blue", 0, isSmoking, ball.smokingStartTime, ball.smokingItemType, isDrinking, ball.drinkingStartTime, ball.drinkingItemType);
}

// Achterwand
function drawTopWall() {
    const wallHeight = 150;
    // Loop van achter naar voren voor correcte diepte
    for (let x = mapW - 1; x >= 0; x--) {
        const wallId = `top_${x}`;
        const topLeft = toScreen(x, 0);
        const topRight = toScreen(x + 1, 0);

        // Teken altijd eerst de basiskleur van de muur
        ctx.fillStyle = wallColors[wallId] || "#555";
        ctx.beginPath();
        ctx.moveTo(topLeft.sx, topLeft.sy - wallHeight);
        ctx.lineTo(topRight.sx, topRight.sy - wallHeight);
        ctx.lineTo(topRight.sx, topRight.sy);
        ctx.lineTo(topLeft.sx, topLeft.sy);
        ctx.closePath();
        ctx.fill();

        // Teken de highlight eroverheen als de muis erboven is
        if (hoverTarget && hoverTarget.type === 'wall' && hoverTarget.id === wallId) {
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill(); // Gebruik hetzelfde pad, dus vul opnieuw
        }

        // Teken een eventueel muurobject
        const objectsStartingOnWall = wallObjects.filter(wo => wo.wallId === wallId);
        objectsStartingOnWall.forEach(wallObject => {
            if (!wallObject.isFree) {
                // Grid-based tekening
                const width = wallObject.width || 1;
                const endSegmentX = x + width - 1;
                if (endSegmentX >= mapW) return; // Object gaat buiten de map

                const endTopRight = toScreen(endSegmentX + 1, 0);
                const objX = (topLeft.sx + endTopRight.sx) / 2;
                const objY = topLeft.sy;
                const img = wallObject.runtimeImage || (width > 1 ? wallItem2Img : wallItemImg);
                const yOffset = (width > 1) ? 32 : 16;

                ctx.save();
                if (isBuildMode && (buildTool === 'move' || buildTool === 'delete') && !movingObject && hoveredObjects[moveSelectionIndex] === wallObject) {
                    ctx.filter = buildTool === 'delete' ? "sepia(1) hue-rotate(-50deg) saturate(5)" : "brightness(1.5)";
                }

                if (wallObject.flipped) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -objX - img.width / 2, objY - img.height + yOffset);
                } else {
                    ctx.drawImage(img, objX - img.width / 2, objY - img.height + yOffset);
                }
                ctx.restore();
            }
        });

        // Teken de preview voor een nieuw muurobject
        const activeObj = movingObject || selectedBuildObject;
        const isWallObject = activeObj && ((activeObj.placement === 'wall') || activeObj.wallId);
        if (isWallObject && hoverTarget?.type === 'wall' && hoverTarget.id === wallId) {
            if (!activeObj.isFree) {
                // OUDE LOGICA
                const width = activeObj.width || 1;
                const endSegmentX = x + width - 1;
                if (endSegmentX >= mapW) return;

                const color = "rgba(0, 255, 0, 0.5)";
                const endTopRight = toScreen(endSegmentX + 1, 0);

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(topLeft.sx, topLeft.sy - wallHeight);
                ctx.lineTo(endTopRight.sx, endTopRight.sy - wallHeight);
                ctx.lineTo(endTopRight.sx, endTopRight.sy);
                ctx.lineTo(topLeft.sx, topLeft.sy);
                ctx.closePath();
                ctx.fill();

                const objX = (topLeft.sx + endTopRight.sx) / 2;
                const objY = topLeft.sy;
                const img = activeObj.runtimeImage || (width > 1 ? wallItem2Img : wallItemImg);
                const yOffset = (width > 1) ? 32 : 16;
                ctx.globalAlpha = 0.7;

                if (isBuildObjectFlipped) {
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -objX - img.width / 2, objY - img.height + yOffset);
                    ctx.restore();
                } else {
                    ctx.drawImage(img, objX - img.width / 2, objY - img.height + yOffset);
                }
                ctx.globalAlpha = 1;
            }
        }
    }
}

// Linkermuur
function drawLeftWall() {
    const wallHeight = 150;
    // Loop van achter naar voren
    for (let y = mapH - 1; y >= 0; y--) {
        const wallId = `left_${y}`;
        const leftTop = toScreen(0, y);
        const leftBottom = toScreen(0, y + 1);

        // Teken altijd eerst de basiskleur van de muur
        ctx.fillStyle = wallColors[wallId] || "#666";
        ctx.beginPath();
        ctx.moveTo(leftTop.sx, leftTop.sy - wallHeight);
        ctx.lineTo(leftBottom.sx, leftBottom.sy - wallHeight);
        ctx.lineTo(leftBottom.sx, leftBottom.sy);
        ctx.lineTo(leftTop.sx, leftTop.sy);
        ctx.closePath();
        ctx.fill();

        // Teken de highlight eroverheen als de muis erboven is
        if (hoverTarget && hoverTarget.type === 'wall' && hoverTarget.id === wallId) {
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fill(); // Gebruik hetzelfde pad, dus vul opnieuw
        }

        // Teken een eventueel muurobject
        const objectsStartingOnWall = wallObjects.filter(wo => wo.wallId === wallId);
        objectsStartingOnWall.forEach(wallObject => {
            if (!wallObject.isFree) {
                // Grid-based tekening
                const width = wallObject.width || 1;
                const endSegmentY = y + width - 1;
                if (endSegmentY >= mapH) return;

                const endLeftBottom = toScreen(0, endSegmentY + 1);
                const objX = (leftTop.sx + endLeftBottom.sx) / 2;
                const objY = leftTop.sy;
                const img = wallObject.runtimeImage || (width > 1 ? wallItem2Img : wallItemImg);
                const yOffset = (width > 1) ? 32 : 16;

                const drawY = leftTop.sy;
                ctx.save();
                if (isBuildMode && (buildTool === 'move' || buildTool === 'delete') && !movingObject && hoveredObjects[moveSelectionIndex] === wallObject) {
                    ctx.filter = buildTool === 'delete' ? "sepia(1) hue-rotate(-50deg) saturate(5)" : "brightness(1.5)";
                }

                if (wallObject.flipped) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -objX - img.width / 2, drawY - img.height + yOffset);
                } else {
                    ctx.drawImage(img, objX - img.width / 2, drawY - img.height + yOffset);
                }
                ctx.restore();
            }
        });

        // Teken de preview voor een nieuw muurobject
        const activeObj = movingObject || selectedBuildObject;
        const isWallObject = activeObj && ((activeObj.placement === 'wall') || activeObj.wallId);
        if (isWallObject && hoverTarget?.type === 'wall' && hoverTarget.id === wallId) {
            if (!activeObj.isFree) {
                // OUDE LOGICA
                const width = activeObj.width || 1;
                const endSegmentY = y + width - 1;
                if (endSegmentY >= mapH) return;

                const color = "rgba(0, 255, 0, 0.5)";
                const endLeftBottom = toScreen(0, endSegmentY + 1);

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(leftTop.sx, leftTop.sy - wallHeight);
                ctx.lineTo(endLeftBottom.sx, endLeftBottom.sy - wallHeight);
                ctx.lineTo(endLeftBottom.sx, endLeftBottom.sy);
                ctx.lineTo(leftTop.sx, leftTop.sy);
                ctx.closePath();
                ctx.fill();

                const objX = (leftTop.sx + endLeftBottom.sx) / 2;
                const objY = leftTop.sy;
                const img = activeObj.runtimeImage || (width > 1 ? wallItem2Img : wallItemImg);
                const yOffset = (width > 1) ? 32 : 16;
                ctx.globalAlpha = 0.7;
                if (isBuildObjectFlipped) {
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -objX - img.width / 2, objY - img.height + yOffset);
                    ctx.restore();
                } else {
                    ctx.drawImage(img, objX - img.width / 2, objY - img.height + yOffset);
                }
                ctx.globalAlpha = 1;
            }
        }
    }
}

function drawFreeWallObjects() {
    // 1. Geplaatste vrije objecten
    const freeObjects = wallObjects.filter(wo => wo.isFree);

    freeObjects.forEach(wallObject => {
        const objX = wallObject.freeX;
        const objY = wallObject.freeY;
        const img = wallObject.runtimeImage || (wallObject.width === 2 ? wallFree2Img : wallFreeImg);

        ctx.save();
        // Highlight logic
        if (isBuildMode && (buildTool === 'move' || buildTool === 'delete') && !movingObject && hoveredObjects[moveSelectionIndex] === wallObject) {
            ctx.filter = buildTool === 'delete' ? "sepia(1) hue-rotate(-50deg) saturate(5)" : "brightness(1.5)";
        }

        if (wallObject.flipped) {
            ctx.scale(-1, 1);
            ctx.drawImage(img, -objX - img.width / 2, objY - img.height + 40);
        } else {
            ctx.drawImage(img, objX - img.width / 2, objY - img.height + 40);
        }
        ctx.restore();
    });

    // 2. Preview voor vrije objecten
    const activeObj = movingObject || selectedBuildObject;
    const isWallObject = activeObj && ((activeObj.placement === 'wall') || activeObj.wallId);
    
    if (isWallObject && activeObj.isFree && hoverTarget?.type === 'wall') {
         const img = activeObj.runtimeImage || (activeObj.width === 2 ? wallFree2Img : wallFreeImg);
         ctx.globalAlpha = 0.7;
         if (isBuildObjectFlipped) {
             ctx.save();
             ctx.scale(-1, 1);
             ctx.drawImage(img, -mouseWorldX - img.width / 2, mouseWorldY - img.height + 40);
             ctx.restore();
         } else {
             ctx.drawImage(img, mouseWorldX - img.width / 2, mouseWorldY - img.height + 40);
         }
         ctx.globalAlpha = 1;
    }
}

let lastTypingTime = 0;
const typingFadeStart = 3000;  // 3 seconden wachten na laatste type
const typingFadeDuration = 1000; // fade tijd 1 seconde

function getActiveBalloonCount() {
    const now = Date.now();
    const currentId = socket ? (socket.id || mySocketId) : 'local';
    return chatMessages.filter(m => {
        const isMe = (m.userId && m.userId === myUserId) || (!m.userId && (m.id === currentId || m.id === 'local'));
        return isMe && (now - m.time < m.duration);
    }).length;
}


chatInput.addEventListener("input", () => {
    const activeCount = getActiveBalloonCount();

    // âŒ blokkeren bij 5 ballonnen
    if (activeCount >= 5) {
    chatInput.value = "";
    chatInput.disabled = true;
    chatInput.placeholder = "Even wachten...";
    charCounter.textContent = `0 / ${MAX_CHARS}`;
    return;
}


    // âœ… weer mogen typen
    chatInput.disabled = false;
    chatInput.placeholder = "Typ hier je bericht...";
    chatInput.style.color = "#000";

    lastTypingTime = Date.now();

    if (chatInput.value.length > MAX_CHARS) {
        chatInput.value = chatInput.value.slice(0, MAX_CHARS);
    }

    // Update char counter
    charCounter.textContent = `${chatInput.value.length} / ${MAX_CHARS}`;
    charCounter.style.color = chatInput.value.length >= MAX_CHARS ? "#ff4d4d" : "#aaa";
});

// Zorg dat het canvas meeschaalt met het venster
window.addEventListener('resize', () => {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.imageSmoothingEnabled = false; // Opnieuw instellen na resize
});



window.addEventListener("keydown", (e) => {
    const active = document.activeElement;

    // Pong pauze toggle met ESC
    if (e.key === "Escape") {
        if (document.getElementById('pongGame').style.display === 'flex') {
            if (!isPongAI && socket && currentPongOpponentId) {
                // PvP: Vraag server om pauze
                socket.emit('requestPongPause', { opponentId: currentPongOpponentId });
            } else {
                // AI: Lokale pauze
                initiatePongPause("Jij");
            }
            return; // Stop verdere ESC afhandeling
        }
        
        // Cancel bouwacties
        if (isBuildMode) {
            if (selectedBuildObject) {
                selectedBuildObject = null;
                const selectedItem = document.querySelector('.build-item.selected');
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    isBuildObjectFlipped = false;
                }
            }
            if (movingObject) {
                objects.push(movingObject); // Zet het object terug
                movingObject = null;
                movePreview.style.display = 'none';
            }
        }

        // Cancel item dragging
        if (isItemDragging && draggedItem) {
            if (dragImageElement) {
                dragImageElement.remove();
                dragImageElement = null;
            }
            
            if (isDraggingFromInventory) {
                inventoryItems.push(draggedItem);
                renderInventoryItems();
            } else if (isDraggingFromShop) {
                shopOutputItems.push(draggedItem);
                renderShopOutput();
            } else {
                if (draggedItemOriginalPos) {
                    draggedItem.x = draggedItemOriginalPos.x;
                    draggedItem.y = draggedItemOriginalPos.y;
                    items.push(draggedItem); // Zet item terug
                }
            }
            isItemDragging = false;
            isDraggingFromInventory = false;
            isDraggingFromShop = false;
            isDraggingFromVicinity = false;
            draggedItem = null;
            draggedItemOriginalPos = null;
            
            // Heropen de vensters die open stonden
            if (windowStatesBeforeDrag) {
                if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
                if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
                if (windowStatesBeforeDrag.vicinity) document.getElementById('vicinityWindow').style.display = windowStatesBeforeDrag.vicinity;
                if (windowStatesBeforeDrag.build === 'flex') {
                    buildBtn.click();
                }
                if (windowStatesBeforeDrag.shop === 'flex') {
                    document.getElementById('shopWindow').style.display = 'flex';
                }
            if (windowStatesBeforeDrag.container === 'flex') {
                document.getElementById('containerWindow').style.display = 'flex';
            }
                windowStatesBeforeDrag = null;
            }
        }

        // Cancel object dragging (moveable objects)
        if (isObjectDragging && draggedObject) {
             draggedObject.x = draggedObjectOriginalPos.x;
             draggedObject.y = draggedObjectOriginalPos.y;
             objects.push(draggedObject);
             draggedObject = null;
             draggedObjectOriginalPos = null;
             isObjectDragging = false;
             movePreview.style.display = 'none';
             
             if (camOriginalPos) {
                camTargetX = camOriginalPos.x;
                camTargetY = camOriginalPos.y;
                camSmooth = true;
                camOriginalPos = null;
            }

            if (windowStatesBeforeDrag) {
                if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
                if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
                if (windowStatesBeforeDrag.vicinity) document.getElementById('vicinityWindow').style.display = windowStatesBeforeDrag.vicinity;
                if (windowStatesBeforeDrag.build === 'flex') {
                     if (!isBuildMode) buildBtn.click();
                }
                if (windowStatesBeforeDrag.shop === 'flex') {
                    document.getElementById('shopWindow').style.display = 'flex';
                }
                if (windowStatesBeforeDrag.pouch === 'flex') {
                    document.getElementById('pouchWindow').style.display = 'flex';
                }
                if (windowStatesBeforeDrag.container === 'flex') {
                    document.getElementById('containerWindow').style.display = 'flex';
                }
                windowStatesBeforeDrag = null;
            }
        }
    }

    // Selectie in verplaats-menu met pijltjestoetsen
    if (isBuildMode && (buildTool === 'move' || buildTool === 'delete') && !movingObject && hoveredObjects.length > 1) {
        if (e.key === 'ArrowUp') {
            moveSelectionIndex = (moveSelectionIndex - 1 + hoveredObjects.length) % hoveredObjects.length;
            updateMovePreviewContent();
            e.preventDefault();
            return;
        } else if (e.key === 'ArrowDown') {
            moveSelectionIndex = (moveSelectionIndex + 1) % hoveredObjects.length;
            updateMovePreviewContent();
            e.preventDefault();
            return;
        }
    }

    // Pong start met Spatie
    if (e.code === "Space") {
        if (document.getElementById('pongGame').style.display === 'flex' && !pongGameStarted) {
            pongGameStarted = true;
            pongRunning = true;
            e.preventDefault(); // Voorkom typen in chat
            return;
        }
    }

    // Als we in bouwmodus zijn, handel alleen de rotatie af.
    if (isBuildMode && activeBuildCategory === 'objecten' && (selectedBuildObject || movingObject)) {
        if (e.key.toLowerCase() === 'r') {
            isBuildObjectFlipped = !isBuildObjectFlipped;
            // Als we een object verplaatsen, update ook de 'flipped' state van dat object direct.
            if (movingObject) {
                movingObject.flipped = isBuildObjectFlipped;
            }
        }
        return; // Stop verdere keyboard-logica in bouwmodus
    }

    // Als we een moveable object aan het slepen zijn (buiten bouwmodus)
    if (isObjectDragging && draggedObject) {
        if (e.key.toLowerCase() === 'r') {
            draggedObject.flipped = !draggedObject.flipped;
            e.preventDefault(); // Voorkom dat 'r' in de chat komt
        }
        return; // Stop verdere afhandeling (geen chat focus)
    }

    // âŒ Geen bouwmodus: focus de chat, maar sluit speciale toetsen uit
    if (
        active !== chatInput &&
        active.tagName !== "INPUT" &&
        active.id !== "customObjectName" &&
        active.tagName !== "TEXTAREA" &&
        !["Shift", "Control", "Alt", "Meta", "Enter"].includes(e.key)
    ) {
        chatInput.focus();
    }

    // Enter = bericht versturen
    if (active === chatInput && e.key === "Enter") {
        if (chatInput.value.trim() !== "") {
            sendChatMessage(chatInput.value.trim());
            chatInput.value = "";
            charCounter.textContent = `0 / ${MAX_CHARS}`;
            charCounter.style.color = "#aaa";
        }
        e.preventDefault();
    }
});

function initiatePongPause(name) {
    if (isPongPaused) return; // Al gepauzeerd
    
    isPongPaused = true;
    pongPauseInitiator = name;
    pongPauseCountdown = 5;
    updatePongCursorState(false); // Cursor zichtbaar maken
    
    if (pongPauseInterval) clearInterval(pongPauseInterval);
    pongPauseInterval = setInterval(() => {
        pongPauseCountdown--;
        if (pongPauseCountdown <= 0) {
            // Hervat spel
            clearInterval(pongPauseInterval);
            isPongPaused = false;
            updatePongCursorState(true); // Cursor verbergen
        }
    }, 1000);
}


function drawChatBallon() {
    const now = Date.now();

    const paddingX = 16;
    const paddingY = 12;
    const maxWidth = 200;
    const minWidth = 60;
    const lineHeight = 18;
    const gap = 18;
    const fadeTime = 1000;
    const offsetAbovePlayer = 96;

    // Helper om positie te bepalen
    function getPlayerPosition(id) {
        // Als het bericht van onszelf is (of id is 'local'/'undefined' in singleplayer)
        if (!id || (socket && id === socket.id) || id === 'local') {
            return { x: ball.x, y: ball.y, hop: hopOffset };
        }
        // Als het van een andere speler is
        if (otherPlayers[id]) {
            return { x: otherPlayers[id].x, y: otherPlayers[id].y, hop: 0 };
        }
        return null;
    }

    // Groepeer berichten per speler ID
    const messagesByPlayer = {};

    // 1. Bestaande berichten
    chatMessages.forEach(m => {
        if (now - m.time < m.duration) {
            const id = m.id || 'local';
            if (!messagesByPlayer[id]) messagesByPlayer[id] = [];
            messagesByPlayer[id].push(m);
        }
    });

    // 2. Typing indicator (alleen voor onszelf)
    const timeSinceLastType = now - lastTypingTime;
    const typingActive =
    lastTypingTime > 0 &&
    chatInput.value.length > 0 &&
    timeSinceLastType < typingFadeStart + typingFadeDuration;

    if (typingActive) {
        const myId = socket ? socket.id : 'local';
        if (!messagesByPlayer[myId]) messagesByPlayer[myId] = [];
        messagesByPlayer[myId].push({
            text: "...",
            isTyping: true,
            time: lastTypingTime,
            id: myId
        });
    }

    // 3. Teken loop per speler
    ctx.save();
    ctx.imageSmoothingEnabled = true; // Maak de tekstballon en tekst glad (UI element)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Schaal UI mee met DPI
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    Object.keys(messagesByPlayer).forEach(playerId => {
        const pos = getPlayerPosition(playerId);
        if (!pos) return;

        const stack = messagesByPlayer[playerId];
        const world = toScreen(pos.x, pos.y);
        const screenX = world.sx * scale + window.innerWidth / 2 + camX;
        const screenY = world.sy * scale + window.innerHeight / 4 + camY - pos.hop * scale;

        // Bereken offsets
        let totalOffset = 0;
        const balloonData = [];

        // Van nieuw naar oud (stacken)
        for (let i = stack.length - 1; i >= 0; i--) {
            const m = stack[i];
            const lines = wrapText(m.text, maxWidth - paddingX * 2);
            const height = lines.length * lineHeight + paddingY * 2;
            
            balloonData.push({
                msg: m,
                lines: lines,
                height: height,
                offset: totalOffset
            });
            
            totalOffset += height + gap;
        }

        // Teken de ballonnen
        balloonData.forEach(data => {
            const { msg, lines, height, offset } = data;
            
            // Alpha berekening
            let alpha = 1;
            if (!msg.isTyping) {
                const age = now - msg.time;
                if (age > msg.duration - fadeTime) {
                    alpha = 1 - (age - (msg.duration - fadeTime)) / fadeTime;
                }
            } else {
                if (timeSinceLastType > typingFadeStart) {
                    alpha = 1 - (timeSinceLastType - typingFadeStart) / typingFadeDuration;
                }
            }

            const textWidth = Math.max(...lines.map(l => ctx.measureText(l).width));
            const width = Math.max(minWidth, Math.min(maxWidth, textWidth + paddingX * 2));
            const targetY = screenY - offsetAbovePlayer - offset - height;
            const r = lines.length === 1 ? height / 2 : 14;

            ctx.globalAlpha = alpha;

            // Teken ballon vorm
            ctx.beginPath();
            ctx.moveTo(screenX - width / 2 + r, targetY);
            ctx.lineTo(screenX + width / 2 - r, targetY);
            ctx.quadraticCurveTo(screenX + width / 2, targetY, screenX + width / 2, targetY + r);
            ctx.lineTo(screenX + width / 2, targetY + height - r);
            ctx.quadraticCurveTo(screenX + width / 2, targetY + height, screenX + width / 2 - r, targetY + height);
            ctx.lineTo(screenX - width / 2 + r, targetY + height);
            ctx.quadraticCurveTo(screenX - width / 2, targetY + height, screenX - width / 2, targetY + height - r);
            ctx.lineTo(screenX - width / 2, targetY + r);
            ctx.quadraticCurveTo(screenX - width / 2, targetY, screenX - width / 2 + r, targetY);
            ctx.closePath();

            ctx.fillStyle = "white";
            ctx.fill();

            // NIEUW: Styling voor acties (*...*) in de ballon
            const isAction = typeof msg.text === 'string' && msg.text.trim().startsWith('*') && msg.text.trim().endsWith('*');
            if (isAction) {
                ctx.font = "italic 14px Arial";
                ctx.fillStyle = "#666";
            } else {
                ctx.font = "14px Arial";
                ctx.fillStyle = "black";
            }

            // Teken tekst
            lines.forEach((line, i) => {
                ctx.fillText(line, screenX, targetY + paddingY + lineHeight / 2 + i * lineHeight);
            });

            ctx.globalAlpha = 1;
        });
    });

    ctx.restore();
}

function drawPlayerNames() {
    const playersToDraw = [];
    // Voeg lokale speler toe
    playersToDraw.push({
        x: ball.x,
        y: ball.y,
        hop: hopOffset,
        name: myName,
        id: 'local'
    });
    
    // Voeg andere spelers toe
    Object.values(otherPlayers).forEach(p => {
        playersToDraw.push({
            x: p.x,
            y: p.y,
            hop: p.hopOffset || 0,
            name: p.name,
            id: p.id
        });
    });

    ctx.save();
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // UI coÃ¶rdinaten (niet meeschalen met zoom voor tekstgrootte, wel positie)
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    
    const now = Date.now();
    const fadeDuration = 2000; // 2 seconden fade-out

    playersToDraw.forEach(p => {
        // Initialiseer state als die er nog niet is
        if (!nameHoverStates[p.id]) {
            nameHoverStates[p.id] = { opacity: 0, lastHover: 0 };
        }
        const state = nameHoverStates[p.id];

        const world = toScreen(p.x, p.y);
        const screenX = world.sx * scale + window.innerWidth / 2 + camX;
        const screenY = world.sy * scale + window.innerHeight / 4 + camY - p.hop * scale;
        
        // Hitbox berekening (ongeveer de grootte van de speler)
        const charHeight = 48 * scale;
        const charWidth = 32 * scale;
        
        // Check hover
        const isHovering = (mousePos.x >= screenX - charWidth/2 && mousePos.x <= screenX + charWidth/2 &&
            mousePos.y >= screenY - charHeight && mousePos.y <= screenY);

        if (isHovering) {
            state.opacity = 1;
            state.lastHover = now;
        } else {
            // Fade out logica
            const timeSinceHover = now - state.lastHover;
            if (timeSinceHover < fadeDuration) {
                state.opacity = 1 - (timeSinceHover / fadeDuration);
            } else {
                state.opacity = 0;
            }
        }

        if (state.opacity > 0) {
            const textWidth = ctx.measureText(p.name).width;
            const padding = 4;
            const tagY = screenY - charHeight - 5; // Iets boven het hoofd

            ctx.globalAlpha = state.opacity;
            
            // Achtergrondje
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(screenX - textWidth / 2 - padding, tagY - 14 - padding, textWidth + padding * 2, 14 + padding * 2);
            
            // Tekst
            ctx.fillStyle = "white";
            ctx.fillText(p.name, screenX, tagY);
            
            ctx.globalAlpha = 1.0; // Reset alpha
        }
    });

    ctx.restore();
}

function drawInteractionPrompts() {
    activeInteractionButton = null; // Reset elke frame
    const playerX = Math.floor(ball.x);
    const playerY = Math.floor(ball.y);

    objects.forEach(obj => {
        // Check op functionaliteit via subCategory of interactionType (met fallback naar naam voor oude objecten)
        const isPong = obj.interactionType === 'pong' || obj.name === "Pong";
        const isShop = obj.subCategory === 'shop' || obj.name === "Winkel";
        const isContainer = obj.subCategory === 'containers' || obj.name.includes("Container");
        const isTrash = obj.subCategory === 'trash' || obj.name.includes("Prullenbak");

        if (isPong || isShop || isContainer || isTrash) {
            const isFlipped = obj.flipped;
            const w = isFlipped ? (obj.depth || 1) : (obj.width || 1); // Pong=2x1, Winkel=1x1 (maar hoog)
            const d = isFlipped ? (obj.width || 1) : (obj.depth || 1);

            let spots = [];
            
            if (isShop) {
                if (obj.width >= 2 || obj.depth >= 2) {
                    // Brede winkel: interactie aan de voorkant (zoals brede container)
                    if (isFlipped) {
                        // Verticale oriÃ«ntatie -> Interactie rechts (x+w)
                        for (let i = 0; i < d; i++) {
                            spots.push({x: obj.x + w, y: obj.y + i});
                        }
                    } else {
                        // Horizontale oriÃ«ntatie -> Interactie onder (y+d)
                        for (let i = 0; i < w; i++) {
                            spots.push({x: obj.x + i, y: obj.y + d});
                        }
                    }
                } else {
                    // Standaard Winkel heeft maar 1 interactiekant (voorkant)
                    if (isFlipped) {
                        spots.push({x: obj.x, y: obj.y + 1}); // Links-onder (y+1)
                    } else {
                        spots.push({x: obj.x + 1, y: obj.y}); // Rechts-onder (x+1)
                    }
                }
            } else if (isContainer || isTrash) {
                if (obj.width >= 2) { // Brede varianten (check op basis eigenschap width)
                    // Speciale logica voor de brede container: interactie aan de 'voorkant' (onder/rechts)
                    if (isFlipped) {
                        // Verticale oriÃ«ntatie -> Interactie rechts (x+w)
                        for (let i = 0; i < d; i++) {
                            spots.push({x: obj.x + w, y: obj.y + i});
                        }
                    } else {
                        // Horizontale oriÃ«ntatie -> Interactie onder (y+d)
                        for (let i = 0; i < w; i++) {
                            spots.push({x: obj.x + i, y: obj.y + d});
                        }
                    }
                } else {
                    // Standaard logica voor andere containers (zoals het was)
                    if (isFlipped) {
                        spots.push({x: obj.x, y: obj.y + 1}); // Onder
                    } else {
                        spots.push({x: obj.x + 1, y: obj.y}); // Rechts
                    }
                }
            } else {
                // Pong heeft 2 kanten
                if (isFlipped) {
                    // Verticaal: plekken boven en onder
                    spots.push({x: obj.x, y: obj.y - 1});
                    spots.push({x: obj.x, y: obj.y + d});
                } else {
                    // Horizontaal: plekken links en rechts
                    spots.push({x: obj.x - 1, y: obj.y});
                    spots.push({x: obj.x + w, y: obj.y});
                }
            }

            const isPlayerOnSpot = spots.some(s => s.x === playerX && s.y === playerY);

            if (isPlayerOnSpot) {
                // Teken prompt
                const { sx, sy } = toScreen(ball.x, ball.y);
                const drawX = sx * scale + window.innerWidth / 2 + camX;
                const drawY = (sy - 80) * scale + window.innerHeight / 4 + camY - hopOffset * scale; // Boven speler

                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Reset transform voor UI, schaal mee met DPR
                
                // Teken pong prompt
                let promptImg = pongPromptImg;
                if (isShop) {
                    promptImg = shopPromptImg;
                } else if (isTrash) {
                    promptImg = trashPromptImg;
                } else if (isContainer) {
                    promptImg = containerPromptImg;
                }
                const imgW = promptImg.width || 32;
                const imgH = promptImg.height || 32;
                
                const time = Date.now();
                
                if (isContainer || isTrash) {
                    // Animatie: zacht sprongetje (bounce)
                    const bounce = Math.abs(Math.sin(time / 300)) * 8; // Springt 8px omhoog
                    ctx.translate(drawX, drawY - bounce);
                } else {
                    // Animatie: zachtjes wiebelen (rotatie)
                    const angle = Math.sin(time / 200) * 0.2; // +/- 0.2 radialen
                    ctx.translate(drawX, drawY); // Verplaats naar midden van prompt
                    ctx.rotate(angle);
                }
                
                // Schaduw voor betere zichtbaarheid
                ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.drawImage(promptImg, -imgW / 2, -imgH / 2);
                
                // Sla op voor click detectie
                activeInteractionButton = { x: drawX - imgW/2, y: drawY - imgH/2, w: imgW, h: imgH, obj: obj };

                ctx.restore();
            }
        }
    });
}

// NIEUW: Preview menu voor verplaatsen van objecten
const movePreview = document.getElementById('movePreview');
const movePreviewImg = document.getElementById('movePreviewImg');
const movePreviewName = document.getElementById('movePreviewName');
const movePreviewCount = document.getElementById('movePreviewCount');

let hoveredObjects = [];
let moveSelectionIndex = 0;
let lastHoveredTileKey = "";

function getObjectImageSrc(obj) {
    if (obj.runtimeImage) return obj.runtimeImage.src;
    if (obj.image && typeof obj.image === 'string') return obj.image;
    if (obj.image && obj.image.src) return obj.image.src; // Voor items
    
    if (obj.name === "Pong") return "objects/pong.png";
    if (obj.name === "Winkel") return "winkel_template_96.png";
    if (obj.name === "Brede Winkel") return "winkel_template_96_B.png";
    if (obj.name === "Container") return "container_template.png";
    if (obj.name === "Grote Container") return "container_template_96.png";
    if (obj.name === "Brede Container") return "container_template_96_B.png";
    if (obj.name === "Prullenbak") return "trash_template.png";
    if (obj.name === "Brede Prullenbak") return "trash_template_96_B.png";
    if (obj.isFloor) return "floor_template.png";
    
    const isWide = obj.width === 2;
    const isTall = obj.height === 2;
    
    if (obj.moveable) {
        return isWide ? "object_moveable_template_96_B.png" : "object_moveable_template.png";
    }
    
    if (isWide) return "object_template_96_B.png";
    if (isTall) return "object_template_96.png";
    return "object_template.png";
}

function updateMovePreviewContent() {
    const objectToPreview = hoveredObjects[moveSelectionIndex];
    
    if (objectToPreview) {
        movePreview.style.display = 'flex';
        
        if (movePreviewName.textContent !== objectToPreview.name) {
             movePreviewName.textContent = objectToPreview.name;
             movePreviewImg.src = getObjectImageSrc(objectToPreview);
        }

        // Update de actie tekst (Verplaatsen of Verwijderen)
        const actionText = document.getElementById('movePreviewActionText');
        if (actionText) {
            actionText.textContent = buildTool === 'delete' ? 'Verwijderen' : 'Verplaatsen';
            actionText.style.color = buildTool === 'delete' ? '#ff6666' : '#ccc';
        }

        const priceText = document.getElementById('movePreviewPrice');
        if (priceText) {
            priceText.style.display = 'none';
        }
        
        if (hoveredObjects.length > 1) {
            movePreviewCount.style.display = 'block';
            movePreviewCount.textContent = `${moveSelectionIndex + 1}/${hoveredObjects.length} â†•`;
        } else {
            movePreviewCount.style.display = 'none';
        }
    } else {
        movePreview.style.display = 'none';
        movePreviewName.textContent = '';
    }
}

window.addEventListener('mousemove', (e) => {
    // Toon de preview alleen als de 'verplaats' tool actief is, we over een object hoveren,
    // en we niet al een object aan het verplaatsen zijn.
    if (isBuildMode && (buildTool === 'move' || buildTool === 'delete') && !movingObject) {
        const x = hoverCell ? hoverCell.x : -1;
        const y = hoverCell ? hoverCell.y : -1;
        
        let tileKey = "";
        if (hoverTarget && hoverTarget.type === 'wall') {
            tileKey = hoverTarget.id;
        } else if (hoverCell) {
            tileKey = `${x},${y}`;
        }

        if (tileKey !== lastHoveredTileKey) {
            const objectsOnTile = hoverCell ? objects.filter(o => {
                const w = o.flipped ? (o.depth || 1) : (o.width || 1);
                const d = o.flipped ? (o.width || 1) : (o.depth || 1);
                return x >= o.x && x < o.x + w && y >= o.y && y < o.y + d;
            }) : [];
            const itemsOnTile = hoverCell ? items.filter(i => Math.floor(i.x) === x && Math.floor(i.y) === y) : [];
            
            let wallObjs = [];
            if (hoverTarget && hoverTarget.type === 'wall') {
                const currentWallSide = hoverTarget.id.split('_')[0];

                wallObjs = wallObjects.filter(o => {
                    if (o.isFree) {
                        if (o.wallSide !== currentWallSide) return false;

                        const img = o.runtimeImage || (o.width === 2 ? wallFree2Img : wallFreeImg);
                        if (!img || !img.width) return false;

                        const w = img.width;
                        const h = img.height;
                        const x1 = o.freeX - w / 2;
                        const y1 = o.freeY - h + 40;
                        
                        return (mouseWorldX >= x1 && mouseWorldX < x1 + w && mouseWorldY >= y1 && mouseWorldY < y1 + h);
                    } else {
                        if (o.wallId === hoverTarget.id) return true;
                        const width = o.width || 1;
                        if (width > 1) {
                            const [hType, hIndex] = hoverTarget.id.split('_');
                            const [oType, oIndex] = o.wallId.split('_');
                            if (hType === oType) {
                                const hIdx = parseInt(hIndex);
                                const oIdx = parseInt(oIndex);
                                return hIdx >= oIdx && hIdx < oIdx + width;
                            }
                        }
                        return false;
                    }
                });
            }
            
            hoveredObjects = [...objectsOnTile, ...itemsOnTile, ...wallObjs];
            
            // Sorteer: Meubels eerst, dan vloeren
            hoveredObjects.sort((a, b) => {
                const isItemA = items.includes(a);
                const isItemB = items.includes(b);
                if (isItemA && !isItemB) return -1; // Items eerst
                if (!isItemA && isItemB) return 1;
                if (a.isFloor && !b.isFloor) return 1;
                if (!a.isFloor && b.isFloor) return -1;
                return 0;
            });

            moveSelectionIndex = 0;
            lastHoveredTileKey = tileKey;
        } else {
            // Check of objecten veranderd zijn (bijv. verwijderd)
            const currentObjects = hoverCell ? objects.filter(o => {
                const w = o.flipped ? (o.depth || 1) : (o.width || 1);
                const d = o.flipped ? (o.width || 1) : (o.depth || 1);
                return x >= o.x && x < o.x + w && y >= o.y && y < o.y + d;
            }) : [];
            const currentItems = hoverCell ? items.filter(i => Math.floor(i.x) === x && Math.floor(i.y) === y) : [];
            
            let currentWallObjs = [];
            if (hoverTarget && hoverTarget.type === 'wall') {
                const currentWallSide = hoverTarget.id.split('_')[0];
                currentWallObjs = wallObjects.filter(o => {
                    if (o.isFree) {
                        if (o.wallSide !== currentWallSide) return false;
                        const img = o.runtimeImage || (o.width === 2 ? wallFree2Img : wallFreeImg);
                        if (!img || !img.width) return false;
                        const w = img.width;
                        const h = img.height;
                        const x1 = o.freeX - w / 2;
                        const y1 = o.freeY - h + 40;
                        return (mouseWorldX >= x1 && mouseWorldX < x1 + w && mouseWorldY >= y1 && mouseWorldY < y1 + h);
                    } else {
                        if (o.wallId === hoverTarget.id) return true;
                        const width = o.width || 1;
                        if (width > 1) {
                            const [hType, hIndex] = hoverTarget.id.split('_');
                            const [oType, oIndex] = o.wallId.split('_');
                            if (hType === oType) {
                                const hIdx = parseInt(hIndex);
                                const oIdx = parseInt(oIndex);
                                return hIdx >= oIdx && hIdx < oIdx + width;
                            }
                        }
                        return false;
                    }
                });
            }
            
            if (currentObjects.length + currentItems.length + currentWallObjs.length !== hoveredObjects.length) {
                 hoveredObjects = [...currentObjects, ...currentItems, ...currentWallObjs];
                 hoveredObjects.sort((a, b) => {
                    const isItemA = items.includes(a);
                    const isItemB = items.includes(b);
                    if (isItemA && !isItemB) return -1;
                    if (!isItemA && isItemB) return 1;
                    if (a.isFloor && !b.isFloor) return 1;
                    if (!a.isFloor && b.isFloor) return -1;
                    return 0;
                });
                 if (moveSelectionIndex >= hoveredObjects.length) moveSelectionIndex = 0;
            }
        }

        if (hoveredObjects.length > 0) {
            movePreview.style.left = (e.clientX + 20) + 'px';
            movePreview.style.top = e.clientY + 'px';
            updateMovePreviewContent();
        } else {
            movePreview.style.display = 'none';
        }
    } else if (isBuildMode && (selectedBuildObject || movingObject)) {
        // NIEUW: Preview tijdens plaatsen (nieuw of verplaatsen)
        const obj = movingObject || selectedBuildObject;
        
        movePreview.style.display = 'flex';
        movePreview.style.left = (e.clientX + 20) + 'px';
        movePreview.style.top = e.clientY + 'px';
        
        movePreviewName.textContent = obj.name;
        movePreviewImg.src = getObjectImageSrc(obj);

        const actionText = document.getElementById('movePreviewActionText');
        if (actionText) {
            actionText.textContent = "[R] Roteren";
            actionText.style.color = '#ccc';
        }

        const priceText = document.getElementById('movePreviewPrice');
        if (priceText) {
            // Toon prijs alleen bij nieuw object (niet bij verplaatsen bestaand object)
            if (!movingObject && !isUserAdmin && obj.price) {
                priceText.textContent = `â‚¬${obj.price}`;
                priceText.style.display = 'block';
            } else {
                priceText.style.display = 'none';
            }
        }
        
        const countText = document.getElementById('movePreviewCount');
        if(countText) countText.style.display = 'none';
    } else {
        movePreview.style.display = 'none';
        movePreviewName.textContent = '';
        hoveredObjects = [];
        moveSelectionIndex = 0;
        lastHoveredTileKey = "";
    }
});

let mousePos = { x: 0, y: 0 };
// Event listeners
canvas.addEventListener("mousemove", e=>{
    // Blokkeer hover-effecten in de hoofdkamer als Pong actief is
    if (pongRunning) return;

    mousePos = { x: e.clientX, y: e.clientY };

    const {x, y} = toTile(e.clientX, e.clientY);
    hoverCell = (x>=0 && x<mapW && y>=0 && y<mapH) ? {x,y} : null;

    // --- Hover detectie voor muren en tegels in bouwmodus ---
    if (isBuildMode) {
        hoverTarget = null;
        
        // NIEUW: Check of we muren moeten negeren (als we een vloerobject plaatsen)
        let checkWalls = true;
        const activeObj = movingObject || selectedBuildObject;
        if (activeObj) {
            const isFloorObj = (activeObj.placement === 'floor' && !activeObj.wallId) || activeObj.isItem;
            if (isFloorObj) checkWalls = false;
        }

        const wallHeight = 150;
        mouseWorldX = (e.clientX - (window.innerWidth / 2 + camX)) / scale;
        mouseWorldY = (e.clientY - (window.innerHeight / 4 + camY)) / scale;

        if (checkWalls) {
            // Check top walls (van voor naar achter voor correcte selectie)
            for (let x = 0; x < mapW; x++) {
                const p1 = toScreen(x, 0);
                const p2 = toScreen(x + 1, 0);
                // Bounding box van het muursegment
                // We gebruiken een iets complexere check voor de isometrische vorm
                const inside = isInside(mouseWorldX, mouseWorldY, [p1, p2, {sx: p2.sx, sy: p2.sy - wallHeight}, {sx: p1.sx, sy: p1.sy - wallHeight}]);
                if (inside) {
                    hoverTarget = { type: 'wall', id: `top_${x}` };
                    break;
                }
            }

            // Als geen top-muur, check linker muren
            if (!hoverTarget) {
                for (let y = 0; y < mapH; y++) {
                    const p1 = toScreen(0, y);
                    const p2 = toScreen(0, y + 1);
                    // Bounding box van het muursegment
                    const inside = isInside(mouseWorldX, mouseWorldY, [p1, p2, {sx: p2.sx, sy: p2.sy - wallHeight}, {sx: p1.sx, sy: p1.sy - wallHeight}]);
                    if (inside) {
                        hoverTarget = { type: 'wall', id: `left_${y}` };
                        break;
                    }
                }
            }
        }

        // Als nog steeds geen muur, check voor een tegel
        if (!hoverTarget && hoverCell) {
            hoverTarget = { type: 'tile', id: hoverCell };
        }
    }

    if(isCameraDragging){ // Gebruik de nieuwe variabele
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        
        camX = camStart.x + dx;
        camY = camStart.y + dy;
    } 
});

window.addEventListener("mousemove", e => {
    // --- Logica voor verplaatsen BINNEN inventaris ---
    if (isRearrangingInventory && activeInventoryItem && activeInventoryDiv) {
        const inventory = document.getElementById("inventory");
        const rect = inventory.getBoundingClientRect();
        
        // Check of we over de container zijn (voor drag-drop naar container)
        const containerWindow = document.getElementById("containerWindow");
        let isOverContainer = false;
        if (containerWindow && containerWindow.style.display === 'flex') {
             const cRect = containerWindow.getBoundingClientRect();
             if (e.clientX >= cRect.left && e.clientX <= cRect.right && e.clientY >= cRect.top && e.clientY <= cRect.bottom) {
                 isOverContainer = true;
             }
        }

        // Check of de muis BUITEN de inventaris komt -> Switch naar wereld-sleep
        if (isOverContainer || e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
            isRearrangingInventory = false;
            
            // Verwijder uit inventaris array
            const index = inventoryItems.indexOf(activeInventoryItem);
            if (index > -1) inventoryItems.splice(index, 1);
            
            // Verwijder de div uit de DOM
            if (activeInventoryDiv) activeInventoryDiv.remove();

            savePlayerData(); // Opslaan (item is eruit)            
            
            // Start de wereld-sleep logica
            draggedItem = activeInventoryItem;
            isItemDragging = true;
            isDraggingFromInventory = true;
            draggedItemOriginalPos = null;
            
            // Maak het sleep-plaatje aan
            dragImageElement = document.createElement('img');
            dragImageElement.src = draggedItem.image.src;
            dragImageElement.style.position = 'absolute';
            dragImageElement.style.pointerEvents = 'none';
            dragImageElement.style.zIndex = '9999';
            dragImageElement.style.imageRendering = 'pixelated';
            const w = (draggedItem.image.width || 64) * scale;
            const h = (draggedItem.image.height || 64) * scale;
            dragImageElement.style.width = w + 'px';
            dragImageElement.style.left = (e.clientX - w/2) + 'px';
            dragImageElement.style.top = (e.clientY - h/2) + 'px';
            document.body.appendChild(dragImageElement);
            
            activeInventoryItem = null;
            activeInventoryDiv = null;
            return;
        }

        // Zolang we BINNEN de inventaris zijn: update positie
        const contentRect = document.getElementById("inventoryContent").getBoundingClientRect();
        const newX = e.clientX - contentRect.left - inventoryDragOffset.x;
        const newY = e.clientY - contentRect.top - inventoryDragOffset.y;
        
        activeInventoryItem.invX = newX;
        activeInventoryItem.invY = newY;
        
        activeInventoryDiv.style.left = newX + 'px';
        activeInventoryDiv.style.top = newY + 'px';
    }

    // Update draggedItem position if dragging (Global to allow dragging over inventory)
    if (isItemDragging && draggedItem) {
        const worldPos = toWorld(e.clientX, e.clientY);
        draggedItem.x = worldPos.x;
        draggedItem.y = worldPos.y;

        if (dragImageElement) {
            const w = (draggedItem.image.width || 64) * scale;
            const h = (draggedItem.image.height || 64) * scale;
            dragImageElement.style.width = w + 'px';
            dragImageElement.style.left = (e.clientX - w/2) + 'px';
            dragImageElement.style.top = (e.clientY - h/2) + 'px';
            
            // NIEUW: Filter logic tijdens slepen
            const tx = Math.floor(worldPos.x);
            const ty = Math.floor(worldPos.y);
            const playerOnTile = Math.floor(ball.x) === tx && Math.floor(ball.y) === ty;
            const dist = Math.sqrt(Math.pow(tx - Math.floor(ball.x), 2) + Math.pow(ty - Math.floor(ball.y), 2));
            const isValid = tx >= 0 && tx < mapW && ty >= 0 && ty < mapH && !playerOnTile && dist <= 2;

            if (isValid) {
                dragImageElement.style.filter = "brightness(1.5)";
            } else {
                dragImageElement.style.filter = "sepia(1) hue-rotate(-50deg) saturate(5)";
            }
        }
    }
});

window.addEventListener("mousemove", e => {
    // --- Logica voor verplaatsen BINNEN container ---
    if (isRearrangingContainer && activeContainerItem) {
        const containerWindow = document.getElementById("containerWindow");
        const rect = containerWindow.getBoundingClientRect();
        
        // Check of de muis BUITEN de container komt -> Switch naar wereld-sleep
        if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
            isRearrangingContainer = false;
            
            // Verwijder uit container items array
            const index = openContainer.items.indexOf(activeContainerItem);
            if (index > -1) openContainer.items.splice(index, 1);
            renderContainerItems(); 
            
            // Start de wereld-sleep logica
            draggedItem = activeContainerItem;
            isItemDragging = true;
            isDraggingFromContainer = true;
            isDraggingFromInventory = false;
            isDraggingFromShop = false;
            draggedItemOriginalPos = null;
            
            // Maak het sleep-plaatje aan
            dragImageElement = document.createElement('img');
            dragImageElement.src = draggedItem.image.src;
            dragImageElement.style.position = 'absolute';
            dragImageElement.style.pointerEvents = 'none';
            dragImageElement.style.zIndex = '9999';
            dragImageElement.style.imageRendering = 'pixelated';
            const w = (draggedItem.image.width || 64) * scale;
            const h = (draggedItem.image.height || 64) * scale;
            dragImageElement.style.width = w + 'px';
            dragImageElement.style.left = (e.clientX - w/2) + 'px';
            dragImageElement.style.top = (e.clientY - h/2) + 'px';
            document.body.appendChild(dragImageElement);
            
            activeContainerItem = null;
            return;
        }

        // Zolang we BINNEN de container zijn: update positie
        const contentRect = document.getElementById("containerContent").getBoundingClientRect();
        activeContainerItem.conX = e.clientX - contentRect.left - containerDragOffset.x;
        activeContainerItem.conY = e.clientY - contentRect.top - containerDragOffset.y;
        renderContainerItems(); 
    }
});

// Helper functie om te checken of een punt in een polygoon (de muur) ligt
function isInside(x, y, vs) {
    // ray-casting algorithm
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i].sx, yi = vs[i].sy;
        const xj = vs[j].sx, yj = vs[j].sy;

        const intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

// NIEUW: Functie om item daadwerkelijk op te pakken (uitgesplitst voor vertraging)
function performItemPickup(item, clientX, clientY) {
    // Check of item nog bestaat (kan verwijderd zijn door sync)
    const index = items.indexOf(item);
    if (index === -1) return;

    // Sla de staat van de vensters op
    windowStatesBeforeDrag = {
        chat: document.getElementById('chatLog').style.display,
        inventory: document.getElementById('inventory').style.display,
        vicinity: document.getElementById('vicinityWindow').style.display,
        pouch: document.getElementById('pouchWindow').style.display,
        build: document.getElementById('buildMenu').style.display,
        shop: document.getElementById('shopWindow').style.display,
        container: document.getElementById('containerWindow').style.display
    };
    closeAllWindows(); // Sluit andere vensters

    // Start de sleep-modus voor het item
    draggedItem = items.splice(index, 1)[0];
    draggedItemOriginalPos = { x: draggedItem.x, y: draggedItem.y };
    isItemDragging = true;
    syncItems(); // DIRECT SYNCEN: Vertel server dat item weg is uit de wereld
    isDraggingFromInventory = false; // Komt uit de wereld
    isDraggingFromShop = false;
    isDraggingFromVicinity = false;
    isDraggingFromContainer = false;
    camSmooth = false;

    // Maak een tijdelijk DOM-element aan dat de muis volgt
    dragImageElement = document.createElement('img');
    dragImageElement.src = draggedItem.image.src;
    dragImageElement.style.position = 'absolute';
    dragImageElement.style.pointerEvents = 'none'; // Zodat we erdoorheen kunnen klikken/hoveren
    dragImageElement.style.zIndex = '9999'; // Boven alles
    dragImageElement.style.imageRendering = 'pixelated';
    const w = (draggedItem.image.width || 64) * scale;
    const h = (draggedItem.image.height || 64) * scale;
    dragImageElement.style.width = w + 'px';
    dragImageElement.style.left = (clientX - w/2) + 'px';
    dragImageElement.style.top = (clientY - h/2) + 'px';
    document.body.appendChild(dragImageElement);

    // Open de inventaris zodat de gebruiker de optie heeft om het item daarheen te slepen
    inventory.style.display = 'flex';
    document.querySelector('#inventoryBtn img').src = "icons/inventory_active.png";
    renderInventoryItems();
    console.log("Item vastgepakt!", draggedItem);
    
    // Reset pending state
    pendingPickup = null;
    if (pickupTimer) {
        clearTimeout(pickupTimer);
        pickupTimer = null;
    }
}

canvas.addEventListener("mousedown", e => {
    e.preventDefault(); // Voorkom dat de browser de canvas als afbeelding probeert te slepen (ghost image)
    
    // NIEUW: Check of we op een interactie-knop klikken (zoals het batje)
    if (activeInteractionButton && e.button === 0) {
        const mx = e.clientX;
        const my = e.clientY;
        if (mx >= activeInteractionButton.x && mx <= activeInteractionButton.x + activeInteractionButton.w &&
            my >= activeInteractionButton.y && my <= activeInteractionButton.y + activeInteractionButton.h) {
            
            const obj = activeInteractionButton.obj;
            const isPong = obj.interactionType === 'pong' || obj.name === "Pong";
            const isShop = obj.subCategory === 'shop' || obj.name === "Winkel";
            const isContainer = obj.subCategory === 'containers' || obj.name.includes("Container");
            const isTrash = obj.subCategory === 'trash' || obj.name.includes("Prullenbak");

            if (isPong) {
                // Check of speler een batje heeft
                const hasPaddle = inventoryItems.some(item => item.name && item.name.toLowerCase().includes("batje"));
                if (hasPaddle) {
                    // Vraag server om game te starten (AI of PvP check)
                    socket.emit('requestPong', {
                        tableX: obj.x,
                        tableY: obj.y,
                        playerX: Math.floor(ball.x),
                        playerY: Math.floor(ball.y)
                    });
                } else {
                    showNotification("Om te kunnen tafeltennissen moet je een batje in je inventaris hebben!");
                }
            } else if (isShop) {
                openShopWindow(obj);
            } else if (isContainer || isTrash) {
                openContainerWindow(obj);
            }
            return;
        }
    }

    if (e.button === 0) { // Linkermuisknop
        // --- Logica voor verslepen van 'moveable' objecten (buiten bouwmodus) ---
        if (!isBuildMode) {
            const {x, y} = toTile(e.clientX, e.clientY);
            const objectToDragIndex = objects.findIndex(o => {
                const w = o.flipped ? (o.depth || 1) : (o.width || 1);
                const d = o.flipped ? (o.width || 1) : (o.depth || 1);
                return x >= o.x && x < o.x + w && y >= o.y && y < o.y + d && o.moveable;
            });
 
            if (objectToDragIndex > -1) {
                // Sla de staat van de vensters op VOORDAT ze gesloten worden
                windowStatesBeforeDrag = {
                    chat: document.getElementById('chatLog').style.display,
                    inventory: document.getElementById('inventory').style.display,
                    vicinity: document.getElementById('vicinityWindow').style.display,
                    pouch: document.getElementById('pouchWindow').style.display,
                    build: document.getElementById('buildMenu').style.display,
                    shop: document.getElementById('shopWindow').style.display,
                    container: document.getElementById('containerWindow').style.display
                };
                closeAllWindows(); // Sluit alle vensters bij het oppakken van een object
                draggedObject = objects.splice(objectToDragIndex, 1)[0];
                draggedObjectOriginalPos = { x: draggedObject.x, y: draggedObject.y };
                camOriginalPos = { x: camX, y: camY }; // Sla de huidige camera positie op
                isObjectDragging = true; // Start de sleep-modus voor het object
                camSmooth = false; // Stop eventuele smooth-beweging
                return;
            }

            // --- Logica voor het oppakken van items ---
            const itemToPickIndex = items.findIndex(item => {
                const itemTileX = Math.floor(item.x);
                const itemTileY = Math.floor(item.y);
                return itemTileX === x && itemTileY === y;
            });

            if (itemToPickIndex > -1) {
                const itemToPick = items[itemToPickIndex];
                const playerTileX = Math.floor(ball.x);
                const playerTileY = Math.floor(ball.y);
                const itemTileX = Math.floor(itemToPick.x);
                const itemTileY = Math.floor(itemToPick.y);

                const distance = Math.sqrt(Math.pow(playerTileX - itemTileX, 2) + Math.pow(playerTileY - itemTileY, 2));

                // Alleen oppakken als de speler dichtbij genoeg is
                if (distance <= 2) {
                    // NIEUW: Start vertraagd oppakken (zodat kort klikken = lopen)
                    pendingPickup = { item: itemToPick, x: e.clientX, y: e.clientY };
                    
                    // Wacht 200ms. Als muis dan nog ingedrukt is (of bewogen), pakken we hem op.
                    // Als muis eerder losgelaten wordt, is het een klik (lopen).
                    pickupTimer = setTimeout(() => {
                        performItemPickup(itemToPick, pendingPickup ? pendingPickup.x : e.clientX, pendingPickup ? pendingPickup.y : e.clientY);
                    }, 200);
                    
                    // We returnen NIET, zodat dragStart gezet wordt en mouseup de loop-logica kan triggeren als we annuleren.
                }
            }
        }
        // Sla de startpositie op voor een mogelijke klik-actie (geen drag)
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
    }
    // Sla de startpositie op voor een mogelijke klik-actie (geen drag) - Ook voor rechtermuisknop
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    if (e.button === 2) { // Rechtermuisknop
        camStart.x = camX;
        camStart.y = camY;
        isCameraDragging = true; // Start camera slepen
        camSmooth = false;
    }
});

window.addEventListener("mouseup", e => {    
    // Als we hier komen, was het geen object-sleep, dus het kan een klik zijn
    // of een drag die geen object betrof.

    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;

    // NIEUW: Als we aan het wachten waren op een pickup, en we laten nu los (korte klik):
    // Annuleer de pickup. De code hieronder zal het interpreteren als een klik (want dx/dy is klein)
    // en de loop-logica triggeren.
    if (pickupTimer) {
        clearTimeout(pickupTimer);
        pickupTimer = null;
        pendingPickup = null;
        // We gaan nu door naar de standaard logica. Omdat isItemDragging false is,
        // en dx/dy klein is, zal de loop-logica onderaan deze functie afgaan.
    }

    // --- Afhandeling van het loslaten van een versleept item ---
    if (isItemDragging && e.button === 0) {
        // Safety check: als draggedItem om een of andere reden null is, stop dan.
        if (!draggedItem) {
            isItemDragging = false;
            return;
        }

        if (dragImageElement) {
            dragImageElement.remove();
            dragImageElement = null;
        }

        let {x, y} = toTile(e.clientX, e.clientY);
        const inventory = document.getElementById("inventory");
        const containerWindow = document.getElementById("containerWindow");
        let droppedInInventory = false;

        // Check of we over de container of pouch droppen
        const containerRect = containerWindow.getBoundingClientRect();
        const isOverContainer = containerWindow.style.display === 'flex' && openContainer && e.clientX >= containerRect.left && e.clientX <= containerRect.right && e.clientY >= containerRect.top && e.clientY <= containerRect.bottom;
        
        const pouchWindow = document.getElementById('pouchWindow');
        const pouchRect = pouchWindow.getBoundingClientRect();
        const isOverPouch = pouchWindow.style.display === 'flex' && openPouch && e.clientX >= pouchRect.left && e.clientX <= pouchRect.right && e.clientY >= pouchRect.top && e.clientY <= pouchRect.bottom;

        const targetContainer = isOverPouch ? openPouch : (isOverContainer ? openContainer : null);

        if (targetContainer) {
            // Voorkom dat een pouch in zichzelf wordt gedropt
            if (draggedItem !== targetContainer) {
                const isCigPack = targetContainer.type === 'sigaretten_container' || targetContainer.itemType === 'sigaretten_container';
                let allowed = true;

                if (isCigPack) {
                        if (targetContainer.items.length >= 20) {
                        showNotification("Pakje is vol!");
                        allowed = false;
                    } else if (draggedItem.type !== 'sigaret' && draggedItem.itemType !== 'sigaret' && draggedItem.type !== 'sigaret_half' && draggedItem.itemType !== 'sigaret_half') {
                        showNotification("Alleen voor sigaretten!");
                        allowed = false;
                    }
                }

                if (allowed) {
                    const contentEl = isOverPouch ? document.getElementById('pouchContent') : document.getElementById('containerContent');
                    const contentRect = contentEl.getBoundingClientRect();
                    draggedItem.conX = e.clientX - contentRect.left - 50;
                    draggedItem.conY = e.clientY - contentRect.top - 50;
                    targetContainer.items.push(draggedItem);
                    
                    if (isOverPouch) {
                        renderPouchItems();
                        savePlayerData(); // Pouches zijn onderdeel van spelerdata
                    } else {
                        renderContainerItems();
                    }
                    droppedInInventory = true; // Set this to prevent it from being placed in the world
                } else {
                    // NIEUW: Als het item geweigerd wordt, stuur het terug naar de bron
                    if (isDraggingFromInventory) {
                        inventoryItems.push(draggedItem);
                        savePlayerData();
                        renderInventoryItems();
                    } else if (isDraggingFromShop) {
                        shopOutputItems.push(draggedItem);
                        renderShopOutput();
                    } else if (isDraggingFromContainer && openPouch) {
                        openPouch.items.push(draggedItem);
                        renderPouchItems();
                    } else if (isDraggingFromContainer && openContainer) {
                        openContainer.items.push(draggedItem);
                        renderContainerItems();
                    } else if (isDraggingFromVicinity) {
                        // Terug naar wereld (vicinity)
                        draggedItem.x = draggedItemOriginalPos.x;
                        draggedItem.y = draggedItemOriginalPos.y;
                        items.push(draggedItem);
                        syncItems();
                    } else {
                        draggedItem.x = draggedItemOriginalPos.x;
                        draggedItem.y = draggedItemOriginalPos.y;
                        items.push(draggedItem);
                        syncItems();
                    }
                    droppedInInventory = true; // Voorkom dat het in de wereld of inventory (via overlap) belandt
                }
            }
        }

        if (inventory && inventory.style.display === 'flex') {
             const inventoryRect = inventory.getBoundingClientRect();
             const isOverInventory = e.clientX >= inventoryRect.left && e.clientX <= inventoryRect.right && e.clientY >= inventoryRect.top && e.clientY <= inventoryRect.bottom;
             
             if (isOverInventory && !droppedInInventory) {
                 if (draggedItem.type === 'currency' || draggedItem.type === 'currency_big') {
                     let amount = 0;
                     if (draggedItem.type === 'currency') {
                         // Random bedrag tussen 0.05 en 20.00 in stappen van 0.05
                         const steps = Math.floor(Math.random() * 400) + 1; // 1 tot 400
                         amount = steps * 0.05;
                     } else {
                         // Random bedrag tussen 25.00 en 100.00 in stappen van 0.05
                         const steps = Math.floor(Math.random() * 1501); // 0 tot 1500 (75 / 0.05)
                         amount = 25 + (steps * 0.05);
                     }
                     
                     addToWallet(amount);
                     console.log("Geld toegevoegd:", amount.toFixed(2));
                 } else {
                     // Bereken positie in inventaris op basis van muis
                     const contentRect = document.getElementById("inventoryContent").getBoundingClientRect();
                     draggedItem.invX = e.clientX - contentRect.left - 50; // Centreer op muis (100/2)
                     draggedItem.invY = e.clientY - contentRect.top - 50;
                     
                     inventoryItems.push(draggedItem);
                     savePlayerData(); // Opslaan (item erbij)
                     renderInventoryItems();
                     console.log("Item in inventaris geplaatst:", draggedItem);
                 }
                 droppedInInventory = true;
             }
        }

        if (!droppedInInventory) {
            const playerOnTile = Math.floor(ball.x) === x && Math.floor(ball.y) === y;
            
            // Check afstand (max 2 tegels)
            const dist = Math.sqrt(Math.pow(x - Math.floor(ball.x), 2) + Math.pow(y - Math.floor(ball.y), 2));
            // NIEUW: Items mogen op objecten en op elkaar
            let isValidPlacement = x >= 0 && x < mapW && y >= 0 && y < mapH && !playerOnTile && dist <= 2;

            // NIEUW: Auto-drop naast speler als plek ongeldig is (bijv. te ver weg)
            if (!isValidPlacement) {
                 const px = Math.floor(ball.x);
                 const py = Math.floor(ball.y);
                 const offsets = [
                     {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1},
                     {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
                 ];
                 
                 for (const o of offsets) {
                     const tx = px + o.dx;
                     const ty = py + o.dy;
                     // Check of deze buur-tegel geldig is (binnen map, niet op speler)
                     if (tx >= 0 && tx < mapW && ty >= 0 && ty < mapH && !(tx === px && ty === py)) {
                         x = tx;
                         y = ty;
                         isValidPlacement = true;
                         break;
                     }
                 }
            }

            if (isValidPlacement) {
                const surfaceZ = getSurfaceHeight(x, y);
                draggedItem.x = x + 0.5 + (Math.random() * 0.6 - 0.3); // Iets meer random
                draggedItem.y = y + 0.5 + (Math.random() * 0.6 - 0.3); // Iets meer random
                
                // BONUS: Laat het item stuiteren bij plaatsen (vanaf iets boven het oppervlak)
                draggedItem.z = surfaceZ + 2; // AANGEPAST: Bijna direct op de grond (was +10)
                draggedItem.vz = 0; // Start snelheid
                draggedItem.lastTouchedBy = mySocketId; // NIEUW: Wij zijn eigenaar
                
                // NIEUW: Zorg dat physics variabelen bestaan (voorkomt NaN bugs waardoor items verdwijnen)
                if (draggedItem.vx === undefined) draggedItem.vx = 0;
                if (draggedItem.vy === undefined) draggedItem.vy = 0;
                if (draggedItem.vr === undefined) draggedItem.vr = 0;
                if (draggedItem.rotation === undefined) draggedItem.rotation = 0;
                
                if (socket) {
                    socket.emit('placeItem', serializeItem(draggedItem));
                } else {
                    items.push(draggedItem); // Fallback voor single player
                }
            } else {
                // Als de plaatsing ongeldig is:
                if (isDraggingFromInventory) {
                    // Terug naar inventaris als het daar vandaan kwam
                    inventoryItems.push(draggedItem);
                    savePlayerData(); // Opslaan
                    renderInventoryItems();
                } else if (isDraggingFromShop) {
                    // Terug naar winkel uitgifte
                    shopOutputItems.push(draggedItem);
                    renderShopOutput();
                } else if (isDraggingFromContainer && openPouch) { // BUG FIX: Was renderShopOutput()
                    // Terug naar pouch
                    openPouch.items.push(draggedItem);
                    renderPouchItems();
                } else if (isDraggingFromContainer && openContainer) {
                    // Terug naar container
                    openContainer.items.push(draggedItem);
                    renderContainerItems();
                } else if (isDraggingFromVicinity) {
                    // Terug naar wereld
                    draggedItem.x = draggedItemOriginalPos.x;
                    draggedItem.y = draggedItemOriginalPos.y;
                    items.push(draggedItem);
                    syncItems();
                } else {
                    // Terug naar oude plek in de wereld
                    draggedItem.x = draggedItemOriginalPos.x;
                    draggedItem.y = draggedItemOriginalPos.y;
                    items.push(draggedItem);
                }
                console.log("Ongeldige plaatsing, item teruggezet.");
            }
        }

        // Reset alle sleep-gerelateerde variabelen voor items
        isItemDragging = false;
        isDraggingFromInventory = false;
        isDraggingFromShop = false;
        isDraggingFromVicinity = false;
        isDraggingFromContainer = false;
        draggedItem = null;
        draggedItemOriginalPos = null;

        // Heropen de vensters die open stonden
        if (windowStatesBeforeDrag) {
            if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
            // We laten de inventory open als die al open was, of als we er iets in hebben gesleept.
            if (windowStatesBeforeDrag.inventory === 'flex' || droppedInInventory) {
                 if(inventory) { inventory.style.display = 'flex'; document.querySelector('#inventoryBtn img').src = "icons/inventory_active.png"; }
            } else {
                     if(inventory) { inventory.style.display = 'none'; document.querySelector('#inventoryBtn img').src = "icons/inventory.png"; }
                }
            if (windowStatesBeforeDrag.vicinity === 'flex') {
                document.getElementById('vicinityWindow').style.display = 'flex';
            }
            if (windowStatesBeforeDrag.pouch === 'flex') {
                document.getElementById('pouchWindow').style.display = 'flex';
            }
            if (windowStatesBeforeDrag.build === 'flex') {
                if (!isBuildMode) buildBtn.click();
            }
            if (windowStatesBeforeDrag.shop === 'flex') {
                document.getElementById('shopWindow').style.display = 'flex';
            }
            if (windowStatesBeforeDrag.container === 'flex') {
                document.getElementById('containerWindow').style.display = 'flex';
            }
            windowStatesBeforeDrag = null;
        }
        return; // Belangrijk: stop verdere uitvoering
    }

    // Stop met herschikken in inventaris (en handel drop af)
    if (isRearrangingInventory) {
        const inventory = document.getElementById("inventory");
        const containerWindow = document.getElementById("containerWindow");

        const pouchWindow = document.getElementById('pouchWindow');
        // Check of we het op de container hebben gedropt
        let droppedInContainer = false;
        if (containerWindow && containerWindow.style.display === 'flex' && openContainer && activeInventoryItem) {
            const cRect = containerWindow.getBoundingClientRect();
            if (e.clientX >= cRect.left && e.clientX <= cRect.right && e.clientY >= cRect.top && e.clientY <= cRect.bottom) {
                // Ja, gedropt op container.
                
                // Voorkom dat een pouch in zichzelf wordt gedropt
                if (activeInventoryItem !== openContainer) {
                    const isCigPack = openContainer.type === 'sigaretten_container' || openContainer.itemType === 'sigaretten_container';
                    let allowed = true;

                    if (isCigPack) {
                        if (openContainer.items.length >= 20) {
                            showNotification("Pakje is vol!");
                            allowed = false;
                        } else if (activeInventoryItem.type !== 'sigaret' && activeInventoryItem.itemType !== 'sigaret' && activeInventoryItem.type !== 'sigaret_half' && activeInventoryItem.itemType !== 'sigaret_half') {
                            showNotification("Alleen voor sigaretten!");
                            allowed = false;
                        }
                    }

                    if (allowed) {
                        const contentRect = document.getElementById("containerContent").getBoundingClientRect();
                        activeInventoryItem.conX = e.clientX - contentRect.left - 50;
                        activeInventoryItem.conY = e.clientY - contentRect.top - 50;
                        openContainer.items.push(activeInventoryItem);
                        
                        // Verwijder uit inventory om duplicatie te voorkomen
                        const idx = inventoryItems.indexOf(activeInventoryItem);
                        if (idx > -1) inventoryItems.splice(idx, 1);
                        renderInventoryItems();

                        renderContainerItems();
                        if (openContainer.isPouch || openContainer.type === 'pouch') {
                            savePlayerData();
                        }
                        droppedInContainer = true;
                    }
                }
            }
        } else if (pouchWindow && pouchWindow.style.display === 'flex' && openPouch && activeInventoryItem) {
            const pRect = pouchWindow.getBoundingClientRect();
            if (e.clientX >= pRect.left && e.clientX <= pRect.right && e.clientY >= pRect.top && e.clientY <= pRect.bottom) {
                // Ja, gedropt op pouch.
                if (activeInventoryItem !== openPouch) {
                    const isCigPack = openPouch.type === 'sigaretten_container' || openPouch.itemType === 'sigaretten_container';
                    let allowed = true;

                    if (isCigPack) {
                        if (openPouch.items.length >= 20) {
                            showNotification("Pakje is vol!");
                            allowed = false;
                        } else if (activeInventoryItem.type !== 'sigaret' && activeInventoryItem.itemType !== 'sigaret' && activeInventoryItem.type !== 'sigaret_half' && activeInventoryItem.itemType !== 'sigaret_half') {
                            showNotification("Alleen voor sigaretten!");
                            allowed = false;
                        }
                    }

                    if (allowed) {
                        const contentRect = document.getElementById("pouchContent").getBoundingClientRect();
                        activeInventoryItem.conX = e.clientX - contentRect.left - 50;
                        activeInventoryItem.conY = e.clientY - contentRect.top - 50;
                        openPouch.items.push(activeInventoryItem);
                        
                        // Verwijder uit inventory om duplicatie te voorkomen
                        const idx = inventoryItems.indexOf(activeInventoryItem);
                        if (idx > -1) inventoryItems.splice(idx, 1);
                        renderInventoryItems();

                        renderPouchItems();
                        savePlayerData(); 
                        droppedInContainer = true;
                    }
                }
            }
        }
        
        savePlayerData(); // Sla altijd op, of het nu verplaatst is in inv of naar container
        isRearrangingInventory = false;
        activeInventoryItem = null;
        activeInventoryDiv = null;
        return; // Stop verdere muis-afhandeling
    }
    
    if (isRearrangingContainer) {
        isRearrangingContainer = false;
        activeContainerItem = null;
    }

    if (activePouchItem) {
        isRearrangingContainer = false; // Hergebruik vlag
        activePouchItem = null;
    }

    // Voor de volgende acties (bouwen, lopen) moet de muis op het canvas zijn
    if (e.target !== canvas) return;

    // Als we in bouwmodus zijn en het een klik was, handel de tool-actie af
    if (e.button === 0 && isBuildMode && Math.sqrt(dx*dx + dy*dy) < 5) { // Alleen uitvoeren bij linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);

        // Plaatsen kan op een tegel (x/y >= 0) of op een muur (hoverTarget.type === 'wall')
        if (activeBuildCategory === 'objecten' && ((x >= 0 && y >= 0) || hoverTarget?.type === 'wall')) {
            
            // Check geld voor spelers
            if (!isUserAdmin && buildTool === 'place' && selectedBuildObject && selectedBuildObject.price) {
                if (walletBalance < selectedBuildObject.price) {
                    showNotification(`Niet genoeg geld! Nodig: â‚¬${selectedBuildObject.price}`);
                    return;
                }
                // Geld wordt afgeschreven als plaatsing succesvol is (hieronder)
            }

            // Check geldigheid voor plaatsing (rekening houdend met width/depth)
            const checkPlacement = (bx, by, obj, flipped) => {
                const w = flipped ? (obj.depth || 1) : (obj.width || 1);
                const d = flipped ? (obj.width || 1) : (obj.depth || 1);
                for(let dx = 0; dx < w; dx++) {
                    for(let dy = 0; dy < d; dy++) {
                        const tx = bx + dx;
                        const ty = by + dy;
                        if (tx >= mapW || ty >= mapH) return false;
                        if (!obj.isFloor && (isBlocked(tx, ty) || (Math.floor(ball.x) === tx && Math.floor(ball.y) === ty))) return false;
                    }
                }
                return true;
            };
            
            // --- Object Tool Logica ---
            switch (buildTool) {
                case 'place':
                    // NIEUW: Check voor Item Spawns
                    if (selectedBuildObject?.isItem) {
                        // Items negeren object-collision (mogen erop) en item-collision (mogen op elkaar)
                        if (hoverTarget?.type !== 'wall' && x >= 0 && x < mapW && y >= 0 && y < mapH) {
                            if (!isUserAdmin && selectedBuildObject.price) {
                                addToWallet(-selectedBuildObject.price);
                                showNotification(`<span style="color: #ff4757;">-â‚¬${selectedBuildObject.price.toFixed(2).replace('.', ',')}</span>`);
                            }
                            const surfaceZ = getSurfaceHeight(x, y);
                            const newItem = {
                                type: selectedBuildObject.itemType,
                                name: selectedBuildObject.name,
                                x: x + 0.5 + (Math.random() * 0.6 - 0.3), // Iets meer random
                                y: y + 0.5 + (Math.random() * 0.6 - 0.3), // Iets meer random
                                z: surfaceZ + 50, // Spawn uit de lucht boven het oppervlak
                                vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0,
                                mass: selectedBuildObject.mass || 1.0,
                                canRotate: selectedBuildObject.canRotate || false,
                                canTopple: selectedBuildObject.canTopple || false,
                                isPouch: selectedBuildObject.isPouch || false,
                                uses: selectedBuildObject.uses
                            };

                            // NIEUW: Als het een pakje sigaretten is, vul het met random 0-20 sigaretten
                            if (newItem.type === 'sigaretten_container') {
                                newItem.items = [];
                                const count = Math.floor(Math.random() * 20); // 0 tot 20
                                for (let i = 0; i < count; i++) {
                                    newItem.items.push({
                                        type: 'sigaret',
                                        name: 'Sigaret',
                                        mass: 0.05,
                                        canTopple: true,
                                        vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0 // NIEUW: Physics initialiseren
                                    });
                                }
                            }

                            // NIEUW: Admin random uses voor aansteker (0-50)
                            if (isUserAdmin && newItem.type === 'aansteker') {
                                newItem.uses = Math.floor(Math.random() * 51);
                            }

                            socket.emit('placeItem', newItem);
                        }
                    } else if (selectedBuildObject?.placement === 'floor' && selectedBuildObject.name) {
                        if (hoverTarget?.type !== 'wall' && checkPlacement(x, y, selectedBuildObject, isBuildObjectFlipped)) {
                            if (!isUserAdmin && selectedBuildObject.price) {
                                addToWallet(-selectedBuildObject.price);
                                showNotification(`<span style="color: #ff4757;">-â‚¬${selectedBuildObject.price.toFixed(2).replace('.', ',')}</span>`);
                            }
                            const { runtimeImage, ...objectToSend } = selectedBuildObject;
                            socket.emit('placeObject', { ...objectToSend, x: x, y: y, flipped: isBuildObjectFlipped, ownerId: mySocketId });
                        }
                    } else if (selectedBuildObject?.placement === 'wall' && hoverTarget?.type === 'wall') {
                        const wallId = hoverTarget.id; // De ID van de muur waar we op klikken
                        
                        if (selectedBuildObject.isFree) {
                            // NIEUW: Vrije plaatsing
                            const mouseWorldX = (e.clientX - (window.innerWidth / 2 + camX)) / scale;
                            const mouseWorldY = (e.clientY - (window.innerHeight / 4 + camY)) / scale;
                            const wallSide = wallId.split('_')[0];

                            if (!isUserAdmin && selectedBuildObject.price) {
                                addToWallet(-selectedBuildObject.price);
                                showNotification(`<span style="color: #ff4757;">-â‚¬${selectedBuildObject.price.toFixed(2).replace('.', ',')}</span>`);
                            }
                            socket.emit('placeWallObject', { 
                                wallId: wallId,
                                name: selectedBuildObject.name, 
                                flipped: isBuildObjectFlipped,
                                image: selectedBuildObject.image,
                                isCustom: selectedBuildObject.isCustom,
                                ownerId: mySocketId,
                                isFree: true,
                                freeX: mouseWorldX,
                                freeY: mouseWorldY,
                                wallSide: wallSide,
                                isTemplate: true, // Markeer dat dit van een template komt
                                width: selectedBuildObject.width || 1
                            });
                        } else {
                            // OUDE LOGICA voor grid-based
                            const width = selectedBuildObject.width || 1;
                            const [type, indexStr] = wallId.split('_');
                            const startIndex = parseInt(indexStr);
                            let isValid = true;
                            for (let i = 0; i < width; i++) {
                                const currentWallId = `${type}_${startIndex + i}`;
                                const max = (type === 'top') ? mapW : mapH;
                                if ((startIndex + i) >= max) {
                                    isValid = false;
                                    break;
                                }
                            }

                            if (!isValid) {
                                showNotification("Niet genoeg ruimte voor dit object!");
                                return;
                            }

                            if (!isUserAdmin && selectedBuildObject.price) {
                                addToWallet(-selectedBuildObject.price);
                                showNotification(`<span style="color: #ff4757;">-â‚¬${selectedBuildObject.price.toFixed(2).replace('.', ',')}</span>`);
                            }
                            socket.emit('placeWallObject', { 
                                wallId: wallId, 
                                name: selectedBuildObject.name, 
                                flipped: isBuildObjectFlipped,
                                image: selectedBuildObject.image, // Stuur plaatje mee
                                isCustom: selectedBuildObject.isCustom, // Stuur custom vlag mee
                                ownerId: mySocketId, // Stuur eigenaar mee
                                width: width // Stuur breedte mee
                            });
                        }
                    }
                    break;
                case 'move':
                    if (movingObject) {
                        let isValid = false;
                        if (movingObject.isItem) {
                             isValid = hoverTarget?.type !== 'wall' && x >= 0 && x < mapW && y >= 0 && y < mapH;
                        } else if (movingObject.wallId) { // Het is een muurobject
                            isValid = hoverTarget && hoverTarget.type === 'wall';
                            if (!movingObject.isFree && isValid) {
                                const wallId = hoverTarget.id;
                                const width = movingObject.width || 1;
                                const [type, indexStr] = wallId.split('_');
                                const startIndex = parseInt(indexStr);

                                let placementValid = true;
                                for (let i = 0; i < width; i++) {
                                    const currentWallId = `${type}_${startIndex + i}`;
                                    const max = (type === 'top') ? mapW : mapH;
                                    if ((startIndex + i) >= max) {
                                        placementValid = false;
                                        break;
                                    }
                                }
                                isValid = placementValid;
                            }
                        } else {
                             isValid = hoverTarget?.type !== 'wall' && checkPlacement(x, y, movingObject, movingObject.flipped);
                        }

                        if (isValid) {
                            if (movingObject.isItem) {
                                movingObject.x = x;
                                movingObject.y = y;
                                movingObject.x += 0.5; // Centreer item op tegel
                                movingObject.y += 0.5;
                                
                                // Reset physics state (idle)
                                movingObject.rotation = 0;
                                movingObject.vr = 0;
                                movingObject.vx = 0;
                                movingObject.vy = 0;
                                movingObject.vz = 0;
                                movingObject.z = getSurfaceHeight(x, y);

                                const { image, isItem, ...itemToSend } = movingObject;
                                socket.emit('placeItem', itemToSend);
                            } else if (movingObject.wallId) { // Het is een muurobject
                                if (movingObject.isFree) {
                                    // NIEUW: Vrije plaatsing
                                    const mouseWorldX = (e.clientX - (window.innerWidth / 2 + camX)) / scale;
                                    const mouseWorldY = (e.clientY - (window.innerHeight / 4 + camY)) / scale;
                                    const wallSide = hoverTarget.id.split('_')[0];
                                    socket.emit('placeWallObject', { 
                                        wallId: hoverTarget.id,
                                        name: movingObject.name, 
                                        flipped: movingObject.flipped,
                                        image: movingObject.image,
                                        isCustom: movingObject.isCustom,
                                        ownerId: mySocketId,
                                        isFree: true,
                                        freeX: mouseWorldX,
                                        freeY: mouseWorldY,
                                        wallSide: wallSide,
                                        width: movingObject.width || 1
                                    });
                                } else {
                                    // OUDE LOGICA
                                    socket.emit('placeWallObject', { 
                                        wallId: hoverTarget.id, 
                                        name: movingObject.name, 
                                        flipped: movingObject.flipped,
                                        image: movingObject.image,
                                        isCustom: movingObject.isCustom,
                                        ownerId: mySocketId,
                                        width: movingObject.width || 1
                                    });
                                }
                            } else {
                                movingObject.x = x;
                                movingObject.y = y;
                                const { runtimeImage, ...objectToSend } = movingObject;
                                socket.emit('placeObject', objectToSend); // Stuur naar server
                            }
                            movingObject = null; // Stop met verplaatsen
                            movePreview.style.display = 'none';
                            hoveredObjects = []; // Reset hovered objects om stale references te voorkomen
                        }
                    } else { // Anders, pak een object op
                        let objectToMove = null;
                        
                        // Gebruik de selectie uit het menu als die er is
                        if (hoveredObjects.length > 0) {
                            objectToMove = hoveredObjects[moveSelectionIndex];
                        }
                        
                        if (objectToMove) {
                            const itemIndex = items.indexOf(objectToMove);
                            if (itemIndex > -1) {
                                movingObject = items.splice(itemIndex, 1)[0];
                                movingObject.isItem = true; // Markeer als item
                                socket.emit('removeItem', { 
                                    x: Math.floor(movingObject.x), 
                                    y: Math.floor(movingObject.y),
                                    type: movingObject.type,
                                    name: movingObject.name
                                });
                                closeSecondaryWindows();
                            } else if (objectToMove.wallId) {
                                // Muurobject oppakken
                                const idx = wallObjects.indexOf(objectToMove);
                                if (idx > -1) {
                                    movingObject = objectToMove;
                                    wallObjects.splice(idx, 1); // Verwijder direct uit lokale lijst

                                    isBuildObjectFlipped = movingObject.flipped; // Synchroniseer de rotatie-status
                                    socket.emit('removeWallObject', { 
                                        id: movingObject.id,
                                        wallId: movingObject.wallId, 
                                        name: movingObject.name,
                                        ownerId: movingObject.ownerId,
                                        isCustom: movingObject.isCustom,
                                        image: movingObject.image
                                    });
                                    closeSecondaryWindows();
                                }
                            } else {
                                const objectToMoveIndex = objects.indexOf(objectToMove);
                                if (objectToMoveIndex > -1) {
                                    movingObject = objects.splice(objectToMoveIndex, 1)[0];
                                    // Maak een schoon object zonder runtime properties voor de server
                                    const { runtimeImage, ...objectToSend } = movingObject;
                                    socket.emit('removeObject', objectToSend); 
                                    closeSecondaryWindows(); // Sluit andere vensters bij het oppakken
                                    isBuildObjectFlipped = movingObject.flipped; // Synchroniseer de rotatie-status
                                }
                            }
                        }
                    }
                    break;
                case 'delete':
                    let objectToDelete = null;

                    // Gebruik de selectie uit het menu als die er is
                    if (hoveredObjects.length > 0) {
                        objectToDelete = hoveredObjects[moveSelectionIndex];
                    }

                    if (objectToDelete) {
                        // NIEUW: Refund logica (50% terug bij verwijderen eigen object)
                        if (!isUserAdmin && objectToDelete.price && objectToDelete.ownerId === mySocketId) {
                            const refund = objectToDelete.price / 2;
                            addToWallet(refund);
                            showNotification(`<span style="color: #4cd137;">+â‚¬${refund.toFixed(2).replace('.', ',')}</span>`);
                        }

                        const itemIndex = items.indexOf(objectToDelete);
                        if (itemIndex > -1) {
                            socket.emit('removeItem', { 
                                x: Math.floor(objectToDelete.x), 
                                y: Math.floor(objectToDelete.y),
                                type: objectToDelete.type,
                                name: objectToDelete.name
                            });
                            items.splice(itemIndex, 1);
                        } else if (objectToDelete.wallId) {
                            socket.emit('removeWallObject', { 
                                id: objectToDelete.id,
                                wallId: objectToDelete.wallId, 
                                name: objectToDelete.name,
                                ownerId: objectToDelete.ownerId,
                                isCustom: objectToDelete.isCustom,
                                image: objectToDelete.image
                            });
                        } else {
                            const { runtimeImage, ...objectToSend } = objectToDelete;
                            socket.emit('removeObject', objectToSend);
                        }
                        movePreview.style.display = 'none'; // Verberg menu na verwijderen
                    } else if (hoverTarget?.type === 'wall') {
                        socket.emit('removeWallObject', hoverTarget.id);
                    } else {
                        // Check of we een item verwijderen
                        const itemToDeleteIndex = items.findIndex(item => Math.floor(item.x) === x && Math.floor(item.y) === y);
                        if (itemToDeleteIndex > -1) {
                            const itemToDelete = items[itemToDeleteIndex];
                            socket.emit('removeItem', { x: Math.floor(itemToDelete.x), y: Math.floor(itemToDelete.y) });
                            items.splice(itemToDeleteIndex, 1);
                        }
                    }
                    break;
            }
        } else if (activeBuildCategory === 'kleur') {
            // --- Kleur Tool Logica ---
            if (hoverTarget) {
                if (colorTool === 'brush') {
                    if (hoverTarget.type === 'tile') {
                        const tileKey = `${hoverTarget.id.x},${hoverTarget.id.y}`;
                        tileColors[tileKey] = selectedColor;
                        socket.emit('updateTileColor', { key: tileKey, color: selectedColor });
                    } else if (hoverTarget.type === 'wall') {
                        wallColors[hoverTarget.id] = selectedColor;
                        socket.emit('updateWallColor', { id: hoverTarget.id, color: selectedColor });
                    }
                } else if (colorTool === 'bucket') {
                    const startNode = hoverTarget;

                    const getTargetColor = (node) => {
                        if (node.type === 'tile') {
                            return tileColors[`${node.id.x},${node.id.y}`] || '#444';
                        }
                        const defaultColor = node.id.startsWith('top') ? '#555' : '#666';
                        return wallColors[node.id] || defaultColor;
                    };

                    const targetColor = getTargetColor(startNode);

                    if (targetColor === selectedColor) return; // Voorkom oneindige loops

                    const queue = [startNode];
                    const visited = new Set();
                    visited.add(JSON.stringify(startNode.id)); // Gebruik JSON.stringify voor unieke keys

                    while (queue.length > 0) {
                        const current = queue.shift();

                        // Kleur het huidige element
                        if (current.type === 'tile') {
                            tileColors[`${current.id.x},${current.id.y}`] = selectedColor;
                            socket.emit('updateTileColor', { key: `${current.id.x},${current.id.y}`, color: selectedColor });
                        } else {
                            wallColors[current.id] = selectedColor;
                            socket.emit('updateWallColor', { id: current.id, color: selectedColor });
                        }

                        // Vind buren
                        let neighbors = [];
                        if (current.type === 'tile') {
                            const { x, y } = current.id;
                            neighbors = [
                                { type: 'tile', id: { x: x + 1, y: y } },
                                { type: 'tile', id: { x: x - 1, y: y } },
                                { type: 'tile', id: { x: x, y: y + 1 } },
                                { type: 'tile', id: { x: x, y: y - 1 } }
                            ].filter(n => n.id.x >= 0 && n.id.x < mapW && n.id.y >= 0 && n.id.y < mapH);
                        } else { // Wall
                            const [type, indexStr] = current.id.split('_');
                            const index = parseInt(indexStr);
                            neighbors = [
                                { type: 'wall', id: `${type}_${index + 1}` },
                                { type: 'wall', id: `${type}_${index - 1}` }
                            ].filter(n => {
                                const i = parseInt(n.id.split('_')[1]);
                                const max = (type === 'top') ? mapW : mapH;
                                return i >= 0 && i < max;
                            });
                        }

                        for (const neighbor of neighbors) {
                            const neighborIdStr = JSON.stringify(neighbor.id);
                            if (!visited.has(neighborIdStr)) {
                                visited.add(neighborIdStr);
                                if (getTargetColor(neighbor) === targetColor) {
                                    queue.push(neighbor);
                                }
                            }
                        }
                    }
                } else if (colorTool === 'picker') {
                    // --- Pipet Tool Logica ---
                    let pickedColor = null;
                    if (hoverTarget.type === 'tile') {
                        pickedColor = tileColors[`${hoverTarget.id.x},${hoverTarget.id.y}`] || '#444';
                    } else if (hoverTarget.type === 'wall') {
                        const defaultColor = hoverTarget.id.startsWith('top') ? '#555' : '#666';
                        pickedColor = wallColors[hoverTarget.id] || defaultColor;
                    }

                    if (pickedColor) {
                        colorPicker.color.hexString = pickedColor;
                        showNotification(`Kleur gekopieerd: ${pickedColor}`);
                    }
                }
            }
        }
        return; // Bouwactie afgehandeld, stop verdere uitvoering
    }

    // Als het een klik was (niet een sleep) en niet in bouwmodus, start dan spelerbeweging
    if(e.button === 0 && Math.sqrt(dx*dx + dy*dy) < 5 && !isBuildMode){ // Alleen uitvoeren bij linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);
        
        // NIEUW: Extra check om te voorkomen dat we lopen als we net een item hebben opgepakt
        // (Hoewel isItemDragging dit meestal al afvangt, kan de timing bij de timeout net verkeerd vallen)
        if (isItemDragging) return;

        if(x >= 0 && x < mapW && y >= 0 && y < mapH && !isBlocked(x, y)){
            // NIEUW: Onderbreek roken bij verplaatsen
            if (isSmoking || isDrinking) {
                interruptAction();
            }

            const startTile = { x: Math.floor(ball.x), y: Math.floor(ball.y) };
            path = findPath(startTile, { x, y });
            highlightedPath = [...path]; // Kopieer het pad voor highlighting

            if(!jumping && path.length > 0){
                jumpStart = { x: ball.x, y: ball.y }; // voet als start
                const next = path.shift();
                jumpEnd = { x: next.x + 0.5, y: next.y + 0.5 }; // voet op midden tegel
                jumpProgress = 0;
                jumping = true;
            }
        }
    }
});

// Reset alle dragging states bij mouseleave
canvas.addEventListener("mouseleave", e => {
    isCameraDragging = false;
    isObjectDragging = false;
    
    // Reset hovers zodat highlights verdwijnen als je over UI gaat
    hoverCell = null;
    hoverTarget = null;

    // Item dragging wordt niet gereset bij mouseleave, zodat we naar de inventory kunnen slepen
    
    // NIEUW: Als we de canvas verlaten terwijl we wachten op pickup, annuleer pickup
    if (pickupTimer) {
        clearTimeout(pickupTimer);
        pickupTimer = null;
        pendingPickup = null;
    }
});

// Rechtermuisklik om bouwselectie te annuleren
canvas.addEventListener("contextmenu", e => {
    e.preventDefault(); // Voorkom altijd het browser context menu op de canvas

    // Bepaal of het een klik was (geen sleepbeweging)
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    const isClick = Math.sqrt(dx*dx + dy*dy) < 5 && !isCameraDragging; // Voeg check toe voor camera dragging

    // Voer de annuleer-actie alleen uit als het een 'klik' was en geen 'drag'
    if (isClick) {
        if (isBuildMode && selectedBuildObject) {
            selectedBuildObject = null;
            const selectedItem = document.querySelector('.build-item.selected');
            if (selectedItem) {
                selectedItem.classList.remove('selected');
                isBuildObjectFlipped = false;
            }
        }
        if (isBuildMode && movingObject) {
                if (movingObject.isItem) {
                    const { image, isItem, ...itemToSend } = movingObject;
                    socket.emit('placeItem', itemToSend);
                } else if (movingObject.wallId) {
                    socket.emit('placeWallObject', { 
                        wallId: movingObject.wallId, 
                        name: movingObject.name, 
                        flipped: movingObject.flipped,
                        image: movingObject.image,
                        isCustom: movingObject.isCustom,
                        ownerId: movingObject.ownerId 
                    });
                } else {
                    socket.emit('placeObject', movingObject); // Zet het object terug via server
                }
            movingObject = null;
            movePreview.style.display = 'none';
        }
        // NIEUW: Annuleer item slepen met rechtermuisklik
        if (isItemDragging && draggedItem) {
            if (dragImageElement) {
                dragImageElement.remove();
                dragImageElement = null;
            }
            
            if (isDraggingFromInventory) {
                inventoryItems.push(draggedItem);
                savePlayerData(); // Opslaan
                renderInventoryItems();
            } else {
                draggedItem.x = draggedItemOriginalPos.x;
                draggedItem.y = draggedItemOriginalPos.y;
                items.push(draggedItem); // Zet item terug
                syncItems(); // Sync
            }
            isItemDragging = false;
            isDraggingFromInventory = false;
            if (isDraggingFromShop) {
                shopOutputItems.push(draggedItem);
                renderShopOutput();
            }
            if (isDraggingFromContainer && openContainer) {
                openContainer.items.push(draggedItem);
                renderContainerItems();
            }
            if (isDraggingFromVicinity) {
                draggedItem.x = draggedItemOriginalPos.x;
                draggedItem.y = draggedItemOriginalPos.y;
                items.push(draggedItem);
                syncItems();
            }
            draggedItem = null;
            draggedItemOriginalPos = null;
            // Heropen de vensters die open stonden
            if (windowStatesBeforeDrag) {
                if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
                if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
                if (windowStatesBeforeDrag.vicinity) document.getElementById('vicinityWindow').style.display = windowStatesBeforeDrag.vicinity;
                if (windowStatesBeforeDrag.build === 'flex') {
                    buildBtn.click();
                }
                if (windowStatesBeforeDrag.shop === 'flex') {
                    document.getElementById('shopWindow').style.display = 'flex';
                }
                windowStatesBeforeDrag = null;
            }
        }
    }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸª WINKEL LOGICA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const shopCatalog = [
    { name: "Batje Rood", image: batjeRoodImg, price: 15.00, mass: 0.4, canTopple: true, type: 'bat_red', keywords: ['sport', 'pingpong', 'racket']},
    { name: "Batje Zwart", image: batjeZwartImg, price: 15.00, mass: 0.4, canTopple: true, type: 'bat_black', keywords: ['sport', 'pingpong', 'racket']},
    { name: "Pakje sigaretten", image: sigarettenContainerImg, price: 20.00, mass: 0.2, type: 'sigaretten_container', isPouch: true, keywords: ['pakkie', 'peuken', 'tabak', 'peukie'] },
    { name: "Aansteker", image: aanstekerStickImg, price: 2.50, mass: 0.1, canTopple: true, type: 'aansteker', uses: 50, keywords: ['vuurtje', 'lichtje', 'lighter', 'gasbrander'] },
    { name: "Flesje water", image: bottleFullImg, price: 3.00, mass: 1.2, type: 'bottle_full', keywords: ['drinken', 'spa', 'vloeistof', 'vocht'] }
];

let currentOpenShop = null;

function openShopWindow(shopObj) {
    currentOpenShop = shopObj;
    const shopWindow = document.getElementById('shopWindow');
    const shopContent = document.getElementById('shopContent');

    // Check voor brede winkel
    if (shopObj.width >= 2 || shopObj.depth >= 2) {
        shopWindow.style.width = '600px'; // Bredere winkel
        shopContent.style.gridTemplateColumns = 'repeat(5, 1fr)'; // Meer kolommen
    } else {
        shopWindow.style.width = '380px'; // Standaard breedte
        shopContent.style.gridTemplateColumns = 'repeat(3, 1fr)'; // Standaard kolommen
    }

    shopWindow.style.display = 'flex';
    renderShopItems();
    renderShopOutput();
    
    // Open ook de inventory voor gemak
    inventory.style.display = 'flex';
    document.querySelector('#inventoryBtn img').src = "icons/inventory_active.png";
    renderInventoryItems();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ VICINITY (OMGEVING) LOGICA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const vicinityWindow = document.getElementById('vicinityWindow');
const vicinityContent = document.getElementById('vicinityContent');
const closeVicinityWindowBtn = document.getElementById('closeVicinityWindowBtn');
let vicinityInterval = null;

function renderVicinityItems() {
    if (vicinityWindow.style.display !== 'flex') return;
    
    vicinityContent.innerHTML = '';
    const playerX = Math.floor(ball.x);
    const playerY = Math.floor(ball.y);

    // Filter items binnen 2 tegels
    const nearbyItems = items.filter(item => {
        const dist = Math.sqrt(Math.pow(Math.floor(item.x) - playerX, 2) + Math.pow(Math.floor(item.y) - playerY, 2));
        return dist <= 2;
    });

    if (nearbyItems.length === 0) {
        vicinityContent.innerHTML = '<div style="color:#aaa; width:100%; text-align:center; margin-top:20px;">Geen items in de buurt.</div>';
        return;
    }

    nearbyItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'inventory-item';
        div.style.width = '64px';
        div.style.height = '64px';
        div.style.position = 'relative'; // Voor normale flow
        div.style.left = 'auto';
        div.style.top = 'auto';
        
        const imgSrc = item.image ? item.image.src : (createItemFromData(item).image.src);
        div.innerHTML = `<img src="${imgSrc}">`;

        div.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (e.button === 0) {
                // Start slepen vanuit vicinity (wereld)
                const index = items.indexOf(item);
                if (index > -1) {
                    items.splice(index, 1);
                    syncItems(); // Verwijder uit wereld voor iedereen
                    
                    draggedItem = item;
                    draggedItemOriginalPos = { x: item.x, y: item.y };
                    isItemDragging = true;
                    isDraggingFromVicinity = true;
                    isDraggingFromInventory = false;
                    isDraggingFromShop = false;
                    isDraggingFromContainer = false;

                    // Visueel element
                    dragImageElement = document.createElement('img');
                    dragImageElement.src = imgSrc;
                    dragImageElement.style.position = 'absolute';
                    dragImageElement.style.pointerEvents = 'none';
                    dragImageElement.style.zIndex = '9999';
                    dragImageElement.style.imageRendering = 'pixelated';
                    const w = (item.image && item.image.width ? item.image.width : 64) * scale;
                    dragImageElement.style.width = w + 'px';
                    dragImageElement.style.left = (e.clientX - w/2) + 'px';
                    dragImageElement.style.top = (e.clientY - w/2) + 'px';
                    document.body.appendChild(dragImageElement);
                    
                    renderVicinityItems(); // Update lijst direct
                }
            }
        });

        vicinityContent.appendChild(div);
    });
}

// Sleep logica voor vicinity header
const vicinityHeader = document.getElementById('vicinityHeader');
let isDraggingVicinity = false;
let dragStartVicinity = {x:0, y:0};
let vicinityStartPos = {x:0, y:0};

if (vicinityHeader) {
    vicinityHeader.addEventListener("mousedown", (e) => {
        bringToFront(vicinityWindow);
        isDraggingVicinity = true;
        dragStartVicinity = {x: e.clientX, y: e.clientY};
        const rect = vicinityWindow.getBoundingClientRect();
        vicinityWindow.style.left = rect.left + "px";
        vicinityWindow.style.top = rect.top + "px";
        vicinityStartPos = {x: rect.left, y: rect.top};
        e.preventDefault();
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingVicinity) return;
    const dx = e.clientX - dragStartVicinity.x;
    const dy = e.clientY - dragStartVicinity.y;
    const newX = Math.max(0, Math.min(vicinityStartPos.x + dx, window.innerWidth - vicinityWindow.offsetWidth));
    const newY = Math.max(0, Math.min(vicinityStartPos.y + dy, window.innerHeight - vicinityWindow.offsetHeight));
    vicinityWindow.style.left = newX + "px";
    vicinityWindow.style.top  = newY + "px";
});

window.addEventListener("mouseup", () => {
    isDraggingVicinity = false;
});

document.getElementById('closeShopBtn').addEventListener('click', () => {
    document.getElementById('shopWindow').style.display = 'none';
    currentOpenShop = null;
});

// Functie om de bouwknop in de footer te updaten
function updateBuildButton() {
    const btn = document.getElementById('buildBtn');
    const img = btn.querySelector('img');
    
    // Admin en Eigenaar mogen altijd bouwen. Anderen alleen als allowBuilding true is.
    const canBuild = isUserAdmin || isRoomOwner || currentRoomSettings.allowBuilding;
    
    if (canBuild) {
        btn.style.pointerEvents = 'auto';
        btn.style.opacity = '1';
        if (img.src.includes('buildmenu_inactive.png')) img.src = 'icons/buildmenu.png';
    } else {
        btn.style.pointerEvents = 'none';
        img.src = 'icons/buildmenu_inactive.png';
        if (isBuildMode) closeBuildAdminMenu(); // Sluit menu als rechten worden ingetrokken
    }
}

// ROLE SELECTION LOGICA
const roleSelector = document.getElementById('roleSelector');
const rolePlayerBtn = document.getElementById('rolePlayerBtn');
const roleAdminBtn = document.getElementById('roleAdminBtn');

// NIEUW: Check of rol al gekozen is in deze sessie
const storedRole = sessionStorage.getItem('habboRole');
if (storedRole) {
    if (roleSelector) roleSelector.style.display = 'none';
    if (storedRole === 'admin') {
        isUserAdmin = true;
        updateBuildButton();
    } else {
        isUserAdmin = false;
        if (document.getElementById('adminBtn')) document.getElementById('adminBtn').style.display = 'none';
        if (document.getElementById('cheatBtn')) document.getElementById('cheatBtn').style.display = 'none';
        updateBuildButton();
    }
}

if (rolePlayerBtn) {
    rolePlayerBtn.addEventListener('click', () => {
        sessionStorage.setItem('habboRole', 'player'); // Opslaan
        
        const urlParams = new URLSearchParams(window.location.search);
        const currentRoom = urlParams.get('room');

        // Als we al in een studio zitten, verberg het menu alleen
        if (currentRoom && currentRoom.startsWith('alumni-') && currentRoom.endsWith('-studio')) {
            roleSelector.style.display = 'none';
            isUserAdmin = false;
            if (document.getElementById('adminBtn')) document.getElementById('adminBtn').style.display = 'none';
            if (document.getElementById('cheatBtn')) document.getElementById('cheatBtn').style.display = 'none';
            updateBuildButton();
        } else {
            // Anders: maak een nieuwe studio aan en ga erheen
            const randomId = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
            const roomName = `alumni-${randomId}-studio`;
            window.location.search = `?room=${roomName}&size=10`;
        }
    });
}
if (roleAdminBtn) {
    roleAdminBtn.addEventListener('click', () => {
        sessionStorage.setItem('habboRole', 'admin'); // Opslaan
        roleSelector.style.display = 'none';
        isUserAdmin = true;
        updateBuildButton();
    });
}

// ROOMS BUTTON LOGICA
const roomsBtn = document.getElementById('roomsBtn');
const roomsWindow = document.getElementById('roomsWindow');
const closeRoomsBtn = document.getElementById('closeRoomsBtn');

if (roomsBtn) {
    roomsBtn.addEventListener('click', () => {
        if (roomsWindow.style.display === 'flex') {
            roomsWindow.style.display = 'none';
            roomsBtn.querySelector('img').src = "icons/rooms.png";
        } else {
            roomsWindow.style.display = 'flex';
            roomsBtn.querySelector('img').src = "icons/rooms_active.png";
            socket.emit('getRooms');
            bringToFront(roomsWindow);
        }
    });
}

if (closeRoomsBtn) {
    closeRoomsBtn.addEventListener('click', () => {
        roomsWindow.style.display = 'none';
        roomsBtn.querySelector('img').src = "icons/rooms.png";
    });
}

// MY ROOM BUTTON LOGICA
const myRoomBtn = document.getElementById('myRoomBtn');
const myRoomWindow = document.getElementById('myRoomWindow');
const closeMyRoomBtn = document.getElementById('closeMyRoomBtn');
const myRoomContent = document.getElementById('myRoomContent');

function renderMyRoomSettings() {
    myRoomContent.innerHTML = '';

    if (!myRoomId) {
        myRoomContent.innerHTML = '<div style="padding:10px; color:#aaa;">Je hebt nog geen eigen kamer.</div>';
        return;
    }
    
    const urlParams = new URLSearchParams(window.location.search);
    const currentRoomId = urlParams.get('room') || 'testroom';
    
    // Header met deurbel (alleen icoon)
    const headerDiv = document.createElement('div');
    headerDiv.style.display = 'flex';
    headerDiv.style.justifyContent = 'center';
    headerDiv.style.gap = '15px';
    headerDiv.style.marginBottom = '15px';
    headerDiv.style.borderBottom = '1px solid #444';
    headerDiv.style.paddingBottom = '10px';
    
    const bellIcon = document.createElement('img');
    bellIcon.src = myRoomSettings.doorbell ? "icons/bel_active.png" : "icons/bel.png";
    bellIcon.style.width = "16px";
    bellIcon.style.height = "16px";
    bellIcon.style.imageRendering = "pixelated";
    bellIcon.style.cursor = "pointer";
    bellIcon.title = "Deurbel " + (myRoomSettings.doorbell ? "AAN" : "UIT");
    
    bellIcon.onclick = () => {
        myRoomSettings.doorbell = !myRoomSettings.doorbell;
        socket.emit('updateRoomSettings', { roomId: myRoomId, settings: { doorbell: myRoomSettings.doorbell } });
        renderMyRoomSettings(); // Re-render local state immediately
    };

    const roomsIcon = document.createElement('img');
    const isMyRoom = currentRoomId === myRoomId;
    roomsIcon.src = isMyRoom ? "icons/rooms_active.png" : "icons/rooms.png";
    roomsIcon.style.width = "16px";
    roomsIcon.style.height = "16px";
    roomsIcon.style.imageRendering = "pixelated";
    roomsIcon.style.cursor = "pointer";
    roomsIcon.title = "Ga naar mijn studio";
    
    roomsIcon.onclick = () => {
        if (!isMyRoom) {
            window.location.search = `?room=${myRoomId}`;
        }
    };

    // Build Permission Toggle
    const buildIcon = document.createElement('img');
    buildIcon.src = myRoomSettings.allowBuilding ? "icons/buildmenu_active.png" : "icons/buildmenu.png";
    buildIcon.style.width = "16px";
    buildIcon.style.height = "16px";
    buildIcon.style.imageRendering = "pixelated";
    buildIcon.style.cursor = "pointer";
    buildIcon.title = "Bouwen door anderen: " + (myRoomSettings.allowBuilding ? "TOEGESTAAN" : "VERBODEN");

    buildIcon.onclick = () => {
        myRoomSettings.allowBuilding = !myRoomSettings.allowBuilding;
        socket.emit('updateRoomSettings', { roomId: myRoomId, settings: { allowBuilding: myRoomSettings.allowBuilding } });
        renderMyRoomSettings();
    };

    // No Smoking Toggle
    const smokeIcon = document.createElement('img');
    smokeIcon.src = myRoomSettings.noSmoking ? "icons/verboden_active.png" : "icons/verboden.png";
    smokeIcon.style.width = "16px";
    smokeIcon.style.height = "16px";
    smokeIcon.style.imageRendering = "pixelated";
    smokeIcon.style.cursor = "pointer";
    smokeIcon.title = "Roken: " + (myRoomSettings.noSmoking ? "VERBODEN" : "TOEGESTAAN");

    smokeIcon.onclick = () => {
        myRoomSettings.noSmoking = !myRoomSettings.noSmoking;
        socket.emit('updateRoomSettings', { roomId: myRoomId, settings: { noSmoking: myRoomSettings.noSmoking } });
        renderMyRoomSettings();
    };

    headerDiv.appendChild(bellIcon);
    headerDiv.appendChild(buildIcon);
    headerDiv.appendChild(smokeIcon);
    headerDiv.appendChild(roomsIcon);
    myRoomContent.appendChild(headerDiv);

    // Spelerslijst
    const listContainer = document.createElement('div');
    listContainer.style.overflowY = 'auto';
    listContainer.style.maxHeight = '200px';

    if (currentRoomId === myRoomId) {
        if (Object.keys(otherPlayers).length === 0) {
        } else {
            Object.values(otherPlayers).forEach(p => {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.justifyContent = 'space-between';
                row.style.alignItems = 'center';
                row.style.padding = '8px 5px';
                row.style.borderBottom = '1px solid #333';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = p.name;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.gap = '10px';

                // Heart Icon
                const isAlreadyFriend = myFriends.some(friend => friend.userId === p.userId);
                const heartBtn = document.createElement('img');
                heartBtn.src = isAlreadyFriend ? "icons/heart_active.png" : "icons/heart.png"; 
                heartBtn.style.width = "20px";
                heartBtn.style.height = "20px";
                heartBtn.title = isAlreadyFriend ? "Vrienden" : "Vriend toevoegen";

                if (!isAlreadyFriend) {
                    heartBtn.style.cursor = "pointer";
                    heartBtn.onclick = () => {
                        showConfirmation({
                            message: `Wil je een vriendschapsverzoek sturen naar ${p.name}?`,
                            icon: 'icons/heart.png',
                            onConfirm: () => socket.emit('sendFriendRequest', { targetId: p.id })
                        });
                    };
                }

                // Kick Icon (alleen als je eigenaar bent)
                if (isRoomOwner) {
                    const kickBtn = document.createElement('img');
                    kickBtn.src = "icons/kick.png";
                    kickBtn.style.width = "20px";
                    kickBtn.style.height = "20px";
                    kickBtn.style.cursor = "pointer";
                    kickBtn.title = "Kicken";
                    
                    kickBtn.onmousedown = () => { kickBtn.src = "icons/kick_active.png"; };
                    kickBtn.onmouseup = () => { kickBtn.src = "icons/kick.png"; };
                    kickBtn.onmouseleave = () => { kickBtn.src = "icons/kick.png"; };

                    kickBtn.onclick = () => {
                        showConfirmation({
                            message: `Wil je ${p.name} kicken uit je studio?`,
                            icon: 'icons/kick.png',
                            onConfirm: () => socket.emit('kickPlayer', { targetId: p.id })
                        });
                    };
                    actionsDiv.appendChild(kickBtn);
                }

                actionsDiv.appendChild(heartBtn);
                
                row.appendChild(nameSpan);
                row.appendChild(actionsDiv);
                listContainer.appendChild(row);
            });
        }
    }

    myRoomContent.appendChild(listContainer);
}

if (myRoomBtn) {
    myRoomBtn.addEventListener('click', () => {
        if (myRoomWindow.style.display === 'flex') {
            myRoomWindow.style.display = 'none';
            myRoomBtn.querySelector('img').src = "icons/myroom.png";
        } else {
            myRoomWindow.style.display = 'flex';
            myRoomBtn.querySelector('img').src = "icons/myroom_active.png";
            bringToFront(myRoomWindow);
            renderMyRoomSettings();
        }
    });
}
if (closeMyRoomBtn) {
    closeMyRoomBtn.addEventListener('click', () => {
        myRoomWindow.style.display = 'none';
        myRoomBtn.querySelector('img').src = "icons/myroom.png";
    });
}

const closeRoomPlayersBtn = document.getElementById('closeRoomPlayersBtn');
if (closeRoomPlayersBtn) {
    closeRoomPlayersBtn.addEventListener('click', () => {
        document.getElementById('roomPlayersWindow').style.display = 'none';
    });
}

// FRIENDS BUTTON LOGICA
const friendsBtn = document.getElementById('friendsBtn');
const friendsWindow = document.getElementById('friendsWindow');
const closeFriendsBtn = document.getElementById('closeFriendsBtn');

if (friendsBtn) {
    friendsBtn.addEventListener('click', () => {
        if (friendsWindow.style.display === 'flex') {
            friendsWindow.style.display = 'none';
            friendsBtn.querySelector('img').src = "icons/heart.png";
        } else {
            friendsWindow.style.display = 'flex';
            friendsBtn.querySelector('img').src = "icons/heart_active.png";
            bringToFront(friendsWindow);
            socket.emit('getFriends');
        }
    });
}
if (closeFriendsBtn) {
    closeFriendsBtn.addEventListener('click', () => {
        friendsWindow.style.display = 'none';
        friendsBtn.querySelector('img').src = "icons/heart.png";
    });
}

// CHEAT BUTTON LOGICA
document.getElementById('cheatBtn').addEventListener('click', () => {
    addToWallet(1000);
    showNotification("Cheats: â‚¬1000 toegevoegd!");
});

function renderShopItems() {
    const content = document.getElementById('shopContent');
    content.innerHTML = '';

    const searchInput = document.getElementById('shopSearchInput');
    const sortSelect = document.getElementById('shopSortSelect');
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
    const sortMode = sortSelect ? sortSelect.value : 'name_asc';

    let displayItems = shopCatalog.filter(item => {
        const nameMatch = item.name.toLowerCase().includes(searchTerm);
        const keywordMatch = item.keywords && item.keywords.some(k => k.toLowerCase().includes(searchTerm));
        return nameMatch || keywordMatch;
    });

    displayItems.sort((a, b) => {
        if (sortMode === 'name_asc') return a.name.localeCompare(b.name);
        if (sortMode === 'name_desc') return b.name.localeCompare(a.name);
        if (sortMode === 'price_asc') return a.price - b.price;
        if (sortMode === 'price_desc') return b.price - a.price;
        return 0;
    });
    
    displayItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'build-item'; // Hergebruik stijl
        div.style.height = 'auto';
        div.style.minHeight = '90px';
        div.innerHTML = `
            <img src="${item.image.src}" style="height: 48px; object-fit: contain;">
            <div style="text-align:center;">
                <div>${item.name}</div>
                <div style="color: #4cd137;">â‚¬${item.price.toFixed(2)}</div>
            </div>
        `;
        
        div.onclick = () => buyItem(item);
        content.appendChild(div);
    });
}

// Event listeners voor winkel filters
const shopSearchInput = document.getElementById('shopSearchInput');
if (shopSearchInput) shopSearchInput.addEventListener('input', renderShopItems);

const shopSortSelect = document.getElementById('shopSortSelect');
if (shopSortSelect) shopSortSelect.addEventListener('change', renderShopItems);

function buyItem(template) {
    if (walletBalance >= template.price) {
        addToWallet(-template.price);
        
        // Maak een nieuw item aan
        const newItem = {
            ...template, // Kopieer eigenschappen
            x: 0, y: 0, vx: 0, vy: 0, z: 0, vz: 0, rotation: 0, vr: 0
        };

        // NIEUW: Als het een pakje sigaretten is, vul het volledig (20 stuks)
        if (newItem.type === 'sigaretten_container') {
            newItem.items = [];
            for (let i = 0; i < 20; i++) {
                newItem.items.push(createItemFromData({
                    type: 'sigaret',
                    name: 'Sigaret',
                    mass: 0.05,
                    canTopple: true,
                    vx: 0, vy: 0, vz: 0, rotation: 0, vr: 0 // NIEUW: Physics initialiseren
                }));
            }
        }
        
        shopOutputItems.push(newItem);
        renderShopOutput();
    } else {
        showNotification("Niet genoeg geld!");
    }
}

function renderShopOutput() {
    const output = document.getElementById('shopOutput');
    output.innerHTML = '';
    
    shopOutputItems.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'inventory-item';
        div.style.width = '64px';
        div.style.height = '64px';
        div.innerHTML = `<img src="${item.image.src}">`;
        
        div.addEventListener("mousedown", (e) => {
            e.preventDefault();
            if (e.button === 0) {
                // Haal uit shop output
                shopOutputItems.splice(index, 1);
                renderShopOutput();
                
                // Start slepen
                draggedItem = item;
                isItemDragging = true;
                isDraggingFromShop = true;
                isDraggingFromInventory = false;
                draggedItemOriginalPos = null;
                
                // Visueel element
                dragImageElement = document.createElement('img');
                dragImageElement.src = draggedItem.image.src;
                dragImageElement.style.position = 'absolute';
                dragImageElement.style.pointerEvents = 'none';
                dragImageElement.style.zIndex = '9999';
                dragImageElement.style.imageRendering = 'pixelated';
                const w = (draggedItem.image.width || 64) * scale;
                const h = (draggedItem.image.height || 64) * scale;
                dragImageElement.style.width = w + 'px';
                dragImageElement.style.left = (e.clientX - w/2) + 'px';
                dragImageElement.style.top = (e.clientY - h/2) + 'px';
                document.body.appendChild(dragImageElement);
            }
        });
        
        output.appendChild(div);
    });
}

// Sleep logica voor shop header
const shopWindow = document.getElementById('shopWindow');
const shopHeader = document.getElementById('shopHeader');
let isDraggingShop = false;
let dragStartShop = {x:0, y:0};
let shopStartPos = {x:0, y:0};

shopHeader.addEventListener("mousedown", (e) => {
    bringToFront(shopWindow);
    isDraggingShop = true;
    dragStartShop = {x: e.clientX, y: e.clientY};
    const rect = shopWindow.getBoundingClientRect();
    // Reset transform voor absoluut slepen
    shopWindow.style.transform = "none";
    shopWindow.style.left = rect.left + "px";
    shopWindow.style.top = rect.top + "px";
    shopStartPos = {x: rect.left, y: rect.top};
});

// Zoom knoppen
document.getElementById("zoomIn").addEventListener("click", ()=> {
    if (currentZoomIndex < zoomLevels.length - 1) {
        currentZoomIndex++;
        scale = zoomLevels[currentZoomIndex];
    }
});
document.getElementById("zoomOut").addEventListener("click", ()=> {
    if (currentZoomIndex > 0) {
        currentZoomIndex--;
        scale = zoomLevels[currentZoomIndex];
    }
});

let scaleTarget = 1; // Definieer scaleTarget buiten de center knop

// Center knop
document.getElementById("centerCam").addEventListener("click", ()=>{
    camTargetX = 0;
    camTargetY = 0;
    currentZoomIndex = 2; // Index voor neutraal zoomlevel (1.0)
    scaleTarget = zoomLevels[currentZoomIndex];
    camSmooth = true;
});

const setupStatefulButton = (btn, normalIcon, activeIcon) => {
    if (!btn) return;
    const img = btn.querySelector('img');
    if (!img) return;

    btn.addEventListener('mousedown', () => { img.src = activeIcon; });
    
    const resetIcon = () => { img.src = normalIcon; };
    btn.addEventListener('mouseup', resetIcon);
    btn.addEventListener('mouseleave', resetIcon);
};

setupStatefulButton(document.getElementById("zoomIn"), "icons/max.png", "icons/max_active.png");
setupStatefulButton(document.getElementById("zoomOut"), "icons/min.png", "icons/min_active.png");
setupStatefulButton(document.getElementById("centerCam"), "icons/center.png", "icons/center_active.png");

function updateCamera(delta){
    if(!camSmooth || delta === 0) return;
    let dx = camTargetX - camX; 
    let dy = camTargetY - camY;
    let distance = Math.sqrt(dx*dx + dy*dy);
    let t = Math.min(0.08 * delta, distance * 0.01);
    camX += dx * t;
    camY += dy * t;

    // Smooth zoom
    let ds = scaleTarget - scale;
    scale += ds * 0.08 * delta;

    if(distance < 0.3 && Math.abs(ds) < 0.01){ 
        camX = camTargetX; 
        camY = camTargetY; 
        scale = scaleTarget; 
        currentZoomIndex = zoomLevels.indexOf(scaleTarget); // Synchroniseer de index
        camSmooth = false; 
    }
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingShop) return;

    const dx = e.clientX - dragStartShop.x;
    const dy = e.clientY - dragStartShop.y;

    const newX = Math.max(0, Math.min(shopStartPos.x + dx, window.innerWidth - shopWindow.offsetWidth));
    const newY = Math.max(0, Math.min(shopStartPos.y + dy, window.innerHeight - shopWindow.offsetHeight));

    shopWindow.style.left = newX + "px";
    shopWindow.style.top  = newY + "px";
});

// Sleep logica voor myRoom header
const myRoomHeader = document.getElementById('myRoomHeader');
let isDraggingMyRoom = false;
let dragStartMyRoom = {x:0, y:0};
let myRoomStartPos = {x:0, y:0};

if (myRoomHeader) {
    myRoomHeader.addEventListener("mousedown", (e) => {
        bringToFront(myRoomWindow);
        isDraggingMyRoom = true;
        dragStartMyRoom = {x: e.clientX, y: e.clientY};
        const rect = myRoomWindow.getBoundingClientRect();
        myRoomWindow.style.transform = "none";
        myRoomWindow.style.left = rect.left + "px";
        myRoomWindow.style.top = rect.top + "px";
        myRoomStartPos = {x: rect.left, y: rect.top};
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingMyRoom) return;
    const dx = e.clientX - dragStartMyRoom.x;
    const dy = e.clientY - dragStartMyRoom.y;
    const newX = Math.max(0, Math.min(myRoomStartPos.x + dx, window.innerWidth - myRoomWindow.offsetWidth));
    const newY = Math.max(0, Math.min(myRoomStartPos.y + dy, window.innerHeight - myRoomWindow.offsetHeight));
    myRoomWindow.style.left = newX + "px";
    myRoomWindow.style.top  = newY + "px";
});

// Sleep logica voor roomPlayers header
const roomPlayersWindow = document.getElementById('roomPlayersWindow');
const roomPlayersHeader = document.getElementById('roomPlayersHeader');
let isDraggingRoomPlayers = false;
let dragStartRoomPlayers = {x:0, y:0};
let roomPlayersStartPos = {x:0, y:0};

if (roomPlayersHeader) {
    roomPlayersHeader.addEventListener("mousedown", (e) => {
        bringToFront(roomPlayersWindow);
        isDraggingRoomPlayers = true;
        dragStartRoomPlayers = {x: e.clientX, y: e.clientY};
        const rect = roomPlayersWindow.getBoundingClientRect();
        roomPlayersWindow.style.transform = "none";
        roomPlayersWindow.style.left = rect.left + "px";
        roomPlayersWindow.style.top = rect.top + "px";
        roomPlayersStartPos = {x: rect.left, y: rect.top};
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingRoomPlayers) return;
    const dx = e.clientX - dragStartRoomPlayers.x;
    const dy = e.clientY - dragStartRoomPlayers.y;
    const newX = Math.max(0, Math.min(roomPlayersStartPos.x + dx, window.innerWidth - roomPlayersWindow.offsetWidth));
    const newY = Math.max(0, Math.min(roomPlayersStartPos.y + dy, window.innerHeight - roomPlayersWindow.offsetHeight));
    roomPlayersWindow.style.left = newX + "px";
    roomPlayersWindow.style.top  = newY + "px";
});

// Sleep logica voor friends header
const friendsHeader = document.getElementById('friendsHeader');
let isDraggingFriends = false;
let dragStartFriends = {x:0, y:0};
let friendsStartPos = {x:0, y:0};

if (friendsHeader) {
    friendsHeader.addEventListener("mousedown", (e) => {
        bringToFront(friendsWindow);
        isDraggingFriends = true;
        dragStartFriends = {x: e.clientX, y: e.clientY};
        const rect = friendsWindow.getBoundingClientRect();
        friendsWindow.style.transform = "none";
        friendsWindow.style.left = rect.left + "px";
        friendsWindow.style.top = rect.top + "px";
        friendsStartPos = {x: rect.left, y: rect.top};
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingFriends) return;
    const dx = e.clientX - dragStartFriends.x;
    const dy = e.clientY - dragStartFriends.y;
    const newX = Math.max(0, Math.min(friendsStartPos.x + dx, window.innerWidth - friendsWindow.offsetWidth));
    const newY = Math.max(0, Math.min(friendsStartPos.y + dy, window.innerHeight - friendsWindow.offsetHeight));
    friendsWindow.style.left = newX + "px";
    friendsWindow.style.top  = newY + "px";
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“¦ CONTAINER LOGICA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let openContainer = null; // Het container object dat momenteel open is

function openContainerWindow(obj) {
    // NIEUW: Sluit andere container/pouch vensters om conflicten te voorkomen
    // Dit zorgt ervoor dat de state (openContainer, openPouch) niet gedeeld wordt.
    document.getElementById('containerWindow').style.display = 'none';
    document.getElementById('pouchWindow').style.display = 'none';
    openContainer = null;
    openPouch = null;

    openContainer = obj;
    // Initialiseer items array als die nog niet bestaat
    if (!openContainer.items) {
        openContainer.items = [];
    }
    
    const containerWindow = document.getElementById('containerWindow');
    const containerTools = document.getElementById('containerTools');
    const containerContent = document.getElementById('containerContent');

    if (obj.isPouch || obj.type === 'pouch') {
        return openPouchWindow(obj);
    }
    
    // Update de titel van het venster
    containerWindow.querySelector('#containerHeader span').textContent = obj.name || 'Container';
    
    // Reset tools en content hoogte
    containerTools.innerHTML = '';
    containerTools.style.display = 'none';
    containerContent.style.height = 'calc(100% - 36px)';

    // Voeg prullenbak-knop toe indien nodig
    if (obj.subCategory === 'trash' || obj.name.includes("Prullenbak")) {
        containerTools.style.display = 'flex';
        containerContent.style.height = 'calc(100% - 36px - 51px)'; // 36px header + 51px tools

        const trashBtn = document.createElement('button');
        trashBtn.className = 'tool-btn';
        trashBtn.style.background = 'transparent';
        trashBtn.style.border = 'none';
        trashBtn.title = 'Leegmaken';

        const trashIcon = document.createElement('img');
        trashIcon.src = 'icons/trash.png';
        trashIcon.style.width = '24px';
        trashIcon.style.height = '24px';

        trashBtn.appendChild(trashIcon);

        trashBtn.onclick = () => {
            // Voer alleen actie uit als er items zijn om te verwijderen
            if (openContainer && openContainer.items.length > 0) {
                // Verander icoon naar 'actief'
                trashIcon.src = 'icons/trash_active.png';

                // Leeg de items array
                openContainer.items = []; 
                
                // Wacht even, dan her-render en zet icoon terug
                setTimeout(() => {
                    renderContainerItems(); // Her-render de (nu lege) container
                    trashIcon.src = 'icons/trash.png';
                }, 200);
            }
        };
        containerTools.appendChild(trashBtn);
    }

    // Bepaal de grootte van het venster op basis van de vorm van het object
    
    if (obj.height >= 2) {
        // "Hoge container" (Grote Container) -> Dun maar lang, als een locker
        containerWindow.style.width = "170px";
        containerWindow.style.height = "550px";
        obj.columns = 1;
    } else if (obj.width >= 2 || obj.depth >= 2) {
        // "Brede container" en "Brede prullenbak" -> Stuk breder
        containerWindow.style.width = "450px";
        containerWindow.style.height = "300px"; // Standaard hoogte
        obj.columns = 4; // Ruimte voor 4 kolommen
    } else {
        // Standaard voor "Container" en "Prullenbak"
        containerWindow.style.width = "260px";  // Standaard breedte voor 2 kolommen
        containerWindow.style.height = "300px"; // Standaard hoogte
        obj.columns = 2;
    }

    containerWindow.style.display = 'flex';
    renderContainerItems();
    
    // Open ook de inventory voor gemak
    inventory.style.left = "150px"; // Reset positie voor netheid
    inventory.style.display = 'flex';
    document.querySelector('#inventoryBtn img').src = "icons/inventory_active.png";
    renderInventoryItems();
}

document.getElementById('closeContainerBtn').addEventListener('click', () => {
    document.getElementById('containerWindow').style.display = 'none';
    openContainer = null;
});

const pouchWindow = document.getElementById('pouchWindow');
const closePouchBtn = document.getElementById('closePouchBtn');
let openPouch = null;

function openPouchWindow(pouchItem) {
    openPouch = pouchItem;
    if (!openPouch.items) {
        openPouch.items = [];
    }

    let title = pouchItem.name || 'Pouch';
    const isCigPack = pouchItem.type === 'sigaretten_container' || pouchItem.itemType === 'sigaretten_container';

    // Forceer naam voor sigaretten container
    if (isCigPack) {
        title = "Pakje sigaretten";
        pouchWindow.style.width = "300px";
        pouchWindow.style.height = "180px";
    } else {
        pouchWindow.style.width = "260px";
        pouchWindow.style.height = "300px";
    }

    pouchWindow.querySelector('#pouchHeader span').textContent = title;
    pouchWindow.style.display = 'flex';
    bringToFront(pouchWindow);
    renderPouchItems();
}

if (closePouchBtn) {
    closePouchBtn.addEventListener('click', () => {
        pouchWindow.style.display = 'none';
        openPouch = null;
    });
}

function renderContainerItems() {
    if (!openContainer) return;
    const content = document.getElementById('containerContent');
    content.innerHTML = '';
    
    const cols = openContainer.columns || 2; // Default naar 2 als niet ingesteld

    openContainer.items.forEach((item, index) => {
        // Self-healing: herstel afbeelding indien nodig
        if (!item.image) {
            const hydrated = createItemFromData(item);
            item.image = hydrated.image;
        }

        const div = document.createElement("div");
        div.className = "inventory-item";
        const imgSrc = item.image ? item.image.src : '';
        
        // Default positie als die er nog niet is
        if (item.conX === undefined) {
            item.conX = (index % cols) * 110 + 20;
            item.conY = Math.floor(index / cols) * 110 + 20;
        }
        
        div.style.position = 'absolute';
        div.style.left = item.conX + 'px';
        div.style.top = item.conY + 'px';
        div.innerHTML = `<img src="${imgSrc}">`;
        
        div.addEventListener("mousedown", (e) => {
            // Breng item naar voorgrond
            div.style.zIndex = ++highestContainerZ;
            
            // Update array volgorde
            const idx = openContainer.items.indexOf(item);
            if (idx > -1) {
                openContainer.items.push(openContainer.items.splice(idx, 1)[0]);
            }

            e.preventDefault();
            if (e.button === 0) {
                // Start met verplaatsen BINNEN de container
                isRearrangingContainer = true;
                activeContainerItem = item;
                
                const rect = div.getBoundingClientRect();
                containerDragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                e.stopPropagation();
            }
        });
        content.appendChild(div);
    });
}

function renderPouchItems() {
    if (!openPouch) return;
    const content = document.getElementById('pouchContent');
    content.innerHTML = '';
    
    const isCigPack = openPouch.type === 'sigaretten_container' || openPouch.itemType === 'sigaretten_container';

    openPouch.items.forEach((item, index) => {
        // Self-healing: herstel afbeelding indien nodig
        if (!item.image) {
            const hydrated = createItemFromData(item);
            item.image = hydrated.image;
        }

        const div = document.createElement("div");
        div.className = "inventory-item";
        const imgSrc = item.image ? item.image.src : '';
        
        if (isCigPack) {
            // Statische grid layout voor sigaretten (3 rijen: 7, 6, 7)
            let row, col;
            let xOffset = 29; // Gecentreerd in 300px
            
            if (index < 7) {
                row = 0;
                col = index;
            } else if (index < 13) {
                row = 1;
                col = index - 7;
                xOffset += 17.5; // Verspringing voor honingraat effect
            } else {
                row = 2;
                col = index - 13;
            }
            
            div.style.width = '32px';
            div.style.height = '32px';
            div.style.padding = '0';
            div.style.transform = 'scale(1)'; // Voorkom dat sigaretten 6x schalen
            
            // Bereken vaste positie
            item.conX = col * 35 + xOffset;
            item.conY = row * 35 + 25;
        } else if (item.conX === undefined) {
            item.conX = (index % 2) * 110 + 20;
            item.conY = Math.floor(index / 2) * 110 + 20;
        }
        
        div.style.position = 'absolute';
        div.style.left = item.conX + 'px';
        div.style.top = item.conY + 'px';
        
        if (isCigPack) {
            let displayImg = imgSrc;
            // Gebruik speciaal icoon als het een sigaret in het pakje is
            if (item.type === 'sigaret' || item.itemType === 'sigaret') {
                displayImg = 'icons/sigaret_in_container.png';
            } else if (item.type === 'sigaret_half' || item.itemType === 'sigaret_half') {
                displayImg = 'icons/sigaret_H_in_container.png';
            }
            div.innerHTML = `<img src="${displayImg}" style="width:100%; height:100%; object-fit:contain;">`;
        } else {
            div.innerHTML = `<img src="${imgSrc}">`;
        }
        
        div.addEventListener("mousedown", (e) => {
            div.style.zIndex = ++highestContainerZ;
            
            const idx = openPouch.items.indexOf(item);
            if (idx > -1) {
                openPouch.items.push(openPouch.items.splice(idx, 1)[0]);
            }

            e.preventDefault();
            if (e.button === 0) {
                // Voor sigarettenpakje: sta slepen toe (om eruit te halen), 
                // maar herschikken binnenin wordt door de statische render overruled.
                // We starten wel de drag logica zodat 'mousemove' werkt voor het eruit slepen.
                
                isRearrangingContainer = true; // Hergebruik vlag
                activePouchItem = item; // Gebruik aparte variabele
                
                const rect = div.getBoundingClientRect();
                containerDragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                e.stopPropagation();
            }
        });
        content.appendChild(div);
    });
}

let lastPhysicsSync = 0; // NIEUW: Throttle timer

function updateItems(delta) {
    const friction = 0.90; // AANGEPAST: Iets meer frictie (was 0.92) voor strakkere stop
    const dirtyItems = []; // NIEUW: Lijst met items die bewogen hebben

    items.forEach(item => {
        // Sla over als het item wordt versleept
        if (item === draggedItem) return;

        // Pas snelheid toe op positie
        item.x += item.vx * delta;
        item.y += item.vy * delta;

        // Pas frictie toe op snelheid
        item.vx *= friction;
        item.vy *= friction;

        // Stop beweging als de snelheid heel laag is om eindeloos glijden te voorkomen
        if (Math.abs(item.vx) < 0.001) item.vx = 0;
        if (Math.abs(item.vy) < 0.001) item.vy = 0;

        // --- BONUS: Stuiter Logica (Z-as) ---
        // Bereken de hoogte van de grond/tafel op de huidige positie
        const tileX = Math.floor(item.x);
        const tileY = Math.floor(item.y);
        const groundZ = getSurfaceHeight(tileX, tileY);

        // NIEUW: Forceer item omhoog als het onder de grond zit (bijv. object geplaatst)
        if ((item.z || 0) < groundZ) {
            item.z = groundZ;
            item.vz = 0;
        }

        // Pas zwaartekracht toe als het item in de lucht is of snelheid heeft
        if ((item.z !== undefined && item.z > groundZ) || (item.vz && item.vz !== 0)) {
            item.vz -= 2.0 * delta; // Zwaartekracht
            item.z += item.vz * delta;

            if (item.z < groundZ) {
                item.z = groundZ;
                item.vz *= -0.3; // AANGEPAST: Nog minder hard stuiteren
                if (Math.abs(item.vz) < 2) item.vz = 0; // Stop met stuiteren bij lage snelheid
            }
        }

        // --- Rotatie Logica ---
        if (item.canRotate) {
            item.rotation += item.vr * delta;
            item.vr *= 0.95; // Wrijving op rotatie
        }

        // --- Topple Logica (Omvallen) ---
        if (item.canTopple) {
            item.rotation += item.vr * delta;
            
            // Zwaartekracht effect: trek naar +/- 90 graden (PI/2) als hij niet rechtop staat
            if (Math.abs(item.rotation) < Math.PI / 2) {
                 // Hoe schuiner, hoe sneller hij valt (sinus van de hoek)
                 // We voegen een klein beetje 'wiebel' toe als hij bijna recht staat
                 item.vr += Math.sin(item.rotation) * 0.02 * delta;
                 item.vr *= 0.99; // Luchtweerstand
            } else {
                // Raakt de grond (clamp op 90 graden)
                item.rotation = Math.sign(item.rotation) * Math.PI / 2;
                item.vr *= -0.3; // Stuiter een beetje terug
                if(Math.abs(item.vr) < 0.01) item.vr = 0; // Stop met stuiteren
                item.vr *= 0.8; // Wrijving op de grond
            }
        }

        // Simpele muur-collision
        if (item.x < 0.5) { item.x = 0.5; item.vx *= -0.5; }
        if (item.x > mapW - 0.5) { item.x = mapW - 0.5; item.vx *= -0.5; }
        if (item.y < 0.5) { item.y = 0.5; item.vy *= -0.5; }
        if (item.y > mapH - 0.5) { item.y = mapH - 0.5; item.vy *= -0.5; }

        // NIEUW: Check of item significant beweegt of in de lucht is
        const isMoving = item.vx !== 0 || item.vy !== 0 || item.vz !== 0 || item.vr !== 0;
        const isAirborne = (item.z || 0) > getSurfaceHeight(Math.floor(item.x), Math.floor(item.y)) + 0.1;
        
        // NIEUW: Stuur alleen updates als WIJ de eigenaar zijn (voorkomt fighting/jitter)
        if (item.id && item.lastTouchedBy === mySocketId) {
            if (isMoving || isAirborne) {
                item.isResting = false;
                dirtyItems.push({
                    id: item.id,
                    x: item.x, y: item.y, z: item.z || 0,
                    vx: item.vx, vy: item.vy, vz: item.vz || 0,
                    rotation: item.rotation || 0, vr: item.vr || 0,
                    lastTouchedBy: mySocketId
                });
            } else if (!item.isResting) {
                // Het item is net gestopt: stuur een laatste update met 0 snelheid
                item.isResting = true;
                dirtyItems.push({
                    id: item.id,
                    x: item.x, y: item.y, z: item.z || 0,
                    vx: 0, vy: 0, vz: 0,
                    rotation: item.rotation || 0, vr: 0,
                    lastTouchedBy: mySocketId
                });
            }
        }
    });

    // NIEUW: Stuur updates naar server (max 20 keer per seconde)
    const now = Date.now();
    if (dirtyItems.length > 0 && socket && (now - lastPhysicsSync > 50)) {
        socket.emit('updateItemPhysics', dirtyItems);
        lastPhysicsSync = now;
    }
}

function updateOtherPlayers(delta) {
    const jumpSpeed = 4.5; // Iets sneller dan lokaal (3) om lag in te halen
    const jumpHeight = 12;

    Object.keys(otherPlayers).forEach(id => {
        const p = otherPlayers[id];
        if (p.moving) {
            p.progress += jumpSpeed / 60 * delta;

            if (p.progress >= 1) {
                p.progress = 1;
                p.x = p.targetX;
                p.y = p.targetY;
                p.moving = false;
                p.hopOffset = 0;
            } else {
                // Lineaire interpolatie (lerp)
                p.x = p.startX + (p.targetX - p.startX) * p.progress;
                p.y = p.startY + (p.targetY - p.startY) * p.progress;
                // Hop effect
                p.hopOffset = jumpHeight * 4 * p.progress * (1 - p.progress);
            }
        }

        // NIEUW: Laat items ook reageren op andere spelers (visuele interactie)
        items.forEach(item => {
            if (item === draggedItem) return;
            
            const dx = item.x - p.x;
            const dy = item.y - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const minDist = 0.6;

            if (dist < minDist) {
                const pushForce = Math.min(0.15, 0.05 / item.mass);
                const angle = Math.atan2(dy, dx);
                // We passen kracht toe, maar claimen GEEN ownership. 
                // De andere speler doet dat in zijn eigen game, wij simuleren het hier voor direct resultaat.
                item.vx += Math.cos(angle) * pushForce;
                item.vy += Math.sin(angle) * pushForce;
                
                if (item.canRotate) item.vr += (Math.random() - 0.5) * 0.5;
                if (item.canTopple) item.vr += (Math.random() - 0.5) * 0.2;
            }
        });
    });
}

function updateBall(delta) {
    // Snelheid van de sprong per seconde
    const jumpSpeed = 3; // 3 tiles per second


    if(!jumping && path.length > 0){
        // start van midden van tegel horizontaal, onderkant verticaal
        jumpStart = { 
            x: Math.floor(ball.x) + 0.5, 
            y: Math.floor(ball.y) + 0.5 // onderkant op tegel
        };
        const next = path.shift();
        jumpEnd = { 
            x: next.x + 0.5, 
            y: next.y + 0.5 
        };
        jumpProgress = 0;
        jumping = true;
    }

    if(jumping){
        jumpProgress += jumpSpeed / 60 * delta; // /60 omdat de oude snelheid 0.05 was (1/20)
        if(jumpProgress >= 1){
            jumpProgress = 1;
            ball.x = jumpEnd.x;
            ball.y = jumpEnd.y;
            jumping = false;
            hopOffset = 0;
            
            // Sla positie op voor refresh
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room') || 'default';
            localStorage.setItem(`habboCloneLastPos_${roomId}`, JSON.stringify({x: ball.x, y: ball.y}));

            // Als het pad leeg is, maak de highlight leeg
            if (path.length === 0) {
                highlightedPath = [];
            }

            if(path.length > 0){
                jumpStart = { x: ball.x, y: ball.y };
                const next = path.shift();
                jumpEnd = { x: next.x + 0.5, y: next.y + 0.5 };
                jumpProgress = 0;
                jumping = true;
                
                if (socket) {
                    socket.emit('playerMovement', { x: jumpEnd.x, y: jumpEnd.y, isSmoking: isSmoking, smokingItemType: ball.smokingItemType }); // NIEUW: Stuur rookstatus mee bij lopen
                }
            }
        } else {
            // interpolatie
            ball.x = jumpStart.x + (jumpEnd.x - jumpStart.x) * jumpProgress;
            ball.y = jumpStart.y + (jumpEnd.y - jumpStart.y) * jumpProgress;
            hopOffset = jumpHeight * 4 * jumpProgress * (1 - jumpProgress);
        }
    } else hopOffset = 0;

    // Speler-item collision
    items.forEach(item => {
        // Sla over als het item wordt versleept
        if (item === draggedItem) return;

        const dx = item.x - ball.x;
        const dy = item.y - ball.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = 0.6; // Hoe dichtbij de speler moet zijn om te duwen

        if (distance < minDistance) {
            // Cap de kracht zodat lichte items (zoals peuken) niet gelanceerd worden
            const pushForce = Math.min(0.15, 0.05 / item.mass);
            const angle = Math.atan2(dy, dx);
            item.lastTouchedBy = mySocketId; // NIEUW: Wij zijn nu de eigenaar omdat we duwen
            item.vx += Math.cos(angle) * pushForce;
            item.vy += Math.sin(angle) * pushForce;

            // Laat ronde items draaien als je ertegenaan loopt
            if (item.canRotate) {
                item.vr += (Math.random() - 0.5) * 0.5; // Geef een willekeurige draai
            }
            
            // Laat topple items omvallen als je ertegenaan loopt
            if (item.canTopple) {
                item.vr += (Math.random() - 0.5) * 0.2; // Geef een zetje om balans te verstoren
            }
        }
    });

    // --- Check afstand tot open interacties (Winkel / Container) ---
    const shopWindow = document.getElementById('shopWindow');
    const containerWindow = document.getElementById('containerWindow');
    const maxDistance = 1.5; // Maximale afstand in tegels voordat venster sluit

    // Check Winkel
    if (shopWindow.style.display === 'flex' && currentOpenShop) {
        const dx = currentOpenShop.x - ball.x;
        const dy = currentOpenShop.y - ball.y;
        // Gebruik manhattan distance of euclidische afstand naar de rand van het object
        // Simpele check: afstand tot het midden van het object
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > maxDistance + 1) { // +1 marge voor de grootte van het object
            document.getElementById('closeShopBtn').click(); // Gebruik de sluit-knop logica
        }
    }

    // Check Container
    if (containerWindow.style.display === 'flex' && openContainer) {
        const dx = openContainer.x - ball.x;
        const dy = openContainer.y - ball.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > maxDistance + 1) {
             document.getElementById('closeContainerBtn').click(); // Gebruik de sluit-knop logica
        }
    }
}

let isDraggingChat = false;
let dragStartChat = {x:0, y:0};
let chatStartPos = {x:0, y:0};

chatLog.addEventListener("mousedown", (e) => {
    bringToFront(chatLog);
    isDraggingChat = true;
    dragStartChat = {x: e.clientX, y: e.clientY};
    
    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#chatLog')) {
        e.stopPropagation();
    }

    const rect = chatLog.getBoundingClientRect();
    chatStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingChat) return;

    const dx = e.clientX - dragStartChat.x;
    const dy = e.clientY - dragStartChat.y;

    const newX = chatStartPos.x + dx;
    const newY = chatStartPos.y + dy;

    const rect = chatLog.getBoundingClientRect();

    const minX = 0;
    const minY = 0;
    const maxX = window.innerWidth - rect.width;
    const maxY = window.innerHeight - rect.height;

    chatLog.style.left = Math.max(minX, Math.min(newX, maxX)) + "px";
    chatLog.style.top  = Math.max(minY, Math.min(newY, maxY)) + "px";
});

buildMenu.addEventListener("mousedown", (e) => {
    // Alleen slepen als we op de header klikken
    if (!e.composedPath().includes(document.getElementById('buildMenuHeader'))) return;
    bringToFront(buildMenu);

    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#buildMenu')) {
        e.stopPropagation();
    }


    isDraggingBuild = true;
    dragStartBuild = {x: e.clientX, y: e.clientY};
    const rect = buildMenu.getBoundingClientRect();
    buildStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingBuild) return;

    const dx = e.clientX - dragStartBuild.x;
    const dy = e.clientY - dragStartBuild.y;

    const newX = Math.max(0, Math.min(buildStartPos.x + dx, window.innerWidth - buildMenu.offsetWidth));
    const newY = Math.max(0, Math.min(buildStartPos.y + dy, window.innerHeight - buildMenu.offsetHeight));

    buildMenu.style.left = newX + "px";
    buildMenu.style.top  = newY + "px";
});

inventory.addEventListener("mousedown", (e) => {
    // Alleen slepen als we op de header klikken
    if (!e.composedPath().includes(document.getElementById('inventoryHeader'))) return;
    bringToFront(inventory);

    // Voorkom dat de canvas een 'mousedown' event ontvangt als we op een UI-element klikken
    if (e.target.closest('#inventory')) {
        e.stopPropagation();
    }


    isDraggingInventory = true;
    dragStartInventory = {x: e.clientX, y: e.clientY};
    const rect = inventory.getBoundingClientRect();
    inventoryStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingInventory) return;

    const dx = e.clientX - dragStartInventory.x;
    const dy = e.clientY - dragStartInventory.y;

    const newX = Math.max(0, Math.min(inventoryStartPos.x + dx, window.innerWidth - inventory.offsetWidth));
    const newY = Math.max(0, Math.min(inventoryStartPos.y + dy, window.innerHeight - inventory.offsetHeight));

    inventory.style.left = newX + "px";
    inventory.style.top  = newY + "px";
});

// Sleep logica voor container header
const containerWindow = document.getElementById('containerWindow');
const containerHeader = document.getElementById('containerHeader');
let isDraggingContainer = false;
let dragStartContainer = {x:0, y:0};
let containerStartPos = {x:0, y:0};

containerHeader.addEventListener("mousedown", (e) => {
    bringToFront(containerWindow);
    isDraggingContainer = true;
    dragStartContainer = {x: e.clientX, y: e.clientY};
    const rect = containerWindow.getBoundingClientRect();
    containerWindow.style.left = rect.left + "px";
    containerWindow.style.top = rect.top + "px";
    containerStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingContainer) return;

    const dx = e.clientX - dragStartContainer.x;
    const dy = e.clientY - dragStartContainer.y;
    const newX = Math.max(0, Math.min(containerStartPos.x + dx, window.innerWidth - containerWindow.offsetWidth));
    const newY = Math.max(0, Math.min(containerStartPos.y + dy, window.innerHeight - containerWindow.offsetHeight));
    containerWindow.style.left = newX + "px";
    containerWindow.style.top  = newY + "px";
});

// Sleep logica voor pouch header
const pouchHeader = document.getElementById('pouchHeader');
let isDraggingPouch = false;
let dragStartPouch = {x:0, y:0};
let pouchStartPos = {x:0, y:0};

if (pouchHeader) {
    pouchHeader.addEventListener("mousedown", (e) => {
        bringToFront(pouchWindow);
        isDraggingPouch = true;
        dragStartPouch = {x: e.clientX, y: e.clientY};
        const rect = pouchWindow.getBoundingClientRect();
        pouchWindow.style.left = rect.left + "px";
        pouchWindow.style.top = rect.top + "px";
        pouchStartPos = {x: rect.left, y: rect.top};
        e.preventDefault();
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingPouch) return;

    const dx = e.clientX - dragStartPouch.x;
    const dy = e.clientY - dragStartPouch.y;
    const newX = Math.max(0, Math.min(pouchStartPos.x + dx, window.innerWidth - pouchWindow.offsetWidth));
    const newY = Math.max(0, Math.min(pouchStartPos.y + dy, window.innerHeight - pouchWindow.offsetHeight));
    pouchWindow.style.left = newX + "px";
    pouchWindow.style.top  = newY + "px";
});

// Sleep logica voor rooms header
const roomsHeader = document.getElementById('roomsHeader');
let isDraggingRooms = false;
let dragStartRooms = {x:0, y:0};
let roomsStartPos = {x:0, y:0};

if (roomsHeader) {
    roomsHeader.addEventListener("mousedown", (e) => {
        bringToFront(roomsWindow);
        isDraggingRooms = true;
        dragStartRooms = {x: e.clientX, y: e.clientY};
        const rect = roomsWindow.getBoundingClientRect();
        roomsWindow.style.transform = "none";
        roomsWindow.style.left = rect.left + "px";
        roomsWindow.style.top = rect.top + "px";
        roomsStartPos = {x: rect.left, y: rect.top};
    });
}

window.addEventListener("mousemove", (e) => {
    if (!isDraggingRooms) return;
    const dx = e.clientX - dragStartRooms.x;
    const dy = e.clientY - dragStartRooms.y;
    const newX = Math.max(0, Math.min(roomsStartPos.x + dx, window.innerWidth - roomsWindow.offsetWidth));
    const newY = Math.max(0, Math.min(roomsStartPos.y + dy, window.innerHeight - roomsWindow.offsetHeight));
    roomsWindow.style.left = newX + "px";
    roomsWindow.style.top  = newY + "px";
});

window.addEventListener("mouseup", (e) => {
    // Stop met het slepen van UI-elementen
    isDraggingChat = false;
    isDraggingBuild = false;
    isDraggingInventory = false;
    isDraggingPong = false; // Stop pong slepen
    isDraggingShop = false;
    isDraggingContainer = false;
    isDraggingRooms = false;
    isDraggingPouch = false;
    isDraggingMyRoom = false;
    isDraggingRoomPlayers = false;
    isDraggingFriends = false;

    // Stop met het slepen van de camera (rechtermuisknop)
    if (e.button === 2) {
        isCameraDragging = false;
    }

    // Handel het loslaten van een gesleept object af, ongeacht waar de muis is
    if (isObjectDragging && e.button === 0) { // Alleen voor linkermuisknop
        const {x, y} = toTile(e.clientX, e.clientY);
        const playerOnTile = Math.floor(ball.x) === x && Math.floor(ball.y) === y;
        
        // Check geldigheid (rekening houdend met width/depth)
        const w = draggedObject.flipped ? (draggedObject.depth || 1) : (draggedObject.width || 1);
        const d = draggedObject.flipped ? (draggedObject.width || 1) : (draggedObject.depth || 1);
        let isValidPlacement = true;
        for(let dx = 0; dx < w; dx++) {
            for(let dy = 0; dy < d; dy++) {
                const tx = x + dx;
                const ty = y + dy;
                if (tx >= mapW || ty >= mapH || isBlocked(tx, ty) || (Math.floor(ball.x) === tx && Math.floor(ball.y) === ty)) isValidPlacement = false;
            }
        }

        if (isValidPlacement) {
            draggedObject.x = x;
            draggedObject.y = y;
        } else {
            // Plaats terug op de originele positie als de nieuwe plek ongeldig is
            draggedObject.x = draggedObjectOriginalPos.x;
            draggedObject.y = draggedObjectOriginalPos.y;
        }
        objects.push(draggedObject); // Voeg het object (terug) toe aan de wereld

        // Reset alle sleep-gerelateerde variabelen
        draggedObject = null;
        draggedObjectOriginalPos = null;
        isObjectDragging = false;
        movePreview.style.display = 'none';

        // Start het soepel terugkeren van de camera als deze was meebewogen
        if (camOriginalPos) {
            camTargetX = camOriginalPos.x;
            camTargetY = camOriginalPos.y;
            camSmooth = true;
            camOriginalPos = null;
        }

        // Heropen de vensters die open stonden
        if (windowStatesBeforeDrag) {
            if (windowStatesBeforeDrag.chat) document.getElementById('chatLog').style.display = windowStatesBeforeDrag.chat;
            if (windowStatesBeforeDrag.inventory) document.getElementById('inventory').style.display = windowStatesBeforeDrag.inventory;
            // Voor het bouwmenu moeten we de 'isBuildMode' vlag correct zetten
            if (windowStatesBeforeDrag.build === 'flex') {
                buildBtn.click(); // Simuleer een klik om de bouwmodus correct te heractiveren
            }
            if (windowStatesBeforeDrag.pouch === 'flex') {
                buildBtn.click(); // Simuleer een klik om de bouwmodus correct te heractiveren
            }
            windowStatesBeforeDrag = null; // Reset de opgeslagen staat
        }
        return; // Belangrijk: stop verdere uitvoering om te voorkomen dat de speler gaat lopen.
    }

    // Stop camera slepen met rechtermuisknop
    if (isCameraDragging && e.button === 2) {
        isCameraDragging = false;
    }
});

window.addEventListener("mousemove", e => {
    // --- Logica voor verplaatsen BINNEN pouch ---
    if (isRearrangingContainer && activePouchItem) {
        const rect = pouchWindow.getBoundingClientRect();
        
        // Check of de muis BUITEN de pouch komt -> Switch naar wereld-sleep
        if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
            isRearrangingContainer = false;
            
            const index = openPouch.items.indexOf(activePouchItem);
            if (index > -1) openPouch.items.splice(index, 1);
            renderPouchItems();
            savePlayerData();
            
            draggedItem = activePouchItem;
            isItemDragging = true;
            isDraggingFromContainer = true; // Hergebruik vlag
            isDraggingFromInventory = false;
            isDraggingFromShop = false;
            draggedItemOriginalPos = null;
            
            dragImageElement = document.createElement('img');
            dragImageElement.src = draggedItem.image.src;
            dragImageElement.style.position = 'absolute';
            dragImageElement.style.pointerEvents = 'none';
            dragImageElement.style.zIndex = '9999';
            dragImageElement.style.imageRendering = 'pixelated';
            const w = (draggedItem.image.width || 64) * scale;
            const h = (draggedItem.image.height || 64) * scale;
            dragImageElement.style.width = w + 'px';
            dragImageElement.style.left = (e.clientX - w/2) + 'px';
            dragImageElement.style.top = (e.clientY - h/2) + 'px';
            document.body.appendChild(dragImageElement);
            
            activePouchItem = null;
            return;
        }

        const contentRect = document.getElementById("pouchContent").getBoundingClientRect();
        activePouchItem.conX = e.clientX - contentRect.left - containerDragOffset.x;
        activePouchItem.conY = e.clientY - contentRect.top - containerDragOffset.y;
        renderPouchItems();
    }

    // NIEUW: Check voor pending pickup beweging
    // Als we wachten op pickup (muis ingedrukt op item) en we bewegen de muis significant,
    // start dan direct het slepen (drag & drop gedrag).
    if (pendingPickup) {
        const dist = Math.sqrt(Math.pow(e.clientX - pendingPickup.x, 2) + Math.pow(e.clientY - pendingPickup.y, 2));
        if (dist > 5) { // 5 pixels drempel
            performItemPickup(pendingPickup.item, e.clientX, e.clientY);
        }
    }
});

// --- Sleep Logica voor Pong Game ---
const pongGame = document.getElementById('pongGame');
const pongHeader = document.getElementById('pongHeader');
let isDraggingPong = false;
let dragStartPong = {x:0, y:0};
let pongStartPos = {x:0, y:0};

pongHeader.addEventListener("mousedown", (e) => {
    if (pongRunning) return; // Niet slepen tijdens het spelen
    if (e.target.closest('.close-btn')) return; // Niet slepen als we op sluiten klikken

    isDraggingPong = true;
    dragStartPong = {x: e.clientX, y: e.clientY};
    
    // Omdat pongGame standaard gecentreerd is met transform, moeten we dit omzetten naar absolute posities
    // bij de eerste keer slepen, anders verspringt hij.
    const rect = pongGame.getBoundingClientRect();
    pongGame.style.transform = "none"; // Verwijder de centrering
    pongGame.style.left = rect.left + "px";
    pongGame.style.top = rect.top + "px";
    
    pongStartPos = {x: rect.left, y: rect.top};
    e.preventDefault();
});

window.addEventListener("mousemove", (e) => {
    if (!isDraggingPong) return;

    const dx = e.clientX - dragStartPong.x;
    const dy = e.clientY - dragStartPong.y;

    const newX = Math.max(0, Math.min(pongStartPos.x + dx, window.innerWidth - pongGame.offsetWidth));
    const newY = Math.max(0, Math.min(pongStartPos.y + dy, window.innerHeight - pongGame.offsetHeight));

    pongGame.style.left = newX + "px";
    pongGame.style.top  = newY + "px";
});


// Initieel renderen van de bouw-items (ook al is het menu verborgen)
renderBuildItems();

setInterval(() => {
    const now = Date.now();
    const currentId = socket ? (socket.id || mySocketId) : 'local';
    const myActiveMessages = chatMessages
        .filter(m => {
            const isMe = (m.userId && m.userId === myUserId) || (!m.userId && (m.id === currentId || m.id === 'local'));
            return isMe && (now - m.time < m.duration);
        })
        .sort((a, b) => a.time - b.time);

    if (myActiveMessages.length >= 5) {
        const oldest = myActiveMessages[0];
        const remaining =
            Math.max(
                0,
                Math.ceil((oldest.duration - (now - oldest.time)) / 1000)
            );

        chatInput.disabled = true;
        chatInput.value = "";
        chatInput.placeholder = `Even wachten (${remaining}s)`;
    } else {
        chatInput.disabled = false;
        chatInput.placeholder = "Typ hier je bericht...";
        chatInput.style.color = "#000";
    }
}, 250);

// NIEUW: Aparte loop voor spellogica (blijft draaien in achtergrond via setInterval)
function gameLogic() {
    const now = Date.now();
    const deltaTime = now - lastLogicTime;
    lastLogicTime = now;

    const delta = deltaTime / (1000 / 60); // delta is ~1.0 bij 60fps
    
    updateItems(delta);
    updateBall(delta);
    updateOtherPlayers(delta);
    updateCamera(delta);
}

// Start de logic loop op ~60fps
setInterval(gameLogic, 1000 / 60);

function renderLoop() {
    // Reset transform naar fysieke pixels (inclusief DPR)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false; // Standaard voor de hele frame: scherpe pixels

    // --- Camera pan tijdens slepen van object ---
    if (isObjectDragging) { // Gebruik de nieuwe variabele
        const panZone = 100; // De grootte van de zone aan de randen van het scherm
        const panSpeed = 5 * delta;

        if (mousePos.x < panZone) camX += panSpeed;
        if (mousePos.x > window.innerWidth - panZone) camX -= panSpeed;
        if (mousePos.y < panZone) camY += panSpeed;
        if (mousePos.y > window.innerHeight - panZone) camY -= panSpeed;

        // Update de target voor als we stoppen met slepen
        camOriginalPos.x = camX;
        camOriginalPos.y = camY;
    }
    // --- Einde camera pan ---

    // Clear het hele scherm (gebruik logische coordinaten omdat dpr in transform zit)
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.setTransform(
        scale * dpr, 0, 0, scale * dpr,
        (window.innerWidth / 2 + camX) * dpr,
        (window.innerHeight / 4 + camY) * dpr
    );

    drawTiles();
    drawPlacementOutline();
    drawTopWall();
    drawLeftWall();
    drawFreeWallObjects(); // NIEUW: Teken vrije muurobjecten op de voorgrond

    // --- Dieptegesorteerde renderlijst ---
    const renderList = [];
    let playerAdded = false;
    const playerTileX = Math.floor(ball.x);
    const playerTileY = Math.floor(ball.y);

    // OPTIMALISATIE: Maak een snelle lookup set voor item posities
    // Dit voorkomt dat we voor elk object door alle items moeten loopen (wat traag is bij veel items)
    const itemOccupiedTiles = new Set();
    items.forEach(item => {
        itemOccupiedTiles.add(`${Math.floor(item.x)},${Math.floor(item.y)}`);
    });

    // Voeg objecten toe aan de renderlijst
    objects.forEach(obj => {
        const w = obj.flipped ? (obj.depth || 1) : (obj.width || 1);
        const d = obj.flipped ? (obj.width || 1) : (obj.depth || 1);
        
        // Genereer dynamisch de lijst met tegels die "achter" dit object liggen
        // Dit zijn de tegels direct ten noorden (y-1) en westen (x-1) van de bounding box
        let behindTiles = [];
        
        // Rij boven het object
        for(let i = 0; i < w; i++) {
            behindTiles.push({ x: obj.x + i, y: obj.y - 1 });
        }
        // Kolom links van het object
        for(let j = 0; j < d; j++) {
            behindTiles.push({ x: obj.x - 1, y: obj.y + j });
        }
        // De hoek linksboven
        behindTiles.push({ x: obj.x - 1, y: obj.y - 1 });

        // Voor hoge objecten voegen we extra tegels toe (simpele benadering)
        if (obj.height === 2) {
            behindTiles.push({ x: obj.x - 1, y: obj.y - 2 }); // Twee boven, een links (209)
            behindTiles.push({ x: obj.x - 2, y: obj.y - 2 }); // Twee boven, twee links (208)
            behindTiles.push({ x: obj.x - 2, y: obj.y - 1 }); // Een boven, twee links (233)
        }

        // Check of speler achter het object staat OF in het object staat (voor tile 106/131 etc)
        const isPlayerBehind = behindTiles.some(t => playerTileX === t.x && playerTileY === t.y);
        const isPlayerInside = playerTileX >= obj.x && playerTileX < obj.x + w && playerTileY >= obj.y && playerTileY < obj.y + d;

        // Check of een item achter het object staat
        const isItemBehind = behindTiles.some(t => itemOccupiedTiles.has(`${t.x},${t.y}`));
        
        // Bepaal de sorteersleutel op basis van het midden van het object voor betere sortering
        let sortKey = (obj.x + (w - 1) / 2) + (obj.y + (d - 1) / 2);
        if (obj.isFloor) sortKey -= 0.1; // Zorg dat vloeren onder objecten op dezelfde tegel komen

        // Voeg het object toe aan de lijst
        renderList.push({
            type: 'object',
            // We gebruiken nu een expliciete sortKey ipv x/y
            sortKey: sortKey,
            x: obj.x, // Voor debug/referentie
            y: obj.y, // Voor debug/referentie
            draw: () => {
                const centerX = obj.x + (w - 1) / 2;
                const centerY = obj.y + (d - 1) / 2;
                const { sx, sy } = toScreen(centerX, centerY);
                
                ctx.save();

                // Maak object transparant als de speler erachter staat OF erin staat (behalve vloeren)
                ctx.globalAlpha = (!obj.isFloor && (isPlayerBehind || isPlayerInside || isItemBehind)) ? 0.5 : 1;
                
                // Highlight logica
                if (isBuildMode) {
                    let shouldHighlight = false;
                    let highlightFilter = "";

                    // Selectie highlight (Verplaatsen/Verwijderen)
                    if ((buildTool === 'move' || buildTool === 'delete') && !movingObject) {
                        if (hoveredObjects.length > 0 && hoveredObjects[moveSelectionIndex] === obj) {
                            shouldHighlight = true;
                            highlightFilter = buildTool === 'delete' ? "sepia(1) hue-rotate(-50deg) saturate(5)" : "brightness(1.5)";
                        }
                    }
                    // Stacking highlight (Plaatsen)
                    else if ((buildTool === 'place' || movingObject) && hoverCell) {
                         const w = obj.flipped ? (obj.depth || 1) : (obj.width || 1);
                         const d = obj.flipped ? (obj.width || 1) : (obj.depth || 1);
                         if (hoverCell.x >= obj.x && hoverCell.x < obj.x + w && 
                             hoverCell.y >= obj.y && hoverCell.y < obj.y + d) {
                             if (obj !== movingObject && !obj.isFloor) {
                                 shouldHighlight = true;
                                 highlightFilter = "brightness(1.5)";
                             }
                         }
                    }

                    if (shouldHighlight) {
                        ctx.filter = highlightFilter;
                    }
                }

                const isTall = obj.height === 2;
                const isWide = obj.width === 2; // Check voor brede objecten
                let finalImg;

                    if (obj.runtimeImage) {
                        finalImg = obj.runtimeImage;
                    } else if (obj.name === "Pong") {
                    finalImg = pongImg;
                } else if (obj.name === "Winkel") {
                    finalImg = winkelImg;
                } else if (obj.name === "Brede Winkel") {
                    finalImg = winkelImg96B;
                } else if (obj.name === "Container") {
                    finalImg = containerImg;
                } else if (obj.name === "Prullenbak") {
                    finalImg = trashImg;
                } else if (obj.name === "Brede Prullenbak") {
                    finalImg = trashImg96B;
                } else if (obj.name === "Grote Container") {
                    finalImg = containerImg96;
                } else if (obj.name === "Brede Container") {
                    finalImg = containerImg96B;
                } else if (obj.name === "Prullenbak") {
                    finalImg = trashImg;
                } else if (obj.name === "Brede Prullenbak") {
                    finalImg = trashImg96B;
                } else if (obj.isFloor) {
                    finalImg = floorImg;
                } else if (obj.moveable) {
                    finalImg = isWide ? moveableObjectImg96B : moveableObjectImg;
                } else {
                    if (isWide) {
                        finalImg = objectImg96B;
                    } else if (isTall) {
                        finalImg = objectImg96;
                    } else {
                        finalImg = objectImg;
                    }
                }

                const imgWidth = finalImg.width || 64; // Gebruik de werkelijke breedte
                const imgHeight = finalImg.height || (isTall ? 96 : 64); // Gebruik de werkelijke hoogte

                if (obj.flipped) {
                    ctx.scale(-1, 1);
                }

                // NIEUW: Gebruik handmatige offsets als die er zijn (voor custom objects)
                if (obj.isCustom && obj.xOffset !== undefined) {
                    // Bereken positie op basis van de offset uit de editor
                    // sx, sy is de top van de middelste tegel.
                    // We willen dat het punt (xOffset, yOffset) in het plaatje overeenkomt met de top-left van de collision box in de wereld.
                    // De collision box in de wereld begint bij toScreen(obj.x, obj.y).
                    
                    const origin = toScreen(obj.x, obj.y);
                    // In de editor is xOffset/yOffset de afstand van linksboven plaatje naar linksboven box.
                    // Dus plaatje moet getekend worden op: WereldBoxPositie - Offset
                    
                    const drawX = origin.sx - obj.xOffset;
                    const drawY = origin.sy - obj.yOffset;

                    ctx.drawImage(finalImg, obj.flipped ? -drawX - imgWidth : drawX, drawY, imgWidth, imgHeight);
                } else {
                    // OUDE LOGICA (voor standaard objecten)
                    // Bereken de verticale offset op basis van de dimensies zodat het object netjes op de vloer staat
                    const totalDim = (obj.width || 1) + (obj.depth || 1);
                    const verticalOffset = totalDim * 8 + 16;

                    ctx.drawImage(
                        finalImg,
                        obj.flipped ? -sx - imgWidth/2 : sx - imgWidth/2, // horizontaal centreren op basis van breedte
                        sy - imgHeight + verticalOffset, // Dynamische verticale correctie
                        imgWidth, // Gebruik dynamische breedte
                        imgHeight // Gebruik dynamische hoogte
                    );
                }

                ctx.restore();
            }
        });
    });

    // Voeg items toe aan de renderlijst
    items.forEach(item => {
        // Sla over als het item wordt versleept, want die wordt apart getekend
        if (item === draggedItem) return;

        let sortKey = Math.floor(item.x) + Math.floor(item.y);

        // FIX: Als item op een object ligt, zorg dat het ALTIJD na dat object getekend wordt
        // Dit lost het probleem op dat items op de 'achterste' tegel van een tafel erachter vallen.
        const tileX = Math.floor(item.x);
        const tileY = Math.floor(item.y);
        const objUnder = objects.find(o => {
             const w = o.flipped ? (o.depth || 1) : (o.width || 1);
             const d = o.flipped ? (o.width || 1) : (o.depth || 1);
             return tileX >= o.x && tileX < o.x + w && tileY >= o.y && tileY < o.y + d;
        });
        
        if (objUnder && (item.z || 0) >= ((objUnder.height || 1) * 32)) {
             const w = objUnder.flipped ? (objUnder.depth || 1) : (objUnder.width || 1);
             const d = objUnder.flipped ? (objUnder.width || 1) : (objUnder.depth || 1);
             const objSortKey = (objUnder.x + (w - 1) / 2) + (objUnder.y + (d - 1) / 2);
             // Forceer item net iets voor het object in de sortering
             if (sortKey <= objSortKey) sortKey = objSortKey + 0.01;
        }

        renderList.push({
            type: 'item',
            sortKey: sortKey,
            draw: () => {
                const { sx, sy } = toScreen(item.x, item.y);
                
                // Bereken de tekenpositie inclusief de stuiter-hoogte (z)
                const drawY = sy - (item.z || 0);

                ctx.save();
                
                // Highlight logica voor items
                let shouldHighlight = false;
                let highlightFilter = "";

                // 1. Verwijderen (Rood)
                if (isBuildMode && buildTool === 'delete' && hoverCell) {
                    if (Math.floor(item.x) === hoverCell.x && Math.floor(item.y) === hoverCell.y) {
                        // Check of er een object bovenop ligt (objecten hebben voorrang bij verwijderen)
                        const objectOnTile = objects.find(o => {
                            const w = o.flipped ? (o.depth || 1) : (o.width || 1);
                            const d = o.flipped ? (o.width || 1) : (o.depth || 1);
                            return hoverCell.x >= o.x && hoverCell.x < o.x + w && hoverCell.y >= o.y && hoverCell.y < o.y + d;
                        });
                        
                        // Gebruik de selectie uit het menu als die er is (hoveredObjects)
                        if (hoveredObjects.length > 0) {
                            if (hoveredObjects[moveSelectionIndex] === item) {
                                shouldHighlight = true;
                                highlightFilter = "sepia(1) hue-rotate(-50deg) saturate(5)";
                            }
                        } 
                        // Fallback voor als menu nog niet geupdate is of leeg is (zou niet moeten gebeuren met mousemove logic)
                        else if (!objectOnTile) {
                            shouldHighlight = true;
                            highlightFilter = "sepia(1) hue-rotate(-50deg) saturate(5)";
                        }
                    }
                }
                // 2. Oppakken (Wit) - Alleen in speelmodus
                else if (!isBuildMode && !isItemDragging && !isObjectDragging && hoverCell) {
                    if (Math.floor(item.x) === hoverCell.x && Math.floor(item.y) === hoverCell.y) {
                        const dist = Math.sqrt(Math.pow(Math.floor(ball.x) - Math.floor(item.x), 2) + Math.pow(Math.floor(ball.y) - Math.floor(item.y), 2));
                        shouldHighlight = true;
                        if (dist <= 2) {
                            highlightFilter = "brightness(1.5)";
                        } else {
                            highlightFilter = "sepia(1) hue-rotate(-50deg) saturate(5)";
                        }
                    }
                }
                // 3. Verplaatsen (Wit) - Bouwmodus
                else if (isBuildMode && buildTool === 'move' && !movingObject && hoveredObjects.length > 0) {
                    if (hoveredObjects[moveSelectionIndex] === item) {
                        shouldHighlight = true;
                        highlightFilter = "brightness(2)";
                    }
                }

                if (shouldHighlight && highlightFilter) {
                    ctx.filter = highlightFilter;
                }

                // Verplaats naar het midden van waar het item getekend moet worden
                ctx.translate(sx, drawY);
                // Roteer als het item dat kan
                if (item.canRotate) {
                    ctx.rotate(item.rotation || 0);
                    ctx.drawImage(
                        item.image,
                        -item.image.width / 2, // Teken gecentreerd op het rotatiepunt
                        -item.image.height / 2
                    );
                } else if (item.canTopple) {
                    ctx.rotate(item.rotation || 0);
                    ctx.drawImage(
                        item.image,
                        -item.image.width / 2, // Horizontaal gecentreerd
                        -item.image.height     // Verticaal: ankerpunt onderaan
                    );
                } else {
                    ctx.drawImage(
                        item.image,
                        -item.image.width / 2,
                        -item.image.height / 2
                    );
                }

                ctx.restore();
            }
        });
    });

    // Voeg ANDERE spelers toe aan de renderlijst
    Object.keys(otherPlayers).forEach(id => {
        const p = otherPlayers[id];
        renderList.push({
            type: 'otherPlayer',
            sortKey: Math.floor(p.x) + Math.floor(p.y),
            draw: () => {
                drawCharacter(p.x, p.y, false, p.color || "green", p.hopOffset || 0, p.isSmoking, p.smokingStartTime, p.smokingItemType, p.isDrinking, p.drinkingStartTime, p.drinkingItemType);
            }
        });
    });

    // Voeg de speler toe aan de renderlijst
    renderList.push({
        type: 'player',
        sortKey: playerTileX + playerTileY,
        draw: drawBall
    });

    // Voeg de bouw-preview toe aan de renderlijst voor correcte diepte
    const objectToPreview = (selectedBuildObject?.placement === 'floor' && selectedBuildObject) || movingObject || draggedObject;
    if (objectToPreview && hoverCell) {
        // Check geldigheid (rekening houdend met width/depth)
        const isFlipped = (objectToPreview === selectedBuildObject) ? isBuildObjectFlipped : (objectToPreview.flipped || false);
        const w = isFlipped ? (objectToPreview.depth || 1) : (objectToPreview.width || 1);
        const d = isFlipped ? (objectToPreview.width || 1) : (objectToPreview.depth || 1);
        let isValidPlacement = true;
        for(let dx = 0; dx < w; dx++) {
            for(let dy = 0; dy < d; dy++) {
                const tx = hoverCell.x + dx;
                const ty = hoverCell.y + dy;
                if (tx >= mapW || ty >= mapH) {
                    isValidPlacement = false;
                } else if (!objectToPreview.isFloor && !objectToPreview.isItem && (isBlocked(tx, ty) || (Math.floor(ball.x) === tx && Math.floor(ball.y) === ty))) {
                    isValidPlacement = false;
                }
            }
        }

        renderList.push({
                type: 'preview',
                sortKey: (hoverCell.x + (w - 1) / 2) + (hoverCell.y + (d - 1) / 2),
                draw: () => {
                    const centerX = hoverCell.x + (w - 1) / 2;
                    const centerY = hoverCell.y + (d - 1) / 2;
                    const { sx, sy } = toScreen(centerX, centerY);
                    const isTall = objectToPreview.height === 2;
                    const isWide = objectToPreview.width === 2;
                    let finalImg;

                    if (objectToPreview.runtimeImage) {
                        finalImg = objectToPreview.runtimeImage;
                    } else if (objectToPreview.image && objectToPreview.image.src) {
                        finalImg = objectToPreview.image;
                    } else if (objectToPreview.name === "Pong") {
                        finalImg = pongImg;
                    } else if (objectToPreview.name === "Winkel") {
                        finalImg = winkelImg;
                    } else if (objectToPreview.name === "Brede Winkel") {
                        finalImg = winkelImg96B;
                    } else if (objectToPreview.name === "Container") {
                        finalImg = containerImg;
                    } else if (objectToPreview.name === "Grote Container") {
                        finalImg = containerImg96;
                    } else if (objectToPreview.name === "Brede Container") {
                        finalImg = containerImg96B;
                    } else if (objectToPreview.name === "Prullenbak") {
                        finalImg = trashImg;
                    } else if (objectToPreview.name === "Brede Prullenbak") {
                        finalImg = trashImg96B;
                    } else if (objectToPreview.isFloor) {
                        finalImg = floorImg;
                    } else if (objectToPreview.moveable) {
                        finalImg = isWide ? moveableObjectImg96B : moveableObjectImg;
                    } else {
                        if (isWide) {
                            finalImg = objectImg96B;
                        } else if (isTall) {
                            finalImg = objectImg96;
                        } else {
                            finalImg = objectImg;
                        }
                    }

                    const imgWidth = finalImg.width || 64;
                    const imgHeight = finalImg.height || (isTall ? 96 : 64);
                    
                    const totalDim = (objectToPreview.width || 1) + (objectToPreview.depth || 1);
                    const verticalOffset = totalDim * 8 + 16;

                    // NIEUW: Hoogte correctie voor items op objecten
                    let zOffset = 0;
                    if (objectToPreview.isItem) {
                        zOffset = getSurfaceHeight(hoverCell.x, hoverCell.y);
                    }

                    ctx.save();
                    
                    // Kleur overlay logic
                    if (isValidPlacement) {
                        ctx.filter = "sepia(1) hue-rotate(90deg) saturate(3)"; // Groene gloed
                    } else {
                        ctx.filter = "sepia(1) hue-rotate(-50deg) saturate(5)"; // Rode gloed
                    }
                    ctx.globalAlpha = 0.6;

                    if (isFlipped) {
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(finalImg, isFlipped ? -sx - imgWidth/2 : sx - imgWidth/2, sy - imgHeight + verticalOffset - zOffset, imgWidth, imgHeight);
                    
                    ctx.restore();
                }
            });
    }
    
    // Sorteer op x+y voor isometrische diepte
    renderList.sort((a,b) => a.sortKey - b.sortKey);

    // Alles tekenen
    for (let item of renderList) {
        item.draw();
    }
    // --- Einde renderlijst ---

    drawInteractionPrompts(); // Teken interactie prompts bovenop de wereld
    drawChatBallon();
    drawPlayerNames(); // NIEUW: Teken namen bij hover

    requestAnimationFrame(renderLoop);
}

requestAnimationFrame(renderLoop); // Start de render loop

})(); // Einde van de IIFE

</script>
</body>
</html>
